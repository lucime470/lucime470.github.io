<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL基础</title>
    <url>/2025/08/27/MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>MySQL基础</h1>
<h2 id="1-启动和关闭">1. 启动和关闭</h2>
<h3 id="1-cmd">1.cmd</h3>
<ul>
<li>
<p>win加r进入运行输入cmd，ctrl加shift加enter以管理员模式运行</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> mysql80</span><br></pre></td></tr></table></figure>
<p>其中<strong>mysql80</strong> 为服务名，同样以</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> stop mysql80</span><br></pre></td></tr></table></figure>
<p>结束运行。</p>
</li>
</ul>
<h3 id="2-服务">2.服务</h3>
<ul>
<li>win加r进入运行输入<strong>services.msc</strong> ，进入后找到<strong>MySQL80</strong> 右键运行或停止。</li>
</ul>
<h2 id="2-客户端连接">2. 客户端连接</h2>
<h3 id="1-MySQL提供的工具">1.MySQL提供的工具</h3>
<ul>
<li>进入后直接输入密码连接。</li>
</ul>
<h3 id="2-cmd">2.cmd</h3>
<ul>
<li>
<p>win加r进入运行输入cmd，ctrl加shift加enter以管理员模式运行，（这里已经将mysql添加到环境变量，可以在任意路径下运行）输入</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysql -h <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> -P <span class="number">3306</span> -u root -p</span><br></pre></td></tr></table></figure>
<p>，其中-h后面跟指定地址，-<strong>P</strong> （大写）后跟指定端口，（这两个可以省略），-u后跟指定用户，以root用户进行连接，-p指定密码。</p>
</li>
</ul>
<h2 id="3-数据库概念及模型">3. 数据库概念及模型</h2>
<h3 id="1-概念">1.概念</h3>
<ul>
<li>关系型数据库（RDBMS)
<ul>
<li>由二维表组成，以关系型模型为基础</li>
</ul>
</li>
<li>使用表存储数据，格式统一，便于维护</li>
<li>使用SQL语句进行操作</li>
</ul>
<h3 id="2-数据模型">2.数据模型</h3>
<ol>
<li>
<p>客户端连接MySQL的数据库管理系统DBMS</p>
</li>
<li>
<p>使用SQL语句通过数据库管理系统来创建数据库</p>
</li>
<li>
<p>使用SQL语句在指定的数据库中创建多张表</p>
</li>
<li>
<p>单个数据库服务可以创建多个数据库</p>
</li>
<li>
<p>在表中存储数据</p>
</li>
</ol>
<h2 id="4-SQL语句">4.SQL语句</h2>
<h3 id="1-通用语法">1.通用语法</h3>
<ul>
<li>可以单行或多行书写，和c一样以分号结束</li>
<li>语句中可以用空格和缩进使其美观且不影响</li>
<li>SQL语句不区分大小写，关键字建议用大写</li>
<li>注释
<ul>
<li>单行：-- 或  #</li>
<li>多行：/*     */（同c）</li>
</ul>
</li>
</ul>
<h3 id="2-SQL分类">2.SQL分类</h3>
<h4 id="1-DDL-数据定义语言，用来定义数据库对象（数据库，表，字段）">1.DDL 数据定义语言，用来定义数据库对象（数据库，表，字段）</h4>
<h5 id="1-数据库操作">1.数据库操作</h5>
<p>1.查询</p>
<ul>
<li>
<p>查询所有数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases；</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询当前所处数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database (if <span class="keyword">not</span> <span class="keyword">exists</span> #数据库不存在时则创建，存在时无报错) 数据库名称 （<span class="keyword">default</span> charset 字符集 #例如utf8)  (<span class="keyword">collate</span> 排序规则) ；</span><br></pre></td></tr></table></figure>
<p>3.删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database（if <span class="keyword">exists</span>）数据库名；</span><br></pre></td></tr></table></figure>
<p>4.使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use 数据库名；</span><br></pre></td></tr></table></figure>
<p>#进入一个数据库</p>
<h5 id="2-表操作">2.表操作</h5>
<h6 id="1-查询">1.查询</h6>
<p>1.查询<strong>当前</strong> 数据库中所有表（需要先进入一个数据库）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables；</span><br></pre></td></tr></table></figure>
<p>2.查询表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名；</span><br></pre></td></tr></table></figure>
<p>3.查询指定表的建表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create table</span> 表名；</span><br></pre></td></tr></table></figure>
<h6 id="2-创建">2. 创建</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> tables 表名(</span><br><span class="line"></span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>的类型（comment 字段<span class="number">1</span>的注释）,      #注意逗号</span><br><span class="line"></span><br><span class="line">	字段<span class="number">2</span> 字段<span class="number">2</span>的类型（comment 字段<span class="number">2</span>的注释）,</span><br><span class="line"></span><br><span class="line">	........</span><br><span class="line"></span><br><span class="line">)（comment 表注释）；</span><br></pre></td></tr></table></figure>
<h6 id="3-修改">3.修改</h6>
<p>1.添加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add</span> 字段名 类型（长度） （comment 注释）（约束）;</span><br></pre></td></tr></table></figure>
<p>2.修改数据类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 modify 字段名 新数据类型（长度）;</span><br></pre></td></tr></table></figure>
<p>3.修改字段名和字段类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 change 旧字段名 新字段名 类型(长度) （comment 注释）（约束）;</span><br></pre></td></tr></table></figure>
<p>4.删除字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> 字段名;</span><br></pre></td></tr></table></figure>
<p>5.修改表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 remane <span class="keyword">to</span> 新表名；</span><br></pre></td></tr></table></figure>
<h6 id="4-删除">4.删除</h6>
<p>1.删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> （if <span class="keyword">exists</span>） 表名；</span><br></pre></td></tr></table></figure>
<p>2.删除指定表，并重新创建该表 （保留表结构，但是其中数据删除）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名；</span><br></pre></td></tr></table></figure>
<h5 id="3-数据类型">3.数据类型</h5>
<h6 id="1-数值类型">1.数值类型</h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>有符号（signed）范围</th>
<th>无符号（unsigned）范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>tinyint</strong></td>
<td>1byte</td>
<td>(-128,127)</td>
<td>(0,255)</td>
</tr>
<tr>
<td># <strong>适用例如年龄 age TINYINT UNSIGNED (因为年龄只为正整数，所以用无符号的TINYINT型)</strong></td>
<td># ** 如果储存的是01，那么最终查询出来的也是1，只有用字符串‘01’，最后查询出来的才是01**</td>
<td></td>
<td></td>
</tr>
<tr>
<td>smallint</td>
<td>2bytes</td>
<td>(-32768,32767)</td>
<td>(0,65535)</td>
</tr>
<tr>
<td>mediumint</td>
<td>3bytes</td>
<td>(-8388608,8388607)</td>
<td>(0,16777215)</td>
</tr>
<tr>
<td>int或integer</td>
<td>4bytes</td>
<td>(-2147483648,2147483647)</td>
<td>(0,4294967295)</td>
</tr>
<tr>
<td>bigint</td>
<td>8bytes</td>
<td>(-2^63,(2^63)-1)</td>
<td>(0,(2^64)-1)</td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>4bytes</td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>与double相比较内存小运算快</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>double</strong></td>
<td>8bytes</td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>适用例如分数(一百分制)   score double(4,1) 但是更适合用float</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>decimal</td>
<td>依赖于M(精度)和D(标度)的值</td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>精度即为整个数的位数，标度为小数点位数，例如256.13精度为5，标度为2</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>float是单精度浮点数  double是双精度浮点数 decimal是以字符串形式储存的精确小数</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>#<strong>float 和 double都是二进制近似计算，计算可能有舍入误差，且有精度范围，但decimal可自定义精度精确小数，且为十进制计算完全精准，适用于财务货币等精确计算</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="2-字符串类型">2.字符串类型</h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>char</strong></td>
<td>0-255 bytes</td>
<td>定长** 字符串</td>
</tr>
<tr>
<td># <strong>char(10)数字为储存的最大字符数，存储十以内的字符都占用十个字符，未占用的用空格补位，如果删除所有字符串即用update修改值为‘ ’空字符串，显示会是空字符串，而不是null</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>varchar(10)会根据存储内容计算所要空间，因为要计算所以性能要比char差，但是存储空间利用率就高</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>varchar</strong></td>
<td>0-65536 bytes</td>
<td>** 变长**字符串</td>
</tr>
<tr>
<td>tinyblob</td>
<td>0-255 bytes</td>
<td>二进制数据</td>
</tr>
<tr>
<td>tinytext</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>blob</td>
<td>0-65535 bytes</td>
<td>二进制长文本</td>
</tr>
<tr>
<td>text</td>
<td>0-65535 bytes</td>
<td>长文本</td>
</tr>
<tr>
<td>mediumblob</td>
<td></td>
<td>二进制中等长度文本</td>
</tr>
<tr>
<td>mediumtext</td>
<td></td>
<td>中等长度文本</td>
</tr>
<tr>
<td>longblob</td>
<td></td>
<td>二进制极大文本</td>
</tr>
<tr>
<td>longtext</td>
<td></td>
<td>极大文本</td>
</tr>
</tbody>
</table>
<h6 id="6-日期类型">6.日期类型</h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>date</strong></td>
<td>3</td>
<td>1000-01-01至9999-12-31</td>
<td>YYYY-MM-DD</td>
</tr>
<tr>
<td># <strong>日期值</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>time</td>
<td>3</td>
<td>-838:59:59至838:59:59</td>
<td>HH:MM:SS</td>
</tr>
<tr>
<td># <strong>时间值或持续时间</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>year</td>
<td>1</td>
<td>1901至2155</td>
<td>YYYY</td>
</tr>
<tr>
<td># <strong>年份值</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>datetime</td>
<td>8</td>
<td>1000-01-01 00:00:00至9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
</tr>
<tr>
<td># <strong>混合日期和时间值</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-01-01 00:00:01至2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
</tr>
<tr>
<td># <strong>混合日期和时间值，时间戳</strong></td>
<td></td>
<td># ** 这个2038问题是时间戳导致的问题**</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="2-DML-数据操作语言，用来对数据库中的数据进行增删改">2.DML 数据操作语言，用来对数据库中的数据进行增删改</h4>
<h5 id="1-添加数据">1.添加数据</h5>
<h6 id="1-给指定字段添加数据">1.给指定字段添加数据</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 字段<span class="number">1</span>，字段<span class="number">2</span>，....... <span class="keyword">values</span> 值<span class="number">1</span>，值<span class="number">2</span>，........;</span><br></pre></td></tr></table></figure>
<p># 如果值是字符串或日期数据类型，则要加引号</p>
<h6 id="2-给全部字段添加数据">2.给全部字段添加数据</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 <span class="keyword">values</span> 值<span class="number">1</span>，值<span class="number">2</span>，........;</span><br></pre></td></tr></table></figure>
<p>#即值1对应字段1，值2对应字段2，…</p>
<h6 id="3-批量添加数据">3.批量添加数据</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 字段<span class="number">1</span>，字段<span class="number">2</span>，....... <span class="keyword">values</span> 值<span class="number">1</span>，值<span class="number">2</span>，........，值<span class="number">1</span>，值<span class="number">2</span>，........，值<span class="number">1</span>，值<span class="number">2</span>，........;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 <span class="keyword">values</span>  值<span class="number">1</span>，值<span class="number">2</span>，........，值<span class="number">1</span>，值<span class="number">2</span>，........，值<span class="number">1</span>，值<span class="number">2</span>，........;</span><br></pre></td></tr></table></figure>
<h6 id="2-修改数据">2.修改数据</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,字段名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,.........（<span class="keyword">where</span> 条件）;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这里的条件就是把某几个符合这个条件的数据修改，例如修改id为1的这一条数据的name，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> name<span class="operator">=</span>值<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>那么所有id为1的数据中的name都变为值1</p>
</li>
<li>
<p>如果不加where 条件则修改所有的name都变为值1，会警告</p>
</li>
<li>
<p>同样如果值是字符串或日期数据类型，则要加引号</p>
</li>
</ul>
<h6 id="3-删除数据">3.删除数据</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 （<span class="keyword">where</span> 条件）；</span><br></pre></td></tr></table></figure>
<ul>
<li>同样如果不加条件则删除所有数据</li>
<li>删除的不是某个字段而是整条数据</li>
<li>如果要删除某个字段的值则是要用<strong>update</strong> 来修改，字段=null</li>
</ul>
<h4 id="3-DQL-数据查询语言，用来查询数据库中表的记录">3.DQL 数据查询语言，用来查询数据库中表的记录</h4>
<h5 id="1-语法">1.语法</h5>
<ul>
<li><strong>select</strong> 字段列表</li>
<li><strong>from</strong> 表名列表</li>
<li><strong>where</strong> 条件列表</li>
<li><strong>group by</strong> 分组字段列表</li>
<li><strong>having</strong> 分组后条件列表</li>
<li><strong>order by</strong> 排序字段列表</li>
<li><strong>limit</strong> 分页参数</li>
</ul>
<h5 id="2-基本查询">2.基本查询</h5>
<h6 id="1-查询多个字段">1.查询多个字段</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> ，字段<span class="number">2</span>，字段<span class="number">3</span>,........<span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p>#记得加逗号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p>#  *指查询返回所有字段，尽量直接写出所有字段，提高可读性</p>
<h6 id="2-设置别名">2.设置别名</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> <span class="keyword">as</span> 别名<span class="number">1</span>，字段<span class="number">2</span> <span class="keyword">as</span> 别名<span class="number">2</span>，........<span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p># 这里as可以省略</p>
<ul>
<li>表名后面也可以设置别名</li>
</ul>
<h6 id="3-去除重复记录">3.去除重复记录</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段列表 <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p># 这里字段后面也可以加as来设置别名，同样可以省略</p>
<ul>
<li>纯数字别名必须加引号（单双都可以）但是最终查询出来的别名还是‘数字’</li>
</ul>
<h5 id="3-条件查询">3.条件查询</h5>
<h6 id="1-语法-2">1.语法</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件列表；</span><br></pre></td></tr></table></figure>
<ul>
<li>查询出来的符合条件的字段列表，如果用*来代替则查询出来的是符合条件的一整条数据</li>
</ul>
<h6 id="2-条件">2.条件</h6>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>and 或 &amp;&amp;</td>
<td>并且（多个条件同时成立）</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>or 或 ||</td>
<td>或者（任一条件成立）</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>not 或 !</td>
<td>非</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td></td>
<td></td>
</tr>
<tr>
<td>=</td>
<td>等于</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;&gt;或!=</td>
<td>不等于</td>
<td></td>
<td></td>
</tr>
<tr>
<td>between…and…</td>
<td>在某个范围内（包含最大和最小值）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>in(…)</td>
<td>在in后跟的列表中的数值满足其一即可</td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>例如select * from  newwork where age in (12,18,20) ;即查询年龄为12，18，20的整条数据</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>like 占位符</td>
<td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>例如select * from  newwork where name like ’</strong> __<strong>'；即查询名字为两个字符的整条数据，这里是两个下划线</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>例如select * from  newwork where card_id like ‘%9’;即查询身份证最后一位是9的整条数据</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>也可以select * from  newwork where card_id like ‘%8_’;即查询倒数第二位是8的整条数据</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>is null</td>
<td>字段为null</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="4-分组查询">4.分组查询</h5>
<h6 id="1-语法-3">1.语法</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表<span class="number">1</span>，字段列表<span class="number">2</span>，... <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件 <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名<span class="number">1</span>，字段名<span class="number">2</span>,... <span class="keyword">having</span> 分组后过滤条件</span><br></pre></td></tr></table></figure>
<h6 id="2-where和having的区别">2.where和having的区别</h6>
<ul>
<li>执行时间：where在分组前使用，having在分组后使用对结果过滤</li>
<li>判断条件：where的条件不允许使用聚合函数，having可以</li>
</ul>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> gender,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> newwork <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br></pre></td></tr></table></figure>
<p>即统计所有数据中每种性别的个数，同时会显示性别</p>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> age <span class="keyword">from</span> newwork <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;___&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>
<p>即先筛选名字为三个字符串的，再按年龄分组</p>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> age,<span class="built_in">count</span>(age) <span class="keyword">from</span> newwork <span class="keyword">where</span> card_id <span class="keyword">like</span> <span class="string">&#x27;%9&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">having</span> <span class="built_in">count</span>(age)<span class="operator">&lt;</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>即分组前先查询身份证最后一位是9的，然后按年龄分组，最后having统计出所有年龄中相同年龄个数小于5个的个数</p>
<p># 一般查询的字段列表是聚合函数或者分组字段，查询其他会报错，禁用报错后也只会显示该类数据的第一个</p>
<p>#这里同样可以设置别名</p>
<h5 id="5-排序查询">5.排序查询</h5>
<h6 id="1-语法-4">1.语法</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式，字段<span class="number">2</span> 排序方式；</span><br></pre></td></tr></table></figure>
<h6 id="2-排序方式">2.排序方式</h6>
<ul>
<li>asc：升序（可省略）</li>
<li>desc：降序</li>
</ul>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> newwork <span class="keyword">order</span> <span class="keyword">by</span>  age <span class="keyword">asc</span>,id <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure>
<p>即所有数据先按年龄升序排序，有相同年龄的则按id数字降序排序</p>
<h6 id="3-注意">3.注意</h6>
<ul>
<li>多字段排序时，，当第一个字段值相同时，才会根据第二个字段进行排序</li>
</ul>
<h5 id="6-分页查询">6.分页查询</h5>
<h6 id="1-语法-5">1.语法</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 limit 起始索引，查询记录数；</span><br></pre></td></tr></table></figure>
<h6 id="2-注意">2.注意</h6>
<ul>
<li>起始索引从0开始，和数组一样，所以起始索引=（查询页码-1）* 每页记录数</li>
<li>不同数据库的分页查询不同，MySQL中是limit</li>
<li>起始索引为0，即查询第一页时可以省略起始索引</li>
<li>前面可以加where，order by，group by 。limit是再整个语句的最后使用</li>
</ul>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> newwork limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>即从第一页查询所有数据，每页3条数据</p>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> newwork limit <span class="number">5</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>即每页5条数据，从第二页开始查询</p>
<h5 id="7-执行顺序">7.执行顺序</h5>
<ul>
<li>1.from</li>
<li>2.where</li>
<li>3.group by</li>
<li>4.having</li>
<li>5.select</li>
<li>6.order by</li>
<li>7.limit</li>
</ul>
<p># 需要注意执行顺序，再设置别名，才能正常使用别名</p>
<h4 id="4-DCL-数据控制语言，用来创建数据库用户，控制访问权限">4.DCL 数据控制语言，用来创建数据库用户，控制访问权限</h4>
<h5 id="1-管理用户">1.管理用户</h5>
<h6 id="1-查询用户">1.查询用户</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mysql； #用户表存放在MySQL的mysql数据库中，所以要先进入这个数据库 </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>
<h6 id="2-创建用户">2.创建用户</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> ‘用户名’@‘主机名’ identified <span class="keyword">by</span> ‘密码’；</span><br></pre></td></tr></table></figure>
<h6 id="3-修改用户密码">3.修改用户密码</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> ‘用户名’@‘主机名’ identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> ‘新密码’；</span><br></pre></td></tr></table></figure>
<h6 id="4-删除用户">4.删除用户</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> ‘用户名’@‘主机名’；</span><br></pre></td></tr></table></figure>
<p># 主机名有localhost即本机，%即任意主机都可以访问此数据库</p>
<h5 id="2-权限控制">2.权限控制</h5>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>all，all privileges</td>
<td>所有权限</td>
</tr>
<tr>
<td>select</td>
<td>查询数据</td>
</tr>
<tr>
<td>insert</td>
<td>插入数据</td>
</tr>
<tr>
<td>update</td>
<td>修改数据</td>
</tr>
<tr>
<td>delete</td>
<td>删除数据</td>
</tr>
<tr>
<td>alter</td>
<td>修改表</td>
</tr>
<tr>
<td>drop</td>
<td>删除数据库/表/视图</td>
</tr>
<tr>
<td>create</td>
<td>创建数据库/表</td>
</tr>
</tbody>
</table>
<h6 id="1-查询权限">1.查询权限</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> ‘用户名’@‘主机名’；</span><br></pre></td></tr></table></figure>
<h6 id="2-授予权限">2.授予权限</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> ‘用户名’@‘主机名’；</span><br></pre></td></tr></table></figure>
<h6 id="3-撤销权限">3.撤销权限</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库.表名 <span class="keyword">from</span> ‘用户名’@‘主机名’；</span><br></pre></td></tr></table></figure>
<h6 id="4-注意">4.注意</h6>
<ul>
<li>数据库和表名可以为*</li>
<li>权限列表可以为多个权限，之间要加，隔开</li>
</ul>
<h2 id="5-函数">5.函数</h2>
<h3 id="1-聚合函数">1.聚合函数</h3>
<ul>
<li>将一列数据作为一个整体，进行纵向计算</li>
</ul>
<h4 id="1-常见聚合函数">1.常见聚合函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
<tr>
<td># null值不参与计算</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="2-语法">2.语法</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数(字段列表)  <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件；</span><br></pre></td></tr></table></figure>
<p># 这里的括号和前面的聚合函数间不能有空格</p>
<h3 id="2-字符串函数">2.字符串函数</h3>
<h4 id="1-常见字符串函数">1.常见字符串函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>concat(S1,S2,…Sn)</td>
<td>字符串拼接，将括号里的拼接成一个字符串</td>
</tr>
<tr>
<td>lower(str)</td>
<td>将字符串str全部转为小写</td>
</tr>
<tr>
<td>upper(str)</td>
<td>将字符串str全部转为大写</td>
</tr>
<tr>
<td>lpad(str,n,pad)</td>
<td>左填充，将字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>rpad(str,n,pad)</td>
<td>右填充，将字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td># n是指填充完的整个字符串为n个，当pad的长度大于n-原字符串长度时，只会填充pad的前n-原字符串长度个</td>
<td></td>
</tr>
<tr>
<td>trim(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>substring(str,start,len)</td>
<td>返回字符串str中从start位置起的len个长度的字符串</td>
</tr>
<tr>
<td># start是数字索引，但是这里的索引是从1开始的</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="3-数值函数">3.数值函数</h3>
<h4 id="1-常见数值函数">1.常见数值函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ceil(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>mod(x,y)</td>
<td>返回x/y的模（余数）</td>
</tr>
<tr>
<td>rand()</td>
<td>返回0-1内的随机数</td>
</tr>
<tr>
<td># 例如<strong>select lpad(round(rand()*1000000,0),6,0);</strong> 可以用作生成随机六位数验证码，即先用rand随机出数字再乘1000000，再用round去掉小数，lpad在左边补0</td>
<td></td>
</tr>
<tr>
<td>round(x,y)</td>
<td>求参数x的四舍五入值，保留y位小数</td>
</tr>
<tr>
<td># 例如<strong>select round(206.2658,2);</strong> 返回的值就是206.27</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="4-日期函数">4.日期函数</h3>
<h4 id="1-常见日期函数">1.常见日期函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>curdate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>curtime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>year(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td># 例如<strong>select  year(now());</strong></td>
<td></td>
</tr>
<tr>
<td>month(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>day(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>date_add(date,interval expr type)</td>
<td>返回一个日期或时间值加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td># 例如<strong>select date_add(now(),interval 70 day );</strong> 即当前时间向后推70天的日期和时间，这里interval是固定的，expr是间隔，type是时间类型</td>
<td></td>
</tr>
<tr>
<td>datediff(date1,date2)</td>
<td>返回起始时间date1和结束时间date2之间的天数</td>
</tr>
<tr>
<td># 返回的时间=date1-date2，所以可能会是负数</td>
<td></td>
</tr>
<tr>
<td># 例如<strong>select name,datediff(curdate(),enterdate) as ‘enterdate’ from newwork order by  enterdate desc;</strong> 即计算入职天数并设置其别名为enterdate，再按降序排序</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="5-流程函数">5.流程函数</h3>
<h4 id="1-常见的流程函数">1.常见的流程函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>if(value,t,f)</td>
<td>如果value为true则返回t，否则返回f</td>
</tr>
<tr>
<td>ifnull(value1,value2)</td>
<td>如果value1不为空，返回value1，否则value2</td>
</tr>
<tr>
<td>case when val1 then res1 else default end</td>
<td>如果val1为true，返回res1，…否则返回default</td>
</tr>
<tr>
<td># 例如<strong>select age,name,case when age &lt;18 then ‘y’ when age&gt;18 then ‘a’ else ‘e’ end from newwork;</strong> 即查询年龄在十八以下的为y，十八以上为a，其他为e 。同理可以用于判断成绩优良</td>
<td></td>
</tr>
<tr>
<td>case expr when val1 then res1 else default end</td>
<td>如果expr的值=val1，返回res1，否则default</td>
</tr>
<tr>
<td># 例如<strong>select name, age，case age when 20 then ‘t’ when 19 then ‘n’ end from newwork;</strong> 即查询年龄为20和19的分别返回t和n</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="6-约束">6.约束</h2>
<h3 id="1-概述">1.概述</h3>
<h4 id="1-概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据">1.概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据</h4>
<h4 id="2-目的：保证数据库中的数据的正确有效和完整性">2.目的：保证数据库中的数据的正确有效和完整性</h4>
<h4 id="3-分类：">3.分类：</h4>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>非空约束</td>
<td>限制改字段的数据不能为null</td>
<td>not null</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一，不重复的</td>
<td>unique</td>
</tr>
<tr>
<td>主约束条件</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>primary key</td>
</tr>
<tr>
<td>默认约束条件</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>default</td>
</tr>
<tr>
<td>检查约束</td>
<td>保证字段值满足某一个条件</td>
<td>check</td>
</tr>
<tr>
<td># 8.0.16后才支持检查约束</td>
<td></td>
<td></td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>
<td>foreign key</td>
</tr>
</tbody>
</table>
<h3 id="2-示例">2.示例</h3>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>约束条件</th>
<th>约束关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>int</td>
<td>主键，并且主动增长</td>
<td>primary key，auto_increment</td>
</tr>
<tr>
<td>name</td>
<td>varchar（10）</td>
<td>不为空，并且唯一</td>
<td>not null，unique</td>
</tr>
<tr>
<td>age</td>
<td>int</td>
<td>大于0，并且小于等于120</td>
<td>check</td>
</tr>
<tr>
<td>status</td>
<td>char（1）</td>
<td>如果没有指定该值，默认为1</td>
<td>default</td>
</tr>
<tr>
<td>gender</td>
<td>char（1）</td>
<td>无</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> user1(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not null</span> <span class="keyword">unique</span> ,</span><br><span class="line">        age <span class="type">int</span> <span class="keyword">check</span> ( age<span class="operator">&gt;</span><span class="number">0</span> <span class="operator">&amp;&amp;</span> age<span class="operator">&lt;=</span><span class="number">120</span> ),</span><br><span class="line">        status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line">        gender <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">)comment <span class="string">&#x27;用于学习约束的用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>然后用 <strong>insert</strong> 向表中插入数据</p>
</li>
<li>
<p>注意：如果某一条插入的数据违反了约束那么是不会创建该数据的，但是会向数据库申请一个主键，所以会导致下一次创建数据的时候即使没有违反约束，也会跳过之前没有创建的数据的主键，产生跳号的现象</p>
</li>
<li>
<p>但是主键最核心的是其唯一性，而不是连续性，部分数据库中可以手动填空</p>
</li>
</ul>
<h3 id="3-外键约束">3.外键约束</h3>
<ul>
<li>概念：外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性</li>
</ul>
<h4 id="1-添加外键">1.添加外键</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line"></span><br><span class="line">	字段名 数据类型，</span><br><span class="line"></span><br><span class="line">	.......	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constraint</span> 外键名 <span class="keyword">foreign key</span> （外键字段名） <span class="keyword">references</span> 主表（主表列名）</span><br><span class="line"></span><br><span class="line">	);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名 <span class="keyword">foreign key</span> （外键字段名） <span class="keyword">references</span> 主表（主表列名）</span><br></pre></td></tr></table></figure>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> user1 <span class="keyword">add constraint</span> fk_user1_dept_id <span class="keyword">foreign key</span> (id_for_connent) <span class="keyword">references</span> dept (id);</span><br></pre></td></tr></table></figure>
<p>即将表user1中的id_for_connent与表dept中的id关联并把外键名设置为fk_user1_dept_id</p>
<ul>
<li>如果删除dept中的数据则会报错，以此来保证数据的完整性</li>
</ul>
<h4 id="2-删除外键">2.删除外键</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign key</span> 外键名；</span><br></pre></td></tr></table></figure>
<h4 id="3-删除-更新行为">3.删除/更新行为</h4>
<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no action</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，有则不允许删除/更新</td>
</tr>
<tr>
<td>restrict</td>
<td>同上（默认的）</td>
</tr>
<tr>
<td>cascade</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，有则删除/更新子表中的记录</td>
</tr>
<tr>
<td>set null</td>
<td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，有则设置子表中该外键为null</td>
</tr>
<tr>
<td># 前提是该外键允许取null</td>
<td></td>
</tr>
<tr>
<td>set default</td>
<td>父表有变更时，子表将外键列设置成一个默认的值（MySQL的lnnodb引擎不支持）</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名 <span class="keyword">foreign key</span> （外键字段） <span class="keyword">references</span> 主表名（主表字段名） <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade；</span><br></pre></td></tr></table></figure>
<p>#例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> user1 <span class="keyword">add constraint</span> fk_user1_name_dept_id <span class="keyword">foreign key</span> (id_for_connent) <span class="keyword">references</span> dept (id) <span class="keyword">on</span> <span class="keyword">UPDATE</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade ;</span><br></pre></td></tr></table></figure>
<p>即添加一个外键，并且设置为更新/删除时cascade级联，即对应的更新/删除。其中的cascade可以更换成其他行为</p>
<ul>
<li>这个语法不是直接修改而是创建外键并设定了属性</li>
</ul>
<h2 id="7-多表查询">7.多表查询</h2>
<h3 id="1-多表关系">1.多表关系</h3>
<h4 id="1-一对多（多对一）">1.一对多（多对一）</h4>
<ul>
<li>例如：一个部门可以有多个员工，但是一个员工只能对应一个部门、</li>
<li>实现：在多的一方建立外键，指向少的一方的主键</li>
</ul>
<h4 id="2-多对多">2.多对多</h4>
<ul>
<li>例如：一个学生可以选择多个课程，一门课程可以被多个学生选择</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name,s.no,c.name <span class="keyword">from</span> student.s,student_course sc,course c <span class="keyword">where</span> s.id<span class="operator">=</span>sc.studentid <span class="keyword">and</span> sc.courseid<span class="operator">=</span>c.id;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现：建立第三张中间表，中间表中要有两个外键，分别连接另外两张表的主键</li>
</ul>
<h4 id="3-一对一">3.一对一</h4>
<ul>
<li>例如：每个用户对应其用户信息</li>
<li>实现：<strong>在任意一表中加入外键，再关联到另一个表的主键</strong> ，但是外键要设置约束条件为唯一unique</li>
</ul>
<h3 id="2-多表查询概述">2.多表查询概述</h3>
<ul>
<li>
<p>概述：指从多张表中查询数据</p>
</li>
<li>
<p><strong>笛卡尔积</strong> ：笛卡尔乘积指的是，两个集合的所有组合情况，如果直接用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1,dept;</span><br></pre></td></tr></table></figure>
<p>来查询两张表就会出现笛卡尔积的情况，所以正常查询时可以使用where语句根据具体情况来消除无效的笛卡尔积</p>
</li>
<li>
<h4 id="分类">分类</h4>
</li>
<li>
<p>连接查询</p>
<ul>
<li>
<p>内连接：相当于查询A,B交集部分的数据</p>
</li>
<li>
<p>外连接：</p>
<ul>
<li>左外连接：查询<strong>左表</strong> 所有数据，以及两张表交集部分数据</li>
<li>右外连接：查询<strong>右表</strong> 所有数据，以及两张表交集部分数据</li>
</ul>
</li>
<li>
<p>自连接：当前表与自身的连接查询，自连接必须使用表的别名</p>
</li>
</ul>
</li>
<li>
<p>子查询</p>
</li>
</ul>
<h3 id="3-内连接">3.内连接</h3>
<h4 id="1-隐式内连接">1.隐式内连接</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">where</span> 条件...;</span><br></pre></td></tr></table></figure>
<p>#例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name,d.name <span class="keyword">from</span> user1 u，dept d <span class="keyword">where</span> u.id_for_connent<span class="operator">=</span>d.id;</span><br></pre></td></tr></table></figure>
<p>#注意字段名前面要用表名来限定是哪个表的字段</p>
<p>#可以设置别名，但是设置别名后就不能再使用表名</p>
<h4 id="2-显式内连接">2.显式内连接</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">inner</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 连接条件....;</span><br></pre></td></tr></table></figure>
<p># inner可以省略</p>
<p># 相当于where换成on</p>
<p># 连接条件后面可以再加where条件</p>
<h3 id="4-外连接">4.外连接</h3>
<h4 id="1-左外连接">1.左外连接</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure>
<p># outer可以省略</p>
<p># 查询的是左表即表1的所有数据，包含两个表的交集部分</p>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.<span class="operator">*</span>,d.name <span class="keyword">from</span> user1 u <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> u.id_for_connent<span class="operator">=</span>d.id;</span><br></pre></td></tr></table></figure>
<p>这样即使user1中有部分数据没有与dept中的关联也可以被查询出来</p>
<h4 id="2-右外连接">2.右外连接</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure>
<p># outer可以省略</p>
<p># 查询的是右表即表2的所有数据，包含两个表的交集部分</p>
<p># 可以通过交换两个表名来实现右外连接和左外连接的转换，通常使用左外连接</p>
<h3 id="5-自连接">5.自连接</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> 别名<span class="number">1</span> <span class="keyword">join</span> 表<span class="number">1</span> 别名<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure>
<ul>
<li>自连接可以是内连接，也可以是外连接</li>
</ul>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name,u1.name <span class="keyword">from</span> user1 u ，<span class="keyword">user</span> u1 <span class="keyword">where</span> u.manager_id<span class="operator">=</span>u1.id;</span><br></pre></td></tr></table></figure>
<p># 在一张公司员工表中manager_id表示某一员工的领导的id，这样可以查询出员工的领导是谁</p>
<p># 这里用的是内连接，这样就不会在员工那一栏显示领导，因为领导没有领导，可以用外连接，就能在员工栏显示出领导，领导栏就会显示null</p>
<p># 将一张表视为两张</p>
<h3 id="6-联合查询">6.联合查询</h3>
<ul>
<li>就是把多次查询的结果合并，形成一个新的查询结果集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1.</span>..      #省略号中可以用<span class="keyword">where</span>条件</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span>      				   #<span class="keyword">all</span>可以省略，省略后会去除重复的数据</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">2.</span>..；    #省略号中可以用<span class="keyword">where</span>条件</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>这是一个完整的语句可以将上下两个结果直接合并</strong></li>
</ul>
<p># 注意：上下两个字段的列数和字段类型必须一致，否则会报错</p>
<h3 id="7-子查询">7.子查询</h3>
<ul>
<li>
<p>概念：SQL语句中嵌套select语句，称为子查询（嵌套查询）</p>
</li>
<li>
<p>例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> column1<span class="operator">=</span>（<span class="keyword">select</span> column1 <span class="keyword">from</span> 表<span class="number">2</span>）；</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其中<strong>select column1 from 表2</strong> 就是子查询，其他的外部语句可以是insert/delete/select中任一</p>
</li>
<li>
<p>根据子查询结果不同，可以分为</p>
<ul>
<li>
<p>标量子查询（子查询结果为单个值）</p>
</li>
<li>
<p>列子查询（查询结果为一列）</p>
</li>
<li>
<p>行子查询（查询结果为一行）</p>
</li>
<li>
<p>表子查询（子查询结果为多行多列）</p>
</li>
</ul>
</li>
<li>
<p>根据子查询位置不同，又分为</p>
<ul>
<li>where之后</li>
<li>from之后</li>
<li>select之后</li>
</ul>
</li>
</ul>
<h4 id="1-标量子查询">1.标量子查询</h4>
<ul>
<li>返回结果是单个值（数字，字符串，日期等）</li>
<li>常用操作符：=,&lt;&gt;,&gt;,&gt;=,&lt;，&lt;=</li>
</ul>
<p># 例如：需要查询销售部的员工信息</p>
<ul>
<li>
<p>第一步：查询销售部的id序号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span>‘销售部’；</span><br></pre></td></tr></table></figure>
<p>假设查询出来id=4</p>
</li>
<li>
<p>第二步由id作为查询条件在另一张表查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> id_for_connent<span class="operator">=</span><span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>可得结果</p>
</li>
</ul>
<p># 而标量子查询只需要一步</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> id_for_connent<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span>‘销售部’);</span><br></pre></td></tr></table></figure>
<ul>
<li>因为括号里查询出来的是单个值所以可以用标量子查询</li>
</ul>
<p># 同样字符串和日期也可以用此方法来做</p>
<h4 id="2-列子查询">2.列子查询</h4>
<ul>
<li>返回结果是一列（可以多行）</li>
<li>常用操作符：</li>
</ul>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>在指定的集合范围内，多选一</td>
</tr>
<tr>
<td>not in</td>
<td>不在指定的聚合范围内</td>
</tr>
<tr>
<td>any</td>
<td>子查询返回列表中有任意一个满足即可</td>
</tr>
<tr>
<td>some</td>
<td>与any等同</td>
</tr>
<tr>
<td>all</td>
<td>子查询返回值的所有值都必须满足</td>
</tr>
</tbody>
</table>
<p># 例如查询销售部和研发部的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> id_for_connent <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span>‘销售部’ <span class="keyword">or</span> ‘研发部’);</span><br></pre></td></tr></table></figure>
<p># 例如要获取所有部门中工资大于研发部所有员工工资的员工信息</p>
<ul>
<li>
<p>第一步：先获取研发部的员工工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> user1 <span class="keyword">where</span> id_for_connent<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span> ‘研发部);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第二步：在所有表中查询工资数值大于所有查询到的这些数值的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> salary<span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> user1 <span class="keyword">where</span> id_for_connent<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span> ‘研发部));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-行子查询">3.行子查询</h4>
<ul>
<li>返回结果是一行（可以多列）</li>
<li>常用操作符：=，&lt;&gt;,in,not in</li>
</ul>
<p># 例如：要查询和某个员工的工资和领导完全相同的其他员工的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> (salary,manager)<span class="operator">=</span>(<span class="keyword">select</span> salary，manager <span class="keyword">from</span> user1 <span class="keyword">where</span> name<span class="operator">=</span>‘员工<span class="number">1</span>’）;</span><br></pre></td></tr></table></figure>
<h4 id="4-表子查询">4.表子查询</h4>
<ul>
<li>返回结果是多行多列</li>
<li>常用操作符：in</li>
</ul>
<p># 例如：要查询和某两个员工的工资和领导完全相同的其他员工的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> (salary,manager) <span class="keyword">in</span> (<span class="keyword">select</span> salary，manager <span class="keyword">from</span> user1 <span class="keyword">where</span> name<span class="operator">=</span>‘员工<span class="number">1</span>’ <span class="keyword">or</span> name<span class="operator">=</span>‘员工<span class="number">2</span>’）;</span><br></pre></td></tr></table></figure>
<p># 例如：要查询在2005-01-01后入职的员工的信息和其部门</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.<span class="operator">*</span>,d.<span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> enterdate<span class="operator">&gt;</span><span class="string">&#x27;2005-01-01&#x27;</span>) u <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> u.id_for_connet<span class="operator">=</span>d.id;</span><br></pre></td></tr></table></figure>
<p># 这里将第一次查询出来的内容作为一张表放在from后面，再将这张表与部门表左外连接</p>
<h2 id="8-事务">8.事务</h2>
<h3 id="1-事务简介">1.事务简介</h3>
<ul>
<li>事务是一组操作的合集，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即操作同时成功或同时失败</li>
<li>默认每一条语句都是一个事务，且自动提交</li>
</ul>
<h3 id="2-事务操作">2.事务操作</h3>
<h4 id="1-查看-设置事务提交方式">1.查看/设置事务提交方式</h4>
<h5 id="方法一：">方法一：</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>；</span><br></pre></td></tr></table></figure>
<p># 查询出来为1则是自动提交，为0则是手动提交</p>
<ul>
<li><strong>set @@autocommit=0；</strong></li>
</ul>
<h5 id="方法二：">方法二：</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction 或 <span class="keyword">begin</span> </span><br></pre></td></tr></table></figure>
<p># 自动提交的情况下可以用这种方式，这条语句和下面要执行的语句一起运行</p>
<h4 id="2-提交事务">2.提交事务</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>；</span><br></pre></td></tr></table></figure>
<p># 先运行需要执行的语句然后再运行commit</p>
<h4 id="3-回滚事务">3.回滚事务</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rollback</span>；</span><br></pre></td></tr></table></figure>
<p># 运行报错后不要提交，直接回滚</p>
<h3 id="3-事务四大特性">3.事务四大特性</h3>
<ul>
<li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li>
<li>一致性：事务完成时，必须使所有数据都保持一致状态</li>
<li>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>
</ul>
<p># 即多个事务间互不干扰</p>
<ul>
<li>持续性：事务一旦提交或回滚，它对数据库中的数据的改变是永久的</li>
</ul>
<h3 id="4-并发事务问题">4.并发事务问题</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>脏读</td>
<td>一个事务读到另一个事务还没有提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取到同一条记录，但两次读取的数据不同，称之为不可重复读</td>
</tr>
<tr>
<td># 即在另一个事务提交的前后分别查询了这一条数据，<strong>不可重复读的重点在于数据的修改</strong></td>
<td></td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但在插入数据时，又发现这行数据已经存在</td>
</tr>
<tr>
<td>#即在另一个事务提交的前后分别查询和插入了数据，但是反复查询都显示没有数据，<strong>幻读的重点在于数据的新增和删除</strong></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="5-事务隔离级别">5.事务隔离级别</h3>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>会出现的问题</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>read uncommitted</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>read committed</td>
<td></td>
<td>⨉</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>repeatable read（默认）</td>
<td></td>
<td>⨉</td>
<td>⨉</td>
<td>√</td>
</tr>
<tr>
<td># 不可重复读的问题被解决，变为可重复读，正在执行的事务不会被其他正在执行的事务影响</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>serializable（串行化）</td>
<td></td>
<td>⨉</td>
<td>⨉</td>
<td>⨉</td>
</tr>
<tr>
<td># 用了serializable后当第一个事务先执行时，第二个事务会被阻塞，cmd中回车后光标会一直闪烁直到第一个事务提交，才会执行第二个事务。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td># 从上往下级别越高则数据安全性越高，性能越差</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>查看事务隔离级别</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction_isolation</span>；</span><br></pre></td></tr></table></figure>
<ul>
<li>设置事务隔离级别</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session<span class="operator">/</span><span class="keyword">global</span> transaction isolation level read uncommitted<span class="operator">/</span>read committed<span class="operator">/</span>repeatable read<span class="operator">/</span>serializable；</span><br></pre></td></tr></table></figure>
<p># 其中session是会话级别即进当前客户端窗口，global则针对所有客户端窗口</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL运维</title>
    <url>/2025/08/27/MySQL%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>MySQL运维</h1>
<h2 id="1-日志">1.日志</h2>
<h3 id="1-错误日志">1.错误日志</h3>
<ul>
<li>
<p>错误日志是 MySQL 中最重要的日志之一，它记录了当mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。</p>
</li>
<li>
<p>当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p>
</li>
<li>
<p>该日志是默认开启的，默认存放目录/var/log/，默认的日志文件名为mysqld.log。查看日志位置：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-二进制日志">2.二进制日志</h3>
<h4 id="1-介绍">1.介绍</h4>
<ul>
<li>
<p>二进制日志（binlog）记录了所有ddl（数据定义语言）语句和dml（数据操纵语言）语句，但不包括数据查询（select，show）语句</p>
</li>
<li>
<p>作用：</p>
<ul>
<li>
<p>灾难时的数据恢复，数据库崩溃后再次执行二进制日志中的内容就可以恢复</p>
</li>
<li>
<p>MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启的，涉及参数：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>可以查询到：</p>
<ul>
<li>log_bin：开启或关闭</li>
<li>log_bin_basename：日志文件位置，文件由binlog和编号组成</li>
<li>log_bin_index：索引文件位置</li>
</ul>
</li>
</ul>
<h4 id="2-日志格式">2.日志格式</h4>
<table>
<thead>
<tr>
<th>日志格式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>statement</td>
<td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中</td>
</tr>
<tr>
<td>row</td>
<td>基于行的日志记录，记录的是每一行的数据变更（默认）</td>
</tr>
<tr>
<td>mixed</td>
<td>混合了statement和row两种格式，默认采用statement，在某些特殊情况下会自动切换为row进行记录</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p># 查询日志格式</p>
<p># 需要在文件中修改日志格式</p>
<p># 修改后会在新的日志文件中记录</p>
<h4 id="3-日志查看">3.日志查看</h4>
<ul>
<li>
<p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具mysqlbinlog来查看</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlbinlog 选项 日志文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>选项：</p>
<ul>
<li>-d，指定数据库名称，只列出指定的数据库相关操作</li>
<li>-o，忽略掉日志中的前n行命令</li>
<li>-v，将行事件（数据变更）重构为SQL语句</li>
<li>-w，将行事件（数据变更）重构为SQL语句，并输出注释信息</li>
</ul>
</li>
</ul>
<h4 id="4-日志删除">4.日志删除</h4>
<ul>
<li>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>reset master;</td>
<td>删除全部binlog日志，删除之后，日志编号，将从binlog.000001重新开始</td>
</tr>
<tr>
<td>purge master logs to ‘binlog.xxxxxx’;</td>
<td>删除xxxxxx编号之前的所有日志（此编号不会被删除）</td>
</tr>
<tr>
<td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’;</td>
<td>删除日志为’yyyy-mm-dd hh24:mi:ss’之前产生的所有日志</td>
</tr>
</tbody>
</table>
<ul>
<li>也可以在mysql的配置文件中配置二进制日志的过期时间，设置后，二进制日志过期会自动删除</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_expire_logs_seconds%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p># 默认30天</p>
<h3 id="3-查询日志">3.查询日志</h3>
<ul>
<li>
<p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的</p>
</li>
<li>
<p>涉及参数：general_log</p>
</li>
<li>
<p>修改MySQL的配置文件/etc/my.cnf文件，添加内容：</p>
</li>
<li>
<p><strong>general_log=1</strong></p>
</li>
</ul>
<p># 开启</p>
<ul>
<li>general_log_file=目录/文件名</li>
</ul>
<p># 指定文件名，默认文件名为主机名.log</p>
<h3 id="4-慢查询日志">4.慢查询日志</h3>
<ul>
<li>
<p>慢查询日志记录了所有执行时间超过参数long_query_time 设置值并且扫描记录数不小于min_examined_rowlimit的所有的SQL语句的日志，默认未开启。long_query_time 默认为10秒，最小为0，精度可以到微秒。</p>
</li>
<li>
<p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以在MySQL的配置文件/etc/my.cnf文件中修改log_slow_admin_statements和更改此行为log_queries_not_using_indexes</p>
</li>
<li>
<p><strong>log_slow_admin_statements=1</strong></p>
</li>
</ul>
<p># 记录执行较慢的管理语句</p>
<ul>
<li><strong>log_queries_not_using_indexes=1</strong></li>
</ul>
<p># 记录执行较慢的未使用索引的语句</p>
<h2 id="2-主从复制">2.主从复制</h2>
<h3 id="1-概述">1.概述</h3>
<ul>
<li>
<p>主从复制是指将主数据库的DDL 和 DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库（slave）和主库（master）的数据保持同步。</p>
</li>
<li>
<p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。</p>
</li>
<li>
<p>作用：</p>
<ul>
<li>1.主库出现问题，可以快速切换到从库提供服务。</li>
<li>2.实现读写分离，降低主库的访问压力。</li>
<li>3.可以在从库中执行备份，以避免备份期间影响主库服务。</li>
</ul>
</li>
</ul>
<h3 id="2-原理">2.原理</h3>
<ul>
<li>主要分为三步：
<ul>
<li>1.Master 主库在事务提交时，会把数据变更记录在二进制日志文件 binlog中。</li>
<li>2.从库的IOthread读取主库的二进制日志文件 binlog，写入到从库的中继日志Relay Log。</li>
<li>3.slave从库的SQLthread读取中继日志，再将改变反映它自己的数据。</li>
</ul>
</li>
</ul>
<h3 id="3-搭建">3.搭建</h3>
<h4 id="1-服务器准备">1.服务器准备</h4>
<ul>
<li>
<p>主库和从库</p>
</li>
<li>
<p>关闭服务器的防火墙</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<p># 关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>
<p># 关闭防火墙的开机自启动</p>
<ul>
<li>或者</li>
<li>开放指定的端口号</li>
</ul>
<h4 id="2-主库配置">2.主库配置</h4>
<h5 id="1-修改配置文件-etc-my-cnf">1.修改配置文件/etc/my.cnf</h5>
<ul>
<li><strong>server-id=1</strong></li>
</ul>
<p># mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1，默认为1</p>
<ul>
<li><strong>read-only=0</strong></li>
</ul>
<p># 是否只读，1代表只读，0代表读写</p>
<ul>
<li><strong>binlog-ignore-db=数据库名</strong></li>
</ul>
<p># 忽略数据库，指不需要同步的数据库</p>
<ul>
<li><strong>binlog-do-db=数据库名</strong></li>
</ul>
<p># 指定同步的数据库</p>
<h5 id="2-重启MySQL服务器">2.重启MySQL服务器</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
<p># 没有报错则配置成功</p>
<h5 id="3-登录mysql，创建远程连接的账号，并授予主从复制权限">3.登录mysql，创建远程连接的账号，并授予主从复制权限</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p># 创建用户，并设置密码，因为主机名设置为%所以该用户可在任意主机连接该MySQL服务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p># 为用户分配主从复制权限</p>
<h5 id="4-通过指令，查看二进制日志坐标">4.通过指令，查看二进制日志坐标</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>字段含义说明：</p>
<ul>
<li>file：从哪个日志文件开始推送日志文件</li>
<li>position：从哪个位置开始推送日志</li>
<li>binlog_ignore_db：指定不需要同步的数据库</li>
</ul>
</li>
</ul>
<h4 id="3-从库配置">3.从库配置</h4>
<h5 id="1-修改配置文件-etc-my-cnf-2">1.修改配置文件/etc/my.cnf</h5>
<ul>
<li><strong>server-id=2</strong></li>
</ul>
<p># mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1，和主库不一样即可</p>
<ul>
<li><strong>read-only=1</strong></li>
</ul>
<p># 是否只读，1代表只读，0代表读写</p>
<ul>
<li><strong>super-read-only=1</strong></li>
</ul>
<p># 可以将超级管理员也设置为只读，否则也能读写</p>
<h5 id="2-重启MySQL服务器-2">2.重启MySQL服务器</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
<p># 没有报错则配置成功</p>
<h5 id="3-登录mysql，设置主库配置">3.登录mysql，设置主库配置</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">change replication source <span class="keyword">to</span> source_host<span class="operator">=</span><span class="string">&#x27;原主机ip地址&#x27;</span>,source_user<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>,source_password<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>,source_log_file<span class="operator">=</span><span class="string">&#x27;对应二进制日志文件&#x27;</span>,source_log_pos<span class="operator">=</span>从日志中的哪个位置开始同步;</span><br></pre></td></tr></table></figure>
<p># 从日志中的哪个位置开始同步，可以查看二进制日志坐标中的position</p>
<ul>
<li>老版本</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;原主机ip地址&#x27;</span>,master_user<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;对应二进制日志文件名&#x27;</span>,master_log_pos<span class="operator">=</span>从日志中的哪个位置开始同步;</span><br></pre></td></tr></table></figure>
<h5 id="4-开启同步操作">4.开启同步操作</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> replica;</span><br></pre></td></tr></table></figure>
<ul>
<li>老版本(新版本也兼容)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>
<h5 id="5-查看主从同步状态">5.查看主从同步状态</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status;</span><br></pre></td></tr></table></figure>
<ul>
<li>老版本</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status;</span><br></pre></td></tr></table></figure>
<p># 状态中<strong>Replica_IO_Running</strong> 和<strong>Replica_SQL_Running</strong> 为<strong>Yes</strong> 说明主从复制正常</p>
<h2 id="3-分库分表">3.分库分表</h2>
<h3 id="1-介绍-2">1.介绍</h3>
<h4 id="1-问题分析">1.问题分析</h4>
<ul>
<li>
<p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p>
<ul>
<li>1.IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多，带宽不够，网络IO瓶颈。</li>
<li>2.CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。</li>
</ul>
</li>
<li>
<p>分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。</p>
</li>
</ul>
<h4 id="2-拆分策略">2.拆分策略</h4>
<ul>
<li>
<p>垂直拆分</p>
<ul>
<li>垂直分库：以表为依据，根据业务将不同表拆分到不同库中。
<ul>
<li>每个库的表结构都不一样</li>
<li>每个库的数据也不一样</li>
<li>所有库的并集是全量数据</li>
</ul>
</li>
<li>垂直分表：以字段为依据,根据字段属性将不同字段拆分到不同表中。
<ul>
<li>每个表的结构都不一样</li>
<li>每个表的数据也不一样，一般通过一列（主键/外键）关联</li>
<li>所有表的并集是全量数据</li>
</ul>
</li>
</ul>
</li>
<li>
<p>水平拆分</p>
<ul>
<li>水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。
<ul>
<li>每个库的表结构都一样</li>
<li>每个库的数据都不一样</li>
<li>所有库的并集是全量数据</li>
</ul>
</li>
<li>水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个库中。
<ul>
<li>每个表的表结构都一样</li>
<li>每个表的数据都不一样</li>
<li>所有表的并集是全量数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-实现技术">3.实现技术</h4>
<ul>
<li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。</li>
<li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</li>
</ul>
<h3 id="2-MyCat概述">2.MyCat概述</h3>
<h4 id="1-介绍-3">1.介绍</h4>
<ul>
<li>
<p>Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。mycat伪装了mysql的协议，所以可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在。</p>
</li>
<li>
<p>优势：</p>
<ul>
<li>性能可靠稳定</li>
<li>强大的技术团队</li>
<li>体系完善</li>
<li>社区活跃</li>
</ul>
</li>
<li>
<p>MyCat中间件服务器需要安装jdk和mycat</p>
</li>
<li>
<p>mycat解压后有主要四个目录：</p>
<ul>
<li>bin：存放可执行文件，用于启动停止mycat</li>
<li>conf：存放mycat的配置文件</li>
<li>lib：存放mycat的项目依赖包（jar）</li>
<li>logs：存放mycat的日志文件</li>
</ul>
</li>
</ul>
<h4 id="2-概念介绍">2.概念介绍</h4>
<ul>
<li>逻辑结构：</li>
<li>逻辑库
<ul>
<li>逻辑表
<ul>
<li>分片节点</li>
</ul>
</li>
</ul>
</li>
<li>物理结构：</li>
<li>节点主机（与分片节点相连）</li>
</ul>
<h3 id="3-MyCat入门">3.MyCat入门</h3>
<h4 id="1-需求">1.需求</h4>
<ul>
<li>由于 tb_order 表中数据量很大，磁盘IO及容量都到达了瓶颈，现在需要对tb_order表进行数据分片，分为三个数据节点，每一个节点主机位于不同的服务器上。</li>
</ul>
<h4 id="2-环境准备">2.环境准备</h4>
<ul>
<li>需要在三台服务器上都建立一个空的数据库</li>
<li>将防火墙关闭或者直接开放指定端口</li>
</ul>
<h4 id="3-分片配置（schema-xml）">3.分片配置（schema.xml）</h4>
<ul>
<li>修改mycat中conf中的schema.xml文件</li>
</ul>
<p># 可以用notepad++的插件NppFTP，show NppFTP Windows，便于编辑</p>
<ul>
<li>1.配置table（逻辑表）的表名</li>
<li>2.配置dataNode（数据节点）的数据节点名</li>
<li>3.配置数据节点连接的dataHost（节点主机）的节点主机名</li>
<li>4.配置关联的节点主机的database（数据库）的数据库名</li>
<li>5.在下面的dataHost中详细配置关联的服务器的ip地址，端口号以及用户名和密码</li>
</ul>
<h4 id="4-分片配置（server-xml）">4.分片配置（server.xml）</h4>
<ul>
<li>
<p>修改mycat中conf中的server.xml文件</p>
</li>
<li>
<p>配置mycat的用户及用户的权限信息</p>
</li>
<li>
<p>将user中的schemas后面的testdb改为数据库名</p>
</li>
<li>
<p>在readOnly后可以配置是否只可读</p>
</li>
</ul>
<h4 id="5-启动服务">5.启动服务</h4>
<ul>
<li>切换到mycat的安装目录，执行指令启动mycat</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/mycat start</span><br></pre></td></tr></table></figure>
<p># 启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/mycat stop</span><br></pre></td></tr></table></figure>
<p># 停止</p>
<p># mycat启动后占用端口号8066</p>
<ul>
<li>
<p>启动完成后可以查看logs目录下的启动日志，查看mycat是否启动完成</p>
</li>
<li>
<p>登录</p>
</li>
<li>
<p>和MySQL一样</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h 主机ip地址 -P 8066 -u root -p</span><br></pre></td></tr></table></figure>
<h3 id="4-MyCat配置">4.MyCat配置</h3>
<h4 id="1-schema-xml">1.schema.xml</h4>
<ul>
<li>schema.xml作为MyCat中最重要的配置文件之一，涵盖了MyCat的逻辑库、逻辑表、分片规则、分片节点及数据源的配置。</li>
<li>主要包含三组标签</li>
</ul>
<h5 id="1-schema">1.schema</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;DB01&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name-</span>&quot;<span class="attr">TB</span> <span class="attr">ORDER</span>&quot; <span class="attr">dataNode</span>=<span class="string">&quot;dnl,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>schema标签用于定义 MyCat实例中的逻辑库，一个MyCat实例中，可以有多个逻辑库，可以通过 schema标签来划分不同的逻辑库。</p>
</li>
<li>
<p>MyCat中的逻辑库的概念，等同于ySQL中的database概念，需要操作某个逻辑库下的表时，也需要切换逻辑库(use xxx)。</p>
</li>
<li>
<p>核心属性：</p>
<ul>
<li>name：指定自定义的逻辑库库名</li>
<li>checksdLschema：在SOL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去除，false：不自动去除</li>
<li>sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录</li>
</ul>
</li>
<li>
<p>子标签table</p>
<ul>
<li>table标签定义了MyCat中逻辑库schema下的逻辑表，所有需要拆分的表都需要在table标签中定义。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;DB01&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name-</span>&quot;<span class="attr">TB</span> <span class="attr">ORDER</span>&quot; <span class="attr">dataNode</span>=<span class="string">&quot;dnl, dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>核心属性：</p>
<ul>
<li>name：定义逻辑表表名，在该逻辑库下唯一</li>
<li>dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔</li>
<li>rule：分片规则的名字，分片规则名字是在rule.xml中定义的</li>
<li>primaryKey：逻辑表对应真实表的主键</li>
<li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配置为global</li>
</ul>
</li>
</ul>
<h5 id="2-dataNode">2.dataNode</h5>
<ul>
<li>dataNode标签中定义了MyCat中的数据节点，也就是我们通常说的数据分片。一个dataNode标签就是一个独立的数据分片。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;dbo1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;dbo1&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database-</span>&quot;<span class="attr">dbo1</span>&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>核心属性：
<ul>
<li>name：定义数据节点名称</li>
<li>dataHost：数据库实例主机名称，引用自dataHost 标签中name属性</li>
<li>database：定义分片所属数据库</li>
</ul>
</li>
</ul>
<h5 id="3-dataHost">3.dataHost</h5>
<ul>
<li>dataHost标签在MyCat逻辑库中作为底层标签存在，直接定义了具体的数据库实例、读写分离、心跳语句。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://192.168.200.210:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai&amp;amp:characterEncoding-utf8&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">&lt;/dataHost》</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>核心属性：</p>
<ul>
<li>name：唯一标识，供上层标签使用</li>
<li>maxCon/minCon: 最大连接数/最小连接数</li>
<li>balance:负载均衡策略，取值0,1,2,3</li>
<li>writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）</li>
<li>dbDriver：数据库驱动，支持native、jdbc</li>
</ul>
</li>
</ul>
<h4 id="2-rule-xml">2.rule.xml</h4>
<ul>
<li>rule.xml中定义所有拆分表的规则，在使用过程中可以灵活的使用分片算法，或者对同一个分片算法使用不同的参数，它让分片过程可配置化。主要包含两类标签：tableRule、Function</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-long&quot;</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">colunsJ</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 分片规则</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name-</span>&quot;<span class="attr">mapFile</span>&quot;&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 关联的分片算法rang-long，封装在外部文件autopartition-long.txt</p>
<h4 id="3-server-xml">3.server.xml</h4>
<ul>
<li>
<p>server.xml配置文件包含了MyCat的系统配意信息，主要有两个重要的标签：System、user。</p>
</li>
<li>
<p>system</p>
<ul>
<li>对应的系统配置项及其含义，参考资料。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nonePasswordLogin&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useHandshakeV10&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useSqlStat&quot;</span>&gt;</span>l<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>user</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>schemas后的表示该用户可以访问的逻辑库，多个逻辑库之间逗号分隔</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">privileges</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">dml</span>=<span class="string">&quot;0110&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb01&quot;</span> <span class="attr">dml</span>=<span class="string">&quot;0000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb02&quot;</span> <span class="attr">dml</span>=<span class="string">&quot;1111&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">privileges</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># &lt;privileges check=“false”&gt;表示是否开启DML权限检查，默认为false</p>
<p># &lt;schema name=“TESTDB” dml=“0110”&gt;配置指定逻辑库的权限</p>
<p># &lt;table name=“tb01” dml=“0000”&gt;&lt;/table&gt;配置指定逻辑表的权限，就近原则：以逻辑表为准（如果配置了逻辑表权限）</p>
<p># 0000，用二进制数对应IUSD（增改查删，例如1010则为增和查）的权限</p>
<h3 id="5-MyCat分片">5.MyCat分片</h3>
<h4 id="1-垂直拆分">1.垂直拆分</h4>
<h5 id="1-场景">1.场景</h5>
<ul>
<li>
<p>在业务系统中，涉及以下表结构，但是由于用户与订单每天都会产生大量的数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分，原有的数据库表如下</p>
<ul>
<li>省市区</li>
<li>商品
<ul>
<li>基础信息</li>
<li>品牌</li>
<li>分类</li>
<li>编号</li>
<li>详细信息</li>
</ul>
</li>
<li>订单
<ul>
<li>详细信息</li>
<li>支付记录</li>
</ul>
</li>
<li>用户
<ul>
<li>用户名</li>
<li>用户地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>将用户和省市区，商品，订单存放在三个分片中</p>
</li>
</ul>
<h5 id="2-准备">2.准备</h5>
<ul>
<li>在三台MySQL中创建数据库shopping</li>
</ul>
<h5 id="3-配置">3.配置</h5>
<ul>
<li>在schema中配置逻辑库，逻辑表，以及指定每一个逻辑表所关联的数据节点</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;SHOPPING&quot;</span> <span class="attr">checksgLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb goods base&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dnl&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb goods brand&quot;</span> <span class="attr">dataNode-</span>&quot;<span class="attr">dnl</span>&quot; <span class="attr">primaryKey</span>&quot;<span class="attr">id</span>&quot;/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb goods cat&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;th goods desc&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dnl&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;goods id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb goods item&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dnl&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb order item&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb order master&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;order id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb order pay log&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;out trade no&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;th user address&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb areas provinces&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb areas city&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb areas region&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhostl&quot;</span> <span class="attr">database</span>=<span class="string">&quot;shopping&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;shopping&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name-</span>&quot;<span class="attr">dn3</span>&quot; <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;shopping&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="4-测试">4.测试</h5>
<ul>
<li>在mycat命令行中，通过source指令导入表结构，以及对应的数据，查看数据分布情况</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /目录/文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>查询用户的收件人及收件人地址信息（多表联查）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ua.user_id, ua.contact, p.province, c.city, r.area , ua.address <span class="keyword">from</span> tb_user address ua ,tb_areas_city c, tb_areas_provinces p,tb_areas_region r <span class="keyword">where</span> ua.province_id <span class="operator">=</span> p.provinceid <span class="keyword">and</span> ua.city_id <span class="operator">=</span> c.cityid <span class="keyword">and</span> ua.town_id <span class="operator">=</span> r.areaid;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询每一笔订单及订单的收件地址信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id , payment,receiver,province,city,area <span class="keyword">FROM</span> tb_order_master o , tb_areas_provinces p , tb_areas_city c, tb_areas_region r <span class="keyword">WHERE</span> o.receiver_province <span class="operator">=</span> p.provinceid <span class="keyword">AND</span> o.receiver_city <span class="operator">=</span> c.cityid <span class="keyword">AND</span> o.receiver_region <span class="operator">=</span> r.areaid;</span><br></pre></td></tr></table></figure>
<p># 这里直接执行会报错，这是跨两库的多表联查</p>
<h5 id="5-全局表配置">5.全局表配置</h5>
<ul>
<li>对于省、市、区/县表tb_areas_provinces,tb_areas_city,tb_areas_region，是属于数据字典表，在多个业务模块中都可能会遇到，可以将其设置为全局表，利于业务操作。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_provinces&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dnl,dn2,dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span><span class="attr">type</span>=<span class="string">&quot;global&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p># 对三张表进行全局配置，查询的时候就会把这三张表路由到订单的数据库中，这样就能实现跨两库的多表联查</p>
<p># 全局表更新后关联的其他三个库中的表也会更新</p>
<h4 id="2-水平拆分">2.水平拆分</h4>
<h5 id="1-场景-2">1.场景</h5>
<ul>
<li>在业务系统中，有一张表(日志表，业务系统每天都会产生大量的日志数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分。</li>
</ul>
<h5 id="2-准备-2">2.准备</h5>
<ul>
<li>在三台MySQL中创建数据库itcast</li>
</ul>
<h5 id="3-配置-2">3.配置</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITCAST&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_log&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn4,dn5,dn6&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn4&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhosti&quot;</span> <span class="attr">database</span>=<span class="string">&quot;itcast&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn5&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;itcast&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn6&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;itcast&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p># 这里rule=&quot;mod-long&quot;将分片规则配置为取模</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>SHOPPING,ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 增加访问的逻辑库</p>
<ul>
<li>创建表结构并导入数据</li>
</ul>
<h4 id="3-分片规则">3.分片规则</h4>
<h5 id="1-范围（auto-sharding-long）">1.范围（auto-sharding-long）</h5>
<ul>
<li>根据指定的字段及其配置的范围与数据节点的对应情况，来决定该数据属于哪一个分片。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name-</span>&quot;<span class="attr">tb</span> <span class="attr">operate</span>&quot; <span class="attr">dataNode-</span>&quot;<span class="attr">dn4</span>,<span class="attr">dn5</span>,<span class="attr">dn6</span>&quot; <span class="attr">rule</span>&quot;<span class="attr">auto-sharding-long</span>&quot; /&gt;</span></span><br></pre></td></tr></table></figure>
<p># 在schema.xml中通过rule来指定对应的分片规则</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-long&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p># rule&quot;auto-sharding-long&quot;分片规则引用的是rule.xml中定义的分片规则</p>
<p># &lt;columns&gt;id&lt;columns&gt;定义了根据id字段进行分片</p>
<p># &lt;algorithm&gt;rang-long&lt;/algorithm&gt;分片对应的算法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span> &gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># &lt;algorithm&gt;rang-long&lt;/algorithm&gt;引用rule.xml中的function</p>
<p># class=&quot;io.mycat.route.function.AutoPartitionByLong&quot;这个java类中对分片规则进行定义解析</p>
<p># &lt;property name=“mapFile” &gt;autopartition-long.txt&lt;/property&gt;又引用了一个外部文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># range start-end ,data node index</span><br><span class="line"># K=1000,M=10000.</span><br><span class="line">0-500M=0</span><br><span class="line">500M-1000M=1</span><br><span class="line">1000M-1500M=2</span><br></pre></td></tr></table></figure>
<p># autopartition-long.txt这个外部文件中具体配置了范围对应的节点</p>
<h5 id="2-取模（mod-long）">2.取模（mod-long）</h5>
<ul>
<li>根据指定的字段值与节点数量进行求模运算，根据运算结果，来决定该数据属于哪一个分片。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 在rule.xml中配置节点数</p>
<h5 id="3-一致性hash（sharding-by-murmur）">3.一致性hash（sharding-by-murmur）</h5>
<ul>
<li>所谓一致性哈希，将字符串字段根据哈希计算，相同的哈希因子计算值总是被划分到相同的分区表中，不会因为分区节点的增加而改变原来数据的分区位置。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># function中配置节点数</p>
<h5 id="4-枚举（sharding-by-intfile）">4.枚举（sharding-by-intfile）</h5>
<ul>
<li>通过在配置文件中配置可能的枚举值,指定数据分布到不同数据节点上,本规则适用于按照省份、性别、状态拆分数据等业务。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># function配置默认节点值，当插入的数据超出了指定的枚举值则默认存储到这个节点</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># function中引用外部文件，在partition-hash-int.txt这个文件中直接定义例如3=1，则字段值为3时存到第2个节点，节点是从0开始的</p>
<ul>
<li>如果有不同的字段要用同一种分片规则，则可以将原本的分片规则复制黏贴，修改规则名称，修改字段，对应的算法不更改</li>
</ul>
<h5 id="5-应用指定（sharding-by-substring）">5.应用指定（sharding-by-substring）</h5>
<ul>
<li>运行阶段由应用自主决定路由到那个分片，直接根据子字符串（必须是数字，例如截取前2个数字）计算分片号。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-substring&quot;</span></span></span><br><span class="line"><span class="tag">	&lt;<span class="attr">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-substring<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-substring&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionDirectBySubString&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;startIndex&quot;</span>&gt;</span>O<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultPartition&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 这个分片规则不在默认的样例中，需要自行添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;startIndex&quot;</span>&gt;</span>O<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 在function中配置开始索引</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 配置截取长度</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 配置分片数量</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultPartition&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 配置默认分片，截取出来的子字符串不在分片数量范围内则存储到默认分片</p>
<h5 id="6-固定分片hash算法（sharding-by-long-hash）">6.固定分片hash算法（sharding-by-long-hash）</h5>
<ul>
<li>
<p>该算法类似于十进制的求模运算，但是为二进制的操作，会将指定字段（值必须是数字）的二进制的前10位与1111111111进行位&amp;运算。</p>
</li>
<li>
<p>位&amp;运算：将前十位的每一位数与1111111111中的相同位置的数字进行对比，相同则为1，不同则为0，获得一个新的数字。1111111111对应的十进制数是2^10-1=1023，所以这里的位&amp;运算得出的结果位于0-1023</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>如果是求模，连续的值，分别分配到各个不同的分片；但是此算法会将连续的值可能分配到相同的分片，降低事务处理的难度。</li>
<li>可以均匀分配到节点，也可以非均匀分配。</li>
<li>分片字段必须为数字类型。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>2,1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>256,512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 2,1表示共三个节点，前两个长度都是256，后一个是512（总的分片长度默认最大为1024）</p>
<p># 2,1和256,512这里配置的数字个数必须对应</p>
<h5 id="7-字符串hash解析（sharding-by-stringhash）">7.字符串hash解析（sharding-by-stringhash）</h5>
<ul>
<li>截取字符串中的指定位置的子字符串，进行哈希运算，算出哈希值与1023进行位&amp;运算，算出分片。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-stringhash&quot;</span></span></span><br><span class="line"><span class="tag">	&lt;<span class="attr">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>name<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-stringhash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByString&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&#x27;partitionCount&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashslice&quot;</span>&gt;</span>0:2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 这个分片规则也是需要自行添加的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&#x27;partitionCount&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 两个节点各512长度</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashslice&quot;</span>&gt;</span>0:2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># hash运算位，格式start:end，start从0开始。0在end中出现代表str.length()，-1代表str.length()-1，大于0代表数字本身</p>
<h5 id="8-按（天）日期分片（sharding-by-date）">8.按（天）日期分片（sharding-by-date）</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-date&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByDate&quot;</span>&gt;</span>		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateformat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBecinDate&quot;</span>&gt;</span>2022-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sEndDate&quot;</span>&gt;</span>2022-01-30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sPartionDay&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 需要自行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;daterormat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 日期格式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBeginDate&quot;</span>&gt;</span>2022-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 起始时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sEndDate&quot;</span>&gt;</span>2022-01-30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 截止时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sPartionDay&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 分片周期，每十天位一个分片，到达结束时间后，后面的日期再插入，会重复开始分片插入</p>
<p># dataNode的分片数量必须和这里的分片规则的数量一致，例如从同一年的01-01到12-31，每十天一个分片，则需要37个分片，没有则报错</p>
<h5 id="9-按自然月分片（sharding-by-month）">9.按自然月分片（sharding-by-month）</h5>
<ul>
<li>
<p>mycat中自带的分片规则</p>
</li>
<li>
<p>和按天分片一样需要配置日期格式和起始截止日期</p>
</li>
<li>
<p>一个月为一个分片，到达结束时间后，后面的日期再插入，会重复开始分片插入</p>
</li>
<li>
<p>dataNode的分片数量必须和这里的分片规则的数量一致，例如从同一年的01-01到12-31，每一个月一个分片，则需要12个分片，没有则报错</p>
</li>
</ul>
<h3 id="6-MyCat管理及监控">6.MyCat管理及监控</h3>
<h4 id="1-MyCat原理">1.MyCat原理</h4>
<ul>
<li>
<p>客户端发送插入的SQL语句到mycat</p>
</li>
<li>
<p>mycat</p>
<ul>
<li>解析SQL</li>
<li>分片分析</li>
<li>路由分析，路由到相对应的节点中</li>
<li>读写分离分析</li>
<li>…</li>
</ul>
</li>
<li>
<p>客户端发送查询的SQL语句到mycat</p>
</li>
<li>
<p>mycat</p>
<ul>
<li>解析SQL</li>
<li>分片分析，如果字段值不在规则范围内或者没有这个字段值，则接下来的路由分析会路由到所有库中</li>
<li>路由分析</li>
<li>读写分离分析</li>
<li>…</li>
</ul>
</li>
<li>
<p>分片节点</p>
<ul>
<li>接收到SQL语句</li>
<li>执行后返回结果到mycat</li>
</ul>
</li>
<li>
<p>mycat</p>
<ul>
<li>结果合并</li>
<li>聚合处理</li>
<li>排序处理</li>
<li>分页处理</li>
<li>…</li>
<li>结果返回到客户端</li>
</ul>
</li>
</ul>
<h4 id="2-MyCat管理">2.MyCat管理</h4>
<ul>
<li>
<p>Mycat默认开通2个端口，可以在server.xml中进行修改。</p>
<ul>
<li>
<p>8066数据访问端口，即进行DML和DDL操作。</p>
</li>
<li>
<p>9066数据库管理端口，即mycat服务管理控制功能，用于管理mycat的整个集群状态</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h ip地址 -P 9066 -uroot -p密码</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>show @@help</td>
<td>查看Mycat管理工具帮助文档</td>
</tr>
<tr>
<td>show @@version</td>
<td>查看Mycat的版本</td>
</tr>
<tr>
<td>reload @@config</td>
<td>重新加载Mycat的配置文件</td>
</tr>
<tr>
<td>show @@datasouorce</td>
<td>查Mycat的数据源信息</td>
</tr>
<tr>
<td>show @@datanode</td>
<td>查看MyCat现有的分片节点信息</td>
</tr>
<tr>
<td>show @@threadpool</td>
<td>查看Mycat的线程池信息</td>
</tr>
<tr>
<td>show @@sql</td>
<td>查看执行的SQL</td>
</tr>
<tr>
<td>show @@sql.sum</td>
<td>查看执行的SQL统计</td>
</tr>
</tbody>
</table>
<h4 id="3-MyCat-eye">3.MyCat-eye</h4>
<ul>
<li>
<p>Mlycat-web(Mycat-eye)是对mycat-server提供监控服务，功能不局限于对mycat-server使用。他通过JDBC连接对Mycat、Mysal监控，监控远程服务器(目前仅限于linux系统)的cpu、内存、网络、磁盘。</p>
</li>
<li>
<p>Mycat-eye运行过程中需要依赖zookeeper，因此需要先安装zookeeper。</p>
</li>
<li>
<p>在mycat-web文件夹下</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh start.sh</span><br></pre></td></tr></table></figure>
<p># 启动mycat-web</p>
<ul>
<li>
<p>在浏览器中输入网址：服务器ip：8082/mycat进入网站（需要关闭服务器的防火墙）</p>
</li>
<li>
<p>在网站中进入mycat配置中的mycat服务配置</p>
</li>
<li>
<p>管理端口：9066</p>
</li>
<li>
<p>服务端口：8066</p>
</li>
<li>
<p>数据库名称：这里要配置mycat-server配置文件schema.xml中schema标签配置的name。</p>
</li>
<li>
<p>用户名：这里要配置mycat-server配置文件server.xml中user标签中name配置的值</p>
</li>
<li>
<p>密码：这里要配置mycat-server配置文件server.xml中user标签中，property name=&quot;password&quot;配置的密码。</p>
</li>
</ul>
<h2 id="4-读写分离">4.读写分离</h2>
<h3 id="1-介绍-4">1.介绍</h3>
<ul>
<li>读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</li>
<li>通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</li>
</ul>
<h3 id="2-一主一从">2.一主一从</h3>
<h4 id="1-原理">1.原理</h4>
<ul>
<li>MySQL的主从复制，是基于二进制日志（binlog）实现的。</li>
</ul>
<h4 id="2-环境准备-2">2.环境准备</h4>
<ul>
<li>搭建主从结构</li>
</ul>
<h3 id="3-一主一从读写分离">3.一主一从读写分离</h3>
<h4 id="1-配置">1.配置</h4>
<ul>
<li>在schema.xml文件中配置主库writeHost host=“master” url=和从库readHost host=“slave” url=的ip地址</li>
</ul>
<p># 从库的需要自行添加</p>
<ul>
<li>
<p>还要在server.xml中的user标签中的schemas中新增逻辑库，增加权限</p>
</li>
<li>
<p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控制，将参数值修改为1或3</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>不开启读写分离机制，所有读操作都发送到当前可用的writeHost上</td>
</tr>
<tr>
<td>1</td>
<td>全部的readHost 与备用的writeHost都参与select语句的负载均衡（主要针对于双主双从模式）</td>
</tr>
<tr>
<td>2</td>
<td>所有的读写操作都随机在writeHost，readHost上分发</td>
</tr>
<tr>
<td>3</td>
<td>所有的读请求随机分发到writeHost对应的readHost上执行,writeHost不负担读压力</td>
</tr>
</tbody>
</table>
<h4 id="2-问题">2.问题</h4>
<ul>
<li>主节点Master宕机之后,业务系统就只能够读,而不能写入数据了。</li>
</ul>
<h3 id="4-双主双从">4.双主双从</h3>
<h4 id="1-介绍-5">1.介绍</h4>
<ul>
<li>一个主机 Master1 用于处理所有写请求，它的从机 Slave1和另一台主机 Master2 还有它的从机库Slave2负责所有读请求。当Master1主机宕机后，Master2 主机负责写请求，Master1、Master2 互为备机。</li>
</ul>
<h4 id="2-环境准备-3">2.环境准备</h4>
<ul>
<li>共需要5台服务器，1台中间件，2台主库，2台从库</li>
<li>全部关闭防火墙</li>
</ul>
<h4 id="3-搭建-2">3.搭建</h4>
<h5 id="1-修改主库1的配置文件-etc-my-cnf">1.修改主库1的配置文件/etc/my.cnf</h5>
<ul>
<li><strong>server-id=1</strong></li>
</ul>
<p># mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1，默认为1</p>
<ul>
<li><strong>binlog-do-db=数据库名</strong></li>
</ul>
<p># 指定同步的数据库,需要写三句来同步三个数据库</p>
<ul>
<li><strong>log-slave-updates</strong></li>
</ul>
<p># 在作为从库时，有写入操作也要更新二进制日志文件</p>
<h5 id="2-重启mysql服务">2.重启mysql服务</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
<h5 id="3-修改主库2的配置文件-etc-my-cnf">3.修改主库2的配置文件/etc/my.cnf</h5>
<ul>
<li>与主库1配置相同，只需修改id</li>
</ul>
<h5 id="4-两台主库创建账户并授权">4.两台主库创建账户并授权</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> Root@密码<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure>
<p># 创建用户，并设置密码，该用户可在任意主机连接该MySQL服务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p># 为用户分配主从复制权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure>
<p># 通过指令查看两台主库的二进制日志坐标</p>
<h5 id="5-修改从库1配置文件-etc-my-cnf">5.修改从库1配置文件/etc/my.cnf</h5>
<ul>
<li><strong>server-id=2</strong></li>
</ul>
<p># mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1</p>
<h5 id="6-重启mysql服务">6.重启mysql服务</h5>
<h5 id="7-修改从库2配置文件-etc-my-cnf">7.修改从库2配置文件/etc/my.cnf</h5>
<p># 修改id</p>
<h5 id="8-从库1配置关联的主库1">8.从库1配置关联的主库1</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;对应主库ip&#x27;</span>,MASTER_USER<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>,MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>,MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;二进制日志文件名&#x27;</span>,MASTER_LOG_POS<span class="operator">=</span>日志中开始的位置；</span><br></pre></td></tr></table></figure>
<p># 需要注意slave1对应的是master1，slave2对应的是master2。</p>
<h5 id="9-启动从库主从复制，查看从库状态">9.启动从库主从复制，查看从库状态</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status;</span><br></pre></td></tr></table></figure>
<h5 id="10-从库2配置关联的主库2">10.从库2配置关联的主库2</h5>
<ul>
<li>与从库1配置关联的主库1相同</li>
</ul>
<h5 id="11-主库之间的相互复制">11.主库之间的相互复制</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;另一个主库ip&#x27;</span>,MASTER_USER<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>,MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>,MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;二进制日志文件名&#x27;</span>,MASTER_LOG_POS<span class="operator">=</span>日志中开始的位置；</span><br></pre></td></tr></table></figure>
<p># 在两台主库中都要执行指令</p>
<h5 id="12-启动从库主从复制，查看从库状态">12.启动从库主从复制，查看从库状态</h5>
<h3 id="5-双主双从读写分离">5.双主双从读写分离</h3>
<ul>
<li>在schema.xml文件中配置主库writeHost host=“master” url=和从库readHost host=“slave” url=的ip地址</li>
</ul>
<p># 两个主库从库都要配置，从库分别配置在对应主库下</p>
<ul>
<li>修改balance的数值为1</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1 dbType=&quot;</span><span class="attr">mysql</span>&quot; <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 新增writeType和switchType</p>
<ul>
<li>
<p>writeType</p>
<ul>
<li>0：写操作都转发到第1台writeHost, writeHost1挂了，会切换到writeHost2上；</li>
<li>1：所有的写操作都随机地发送到配置的writeHost上；</li>
</ul>
</li>
<li>
<p>switchType</p>
<ul>
<li>-1：不自动切换</li>
<li>1：自动切换</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL进阶</title>
    <url>/2025/08/27/MySQL%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>MySQL进阶</h1>
<h2 id="1-储存引擎">1.储存引擎</h2>
<h3 id="1-MySQL体系结构">1.MySQL体系结构</h3>
<ul>
<li>
<p>客户端连接器：PHP,Python，Java的JDBC等</p>
</li>
<li>
<p>MySQL服务端：</p>
</li>
<li>
<p>连接层：</p>
<ul>
<li>连接池，用于接收客户端的连接，完成连接的处理，认证授权（校验用户名密码），校验每个客户端的权限，相关安全方案，检查是否超过最大连接数</li>
</ul>
</li>
<li>
<p>服务层：SQL接口，完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程，函数等</p>
<ul>
<li>SQL接口</li>
<li>解析器</li>
<li>查询优化器</li>
<li>缓存</li>
</ul>
</li>
<li>
<p>引擎层：复杂数据的存储和提取，服务器通过API和存储引擎进行通信。其中含有多个可选择的引擎，不同的存储引擎有不同功能，也可以在此基础上扩展。</p>
<ul>
<li>可插拔存储引擎
<ul>
<li>InnoDB（MySQL5.5后的默认引擎）</li>
<li>NDB</li>
<li>MyISAM</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>
<p>存储层：主要将数据存储在文件系统之上，并完成与存储引擎的交互</p>
<ul>
<li>系统文件</li>
<li>文件和日志</li>
</ul>
</li>
</ul>
<h3 id="2-储存引擎简介">2.储存引擎简介</h3>
<ul>
<li>存储数据，建立索引，查询/更新数据等技术的实现方式。</li>
<li>存储引擎是基于表的，而不是基于库的，所以存储引擎也可以称为表类型</li>
</ul>
<h4 id="1-查询表的存储引擎">1.查询表的存储引擎</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create table</span> 表名；</span><br></pre></td></tr></table></figure>
<ul>
<li>用查询建表语句查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `user1` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  `gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `id_for_connent` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `name` (`name`),</span><br><span class="line">  KEY `fk_user1_name_dept_id` (`id_for_connent`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_user1_name_dept_id` <span class="keyword">FOREIGN KEY</span> (`id_for_connent`) <span class="keyword">REFERENCES</span> `dept` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `user1_chk_1` <span class="keyword">CHECK</span> (((`age` <span class="operator">&gt;</span> <span class="number">0</span>) <span class="keyword">and</span> (`age` <span class="operator">&lt;=</span> <span class="number">120</span>)))</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci COMMENT<span class="operator">=</span><span class="string">&#x27;用于学习约束的用户表&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>其中查询出的<strong>ENGINE=InnoDB</strong> 就是存储引擎，InnoDB为默认引擎</p>
</li>
<li>
<p><strong>AUTO_INCREMENT=4</strong> 代表id是自增的</p>
</li>
<li>
<p><strong>DEFAULT CHARSET=utf8mb4</strong> 即当前表的默认字符集是utf8mb4</p>
</li>
<li>
<p><strong>COLLATE=utf8mb4_0900_ai_ci</strong> 即排序方式</p>
</li>
</ul>
<h4 id="2-创建表时指定存储引擎">2.创建表时指定存储引擎</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> tables 表名(</span><br><span class="line"></span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>的类型（comment 字段<span class="number">1</span>的注释）,      #注意逗号</span><br><span class="line"></span><br><span class="line">	字段<span class="number">2</span> 字段<span class="number">2</span>的类型（comment 字段<span class="number">2</span>的注释）,</span><br><span class="line"></span><br><span class="line">	........</span><br><span class="line"></span><br><span class="line">) engine<span class="operator">=</span>innodb（comment 表注释）；</span><br></pre></td></tr></table></figure>
<h4 id="3-查看当前数据库支持的存储引擎">3.查看当前数据库支持的存储引擎</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engine；</span><br></pre></td></tr></table></figure>
<ul>
<li>查询后显示</li>
</ul>
<p>engine（引擎名称）       support（是否支持）        comment（描述）       transactions       XA       savepoints</p>
<h3 id="3-储存引擎特点">3.储存引擎特点</h3>
<h4 id="1-InnoDB">1.InnoDB</h4>
<ul>
<li>
<p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>DML（数据的增删改）操作遵循ACID模型（事务的四大特性），支持<strong>事务</strong></li>
<li><strong>行级锁</strong> ，提高并发访问性能</li>
<li>支持<strong>外键</strong> foreign key约束，保证数据的完整性和正确性</li>
</ul>
</li>
<li>
<p>文件：</p>
<ul>
<li>
<p>xxx.ibd:xxx代表的是表名，innodb引擎的每一张表都会对应这样一个表空间文件，储存该表的表结构（frm，sdi），数据和索引</p>
</li>
<li>
<p>#文件不能直接打开，可以在文件夹中打开cmd，<strong>ibd2sdi xxx.idb</strong> 会返回一长串json</p>
</li>
<li>
<p>参数：innodb_file_per_table</p>
</li>
<li>
<p>#可以用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> varialbes <span class="keyword">like</span>‘innodb_file_per_table’;</span><br></pre></td></tr></table></figure>
<p>查看是否打开，打开则表示每张表对应一个表空间文件</p>
</li>
</ul>
</li>
<li>
<p>逻辑存储结构</p>
<ul>
<li>tablespace：表空间，其中包含多个segment
<ul>
<li>segment：段，其中包含多个extent
<ul>
<li>extent：区（大小固定，每个区1M），其中包含多个page（可以包含64个页）
<ul>
<li>page：页（大小固定，每个页16K，页也是磁盘操作的最小单元），其中包含多个row
<ul>
<li>row：行，其中包含最后一次操作事务的id，指针，字段</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-MyISAM">2.MyISAM</h4>
<ul>
<li>
<p>MyISAM是MySQL早期的默认存储引擎</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
</li>
<li>
<p>文件：</p>
<ul>
<li>xxx.MYD：存储数据</li>
<li>xxx.MYI：存储索引</li>
<li>xxx.sdi：存储表结构信息，打开是文本形式的json，json格式化后查看</li>
</ul>
</li>
</ul>
<h4 id="3-Memory">3.Memory</h4>
<ul>
<li>
<p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题，或断电问题的影响，只能将这些表作为临时表或缓存使用</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>内存存放（所以访问速度快）</li>
<li>hash索引（默认）</li>
</ul>
</li>
<li>
<p>xxx.sdi：存储表结构信息</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>—</td>
<td>—支持</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持（5.6后）</td>
<td>支持</td>
<td>—</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td>—</td>
<td>—</td>
</tr>
</tbody>
</table>
<h3 id="4-储存引擎选择">4.储存引擎选择</h3>
<ul>
<li>应根据应用系统的特点选择合适的存储引擎，对于复杂的应用系统，可以根据实际情况选择多种存储引擎
<ul>
<li>InnoDB：是MySQL的默认存储引擎，支持事务，外键。如果应用对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新，删除操作，那么InnoDB存储引擎是比较合适的选择</li>
<li>MyISAM：如果应用是以读写操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性，并发性要求不是很高，那么MyISAM是合适的选择</li>
<li>Memory：将所有数据保存在内存种，访问速度快，通常用于临时表及缓存。Memory的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li>
</ul>
</li>
</ul>
<h2 id="2-索引">2.索引</h2>
<h3 id="1-索引概述">1.索引概述</h3>
<ul>
<li>索引（index）：帮助MySQL<strong>高效获取数据</strong> 的<strong>数据结构（有序）</strong> 。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据上实现高级查找算法，这种数据结构就是索引。</li>
</ul>
<p># 无索引时，例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">40</span>；</span><br></pre></td></tr></table></figure>
<p>会与每一条数据匹配，称为全表扫描，性能极低</p>
<ul>
<li>
<p>优点：</p>
<ul>
<li>提高数据检索的效率，降低数据的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>
</ul>
</li>
<li>
<p>缺点（影响较小）</p>
<ul>
<li>索引列也要占用空间</li>
<li>索引提高了查询效率，但同时也降低更新表的速度，如对表进行insert，update，delete时效率降低</li>
</ul>
</li>
</ul>
<h3 id="2-索引结构">2.索引结构</h3>
<ul>
<li>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构</li>
</ul>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+Tree索引</td>
<td>最常见的索引类型，大部分引擎都支持B+树索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的，只有精确匹配索引列查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R-tree(空间索引)</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间的数据类型，使用较少</td>
</tr>
<tr>
<td>Full-text(全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，ES</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text索引</td>
<td>5.6后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<h4 id="1-二叉树">1.二叉树</h4>
<ul>
<li>
<p>树状图，但是每个节点下最多只有两个分叉</p>
</li>
<li>
<p>缺点：</p>
<ul>
<li>1.极端情况如顺序插入时，会形成一个链表（即斜树，只有左子树或者只有右子树），查询性能大大降低。</li>
<li>2.大数据量情况下，层级较深，检索速度慢</li>
</ul>
</li>
<li>
<p>红黑数只能解决第一个缺点</p>
</li>
</ul>
<h4 id="2-B-Tree（多路平衡查找树）">2.B-Tree（多路平衡查找树）</h4>
<ul>
<li>同样是树状图，但是可以有多个节点，一个节点的子节点个数称为度数（max-degree），每个节点可以存储（度数-1）个key，度数个指针</li>
<li>当插入超过（度数-1）个key时，中间元素则向上裂变，例如数字：23，56，28，49，如果再插入一个数字59，则中间元素49向上裂变，（23，28），（56，59）成为49的两个子节点</li>
</ul>
<h4 id="3-B-Tree">3.B+Tree</h4>
<ul>
<li>与B树类似，但是所有元素都会出现在叶子节点，上面的非叶子节点主要起到索引的作用，叶子节点则存放数据。同时叶子节点形成一个单向链表，每个节点通过指针指向下一个元素</li>
<li>在MySQL中对B+Tree进行了优化，增加了一个指向相邻页子节点的链表指针，形成带有顺序指针的B+Tree，提高区间访问的性能</li>
<li>其中的键值，数据，指针，都是存放在页</li>
</ul>
<p># 假设一行数据大小为1k，那高度为2时可以存储18736字节的数据，高度为3时可以存储21939856字节的数据</p>
<h4 id="4-Hash">4.Hash</h4>
<ul>
<li>
<p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中</p>
</li>
<li>
<p>如果两个或多个键值，映射到同一个槽位上，就产生了hash冲突（hash碰撞），可以通过链表解决</p>
</li>
<li>
<p>特点</p>
<ul>
<li>1.Hash索引只能用于对等比较（=，in），不支持范围查询（between，&gt;,&lt;,…）</li>
<li>2.无法利用索引完成排序操作</li>
<li>3.查询效率高，通常（不出现hash碰撞）只需要一次检索就可以，效率通常要高于B+tree索引</li>
</ul>
</li>
<li>
<p>存储引擎支持</p>
<ul>
<li>MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的</li>
</ul>
</li>
</ul>
<h4 id="5-思考">5.思考</h4>
<ul>
<li>为什么InnoDB存储引擎用B+Tree索引结构
<ul>
<li>相对于二叉树，层级少，搜素效率高</li>
<li>对于B-tree，无论叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li>
<li>相对Hash索引，B+tree支持范围匹配及排序操作</li>
</ul>
</li>
</ul>
<h3 id="3-索引分类">3.索引分类</h3>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>primary</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>unique</td>
</tr>
<tr>
<td>常规索引</td>
<td>定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>fulltext</td>
</tr>
</tbody>
</table>
<ul>
<li>在InnoDB中根据索引的存储形式，又分为两种</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>聚焦索引</td>
<td>将数据存储与索引放在一块，索引结构的叶子节点保存了行数据</td>
<td>必须有，且只有一个</td>
</tr>
<tr>
<td># 叶子节点下对应的是主键和这一行的行数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td>二级索引</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
<tr>
<td># 叶子节点下对应的是索引对应字段和字段对应的主键</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>两个索引都是B+tree索引</p>
</li>
<li>
<p>例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;arm&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这时候就会先根据name这个字段的二级索引查找对应name下面对应的主键，再根据主键去主键的聚焦索引查找对应主键下面的行数据。这个过程称为<strong>回表查询</strong></p>
</li>
<li>
<p>所以根据主键查询的效率要更高</p>
</li>
<li>
<p>聚焦索引选取规则</p>
<ul>
<li>如果存在主键，主键索引就是聚焦索引</li>
<li>如果不存在主键，将使用第一个唯一索引作为聚焦索引</li>
<li>如果以上都没有则自动生成一个rowid作为隐藏的聚焦索引</li>
</ul>
</li>
</ul>
<h3 id="4-索引语法">4.索引语法</h3>
<p>1.创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span><span class="operator">/</span>fulltext index 索引名称 <span class="keyword">on</span> 表名(表中字段名<span class="number">1</span>,.....);</span><br></pre></td></tr></table></figure>
<p># 如果省略unique或者fulltext则创建一个常规索引</p>
<p># 关联一个字段则为单列索引，多个则为联合索引（联合索引）</p>
<p># 索引名称规范一般为<strong>idx_表名_字段名</strong></p>
<p>2.查看索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名\G；</span><br></pre></td></tr></table></figure>
<p># 不加G显示出来的是表格，但是内容过多会导致表格变形，加上G可以使其每行显示一条</p>
<p>3.删除索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名称 <span class="keyword">on</span> 表名；</span><br></pre></td></tr></table></figure>
<h3 id="5-SQL性能分析">5.SQL性能分析</h3>
<h4 id="1-SQL执行频率">1.SQL执行频率</h4>
<ul>
<li>MySQL中通过<strong>show session/global status</strong> 可以提供服务器状态信息。</li>
</ul>
<p># session和global分别为当前会话和全局</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> ’Com_____________<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure>
<p># Com后面有几个下划线则为模糊匹配几个字符，可以查看当前数据库的insert，update，delete，select的访问频次</p>
<h4 id="2-慢查询日志">2.慢查询日志</h4>
<ul>
<li>
<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认不开启，需要在MySQL的配置文件（/etc/my.cnf）中配置</p>
</li>
<li>
<p><strong>slow_query_log=1</strong> 在配置文件中配置开启</p>
</li>
<li>
<p><strong>long_query_time=2</strong> 设置慢查询日志的时间为2秒</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> ‘slow_query_log<span class="string">&#x27;；</span></span><br></pre></td></tr></table></figure>
<p>查询慢查询日志是否打开</p>
<ul>
<li>日志存放在**/var/lib/mysql** 中会有一个以**-slow.log** 结尾的文件</li>
</ul>
<p># 日志中会记录：哪一个用户通过哪一个主机连接,执行用了多少时间，锁了多少行，返回了多少条记录，用的哪一个数据库，执行的时间，执行的语句</p>
<ul>
<li><strong>tail  -f  文件名</strong> 在Linux中这个指令可以查看文件实时输出的内容</li>
</ul>
<h4 id="3-profile详情">3.profile详情</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>；</span><br></pre></td></tr></table></figure>
<p># 通过have_profiling参数，能够看到当前MySQL是否支持profile操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>；</span><br></pre></td></tr></table></figure>
<p># 查看返回数字，是否开启</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>；</span><br></pre></td></tr></table></figure>
<p># 默认profiling是关闭的，可以选择在session/global级别开启</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles；</span><br></pre></td></tr></table></figure>
<p>#查看每一条SQL的耗时基本情况</p>
<p># 会显示query_id，duration，query</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query 指定query_id；</span><br></pre></td></tr></table></figure>
<p># 查看指定query_id的SQL语句各阶段的耗时情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query 指定query_id；</span><br></pre></td></tr></table></figure>
<p># 查看指定query_id的SQL语句cpu的使用情况</p>
<h4 id="4-explain执行计划">4.explain执行计划</h4>
<ul>
<li>explain或者desc命令获取MySQL如何执行select语句的信息，包括select语句执行过程中表如何连接和连接的顺序</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件；</span><br></pre></td></tr></table></figure>
<p># 直接在select语句前加关键字explain/desc</p>
<p># 会显示id，select_type（查询类型）,table（使用的表），partitions（分区），type（连接的类型），possible_keys（可能用到的索引），key（实际用到的索引），key_len（索引长度），rows（扫描记录数），ref，filtered，extra</p>
<ul>
<li>
<p>explain执行计划各字段含义</p>
<ul>
<li>
<p>id</p>
<ul>
<li>
<p>select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，则值越大的先执行）</p>
<p># 多表查询会出现多条记录，会有多个id</p>
</li>
</ul>
</li>
<li>
<p>select_type</p>
<ul>
<li>表示select的类型，常见有simple（简单表，即不使用表连接或者子查询），primary（主查询，即外层的查询），union（union中的第二个或者后面的查询语句），subquery（select/where之后包含了子查询）等</li>
</ul>
</li>
<li>
<p>type</p>
<ul>
<li>表示连接（访问）类型，性能由好到坏为，null（基本不会出现，除非不访问表），system（访问系统表），const（根据主键和唯一索引访问），eq_ref（联表查询中根据主键和唯一索引访问）,ref（根据非唯一性的索引访问）,range,index（遍历整个索引）,all（全表扫描）</li>
</ul>
</li>
<li>
<p>possible_keys</p>
<ul>
<li>表可能会用到的索引，会有一个或多个</li>
</ul>
</li>
<li>
<p>key</p>
<ul>
<li>实际使用的索引，没有使用索引则为null</li>
</ul>
</li>
<li>
<p>key_len</p>
<ul>
<li>表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li>
</ul>
</li>
<li>
<p>rows</p>
<ul>
<li>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是估计值</li>
</ul>
</li>
<li>
<p>filtered</p>
<ul>
<li>表示返回结果的行数占需要读取行数的百分比，值越大越好</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-索引使用">6.索引使用</h3>
<h4 id="1-验证索引效率">1.验证索引效率</h4>
<ul>
<li>在未建立索引之前，执行SQL语句查看SQL耗时</li>
<li>针对字段创建索引后再执行相同的SQL语句，再次查看SQL耗时</li>
</ul>
<h4 id="2-使用原则">2.使用原则</h4>
<h5 id="1-最左前缀法则">1.最左前缀法则</h5>
<ul>
<li>
<p>最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳过某一列，<strong>索引将部分失效，则此列后面的字段失效</strong></p>
</li>
<li>
<p>如果索引了多列（即联合索引），要遵守最左前缀法则</p>
</li>
</ul>
<p># 例如建立联合索引按顺序关联name，age，status三个字段，在使用联合查询的时候，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> ......;</span><br></pre></td></tr></table></figure>
<p>​    要遵守最左前缀法则，则where后面必须存在name=（位置不限），否则不会根据索引查询，</p>
<p>​    在查询时用and连接字段，如果跳过了age字段，则name根据索引查询，status则不会</p>
<h5 id="2-范围查询">2.范围查询</h5>
<ul>
<li>联合索引中，出现范围查询（&gt;,&lt;)，<strong>范围查询右侧的列索引失效</strong></li>
</ul>
<p># 同样是上面的例子，如果查询的时候where后面age&gt;30，则其右侧即status失效（age仍然根据索引查询）</p>
<p># 在允许的情况下用&gt;=和&lt;=可以规避这个问题</p>
<h5 id="3-索引列运算">3.索引列运算</h5>
<ul>
<li>不要在索引列上进行运算操作，<strong>索引将失效</strong></li>
</ul>
<p># 例如建立了关于phone这个字段的索引，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> phone<span class="operator">=</span>‘号码’；</span><br></pre></td></tr></table></figure>
<p>这样查询是可以根据索引查询的</p>
<p>如果使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> substring（phone，<span class="number">10</span>，<span class="number">2</span>）<span class="operator">=</span>‘<span class="number">12</span>’；</span><br></pre></td></tr></table></figure>
<p>即用了substring函数进行了运算</p>
<p>则进行的是全表扫描，不会根据索引查询</p>
<p># 最左前缀法则中中间字段进行了运算会导致此字段和其后的字段索引失效</p>
<h5 id="4-字符串不加引号">4.字符串不加引号</h5>
<ul>
<li>字符串类型字段使用时，不叫引号，<strong>索引将失效</strong> ，根本原因是对其进行了隐式类型转换，字符串转为数字，而索引存储的是原字符串</li>
</ul>
<p># possibilities_keys为字段相关的索引，但是实际索引key为null</p>
<p># 在最左前缀法则中，如果中间字段没有加引号，<strong>则此字段以及后面的索引全部失效</strong></p>
<h5 id="5-模糊查询">5.模糊查询</h5>
<ul>
<li>如果仅仅是尾部查询模糊匹配（abc%），索引不会失效。但是只要头部模糊匹配（%abc），索引就失效</li>
</ul>
<p># 同样在最左前缀法则中尾部模糊查询会导致当前索引可以使用，其后索引失效。</p>
<p># 只要有头部模糊就会导致，此字段索引及其后索引失效</p>
<h5 id="6-or连接的条件">6.or连接的条件</h5>
<ul>
<li>用or分割开的条件，任一条件中列没有索引，那么前后索引都不会被用到</li>
</ul>
<p># 只要有条件中的字段是联合索引里的中间字段且没有单独索引则失效，如果只是最左索引则可以使用</p>
<p># 会有可能索引，但实际索引key为null</p>
<p># 如果要查询字段是联合索引里的中间字段则需要创建单独索引</p>
<h5 id="7-数据分布影响">7.数据分布影响</h5>
<ul>
<li>如果MySQL评估使用索引比全表更慢，则不使用索引</li>
</ul>
<p># 主要取决于数据的分布，如果条件筛选出来的是小部分数据则会使用索引，反之不使用</p>
<h5 id="8-SQL提示">8.SQL提示</h5>
<ul>
<li>在SQL语句中加入一些提示来达到优化操作的目的</li>
</ul>
<h6 id="1-use-index：建议MySQL使用某个索引，实际使用的索引根据MySQL的判断">1.use index：建议MySQL使用某个索引，实际使用的索引根据MySQL的判断</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 use index（索引名）<span class="keyword">where</span> ......；</span><br></pre></td></tr></table></figure>
<p># 可以用explain查看最终使用了哪个索引</p>
<h6 id="2-ignore-index：不使用某个索引">2.ignore index：不使用某个索引</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 ignore index（索引名）<span class="keyword">where</span> ........;</span><br></pre></td></tr></table></figure>
<h6 id="3-force-index：强制使用某个索引">3.force index：强制使用某个索引</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 force index（索引名）<span class="keyword">where</span> .........；</span><br></pre></td></tr></table></figure>
<h5 id="9-覆盖索引">9.覆盖索引</h5>
<ul>
<li>尽量使用覆盖索引（查询使用了索引，并且需要返回的列在该索引中已经全部能够找到），减少select*出现</li>
</ul>
<p># 例如建立了关联了phone，age，name的联合索引，select id，phone，age，name后面条件包含三个字段</p>
<p>​	根据二级索引，主键id也包含在内，四个字段都在使用的索引中，这时候用explain查询，extra信息会显示</p>
<p>​	using where；using index：查找使用了索引，但是需要的数据都在索引列中能找到，使用不需要回表查询</p>
<p>​	如果再查询status，这个字段不包含在使用到的索引中，则extra信息会显示</p>
<p>​	using index condition：查找使用了索引，但是需要回表查询数据</p>
<p>​	如果要查询则再建立phone，age，name，status的联合索引，以提高效率，单独再建一个status的单列索引仍然会回表查询</p>
<h5 id="10-前缀索引">10.前缀索引</h5>
<ul>
<li>
<p>当字段类型为字符串（varchar，text等）使，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘io，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样可以对的节约索引空间，从而提高索引效率</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名称 <span class="keyword">on</span> 表名（字段名（n））；</span><br></pre></td></tr></table></figure>
<p># n表示要提取这个字段的前面n个字符来构建索引</p>
<ul>
<li>前缀长度</li>
<li>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的</li>
<li>计算公式：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> count（<span class="keyword">distinct</span> 字段名）<span class="operator">/</span>count（\<span class="operator">*</span>） <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p># distinct用于去除重复记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> count（<span class="keyword">distinct</span> substring（字段名，起始位置，截取长度））<span class="operator">/</span>count（\<span class="operator">*</span>） <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p># substring用于截取，起始位置从1开始</p>
<ul>
<li>前缀索引查询流程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> email<span class="operator">=</span>‘完整的邮箱’；</span><br></pre></td></tr></table></figure>
<p># 先根据完整邮箱的前n位到创建的邮箱的前n位的二级索引中查找得到对应主键，再到聚合索引中找到对应主键的行数据，再将行数据中的email与要查询的完整邮箱比对，完全一致则返回数据。如果出现前n位相同，则将几个主键都拿到聚合索引中查询，最终一致的再返回出来</p>
<h5 id="11-单列索引与联合索引">11.单列索引与联合索引</h5>
<ul>
<li>如果存在多个查询条件，考虑针对于查询字段建立索引，建议建立联合索引，而非单列索引</li>
</ul>
<p># 在使用时，即使创建了联合索引，MySQL可能仍会使用单列索引，会回表查询，可以使用SQL提示</p>
<ul>
<li>联合索引情况：</li>
<li>仍然是B+tree，每个节点存储的键值是几个索引的组合情况</li>
</ul>
<p># 例如将phone，name，age按顺序关联成联合索引，则每个键值的形式都是phone+name+age，根据phone来排序，phone一致则再根据name来排序，以此类推。同时phone就作为最左列</p>
<h3 id="7-索引设计原则">7.索引设计原则</h3>
<p>1.针对于数据量较大（数据量超过100万左右），且查询比较频繁的表建立索引。</p>
<p>2.针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。</p>
<p>3.尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p>
<p>4.如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p>
<p>5.尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p>
<p>6.要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p>
<p>7.如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p>
<h2 id="3-SQL优化">3.SQL优化</h2>
<h3 id="1-插入数据">1.插入数据</h3>
<h4 id="1-insert优化">1.insert优化</h4>
<h5 id="1-批量插入">1.批量插入</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 <span class="keyword">values</span>（），（），（），.....；</span><br></pre></td></tr></table></figure>
<p># 因为每一次insert插入都会与数据库进行建立连接和网络传输，所以将多个insert合并为一个</p>
<p># 插入数据量在500-1000较为合适</p>
<h5 id="2-手动提交事务">2.手动提交事务</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction；</span><br><span class="line"></span><br><span class="line">insert......;</span><br><span class="line"></span><br><span class="line">insert......;</span><br><span class="line"></span><br><span class="line">insert......;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-主键顺序插入">3.主键顺序插入</h5>
<ul>
<li>主键乱序插入</li>
<li>主键顺序插入</li>
</ul>
<p># 顺序插入的性能高于乱序插入，与MySQL的数据组织结构有关</p>
<h4 id="2-大批量插入数据">2.大批量插入数据</h4>
<ul>
<li>
<p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入</p>
</li>
<li>
<p>客户端连接服务端时，加上参数  --local-infile  用于加载本地文件</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql --local-infile -u root -p</span><br></pre></td></tr></table></figure>
<ul>
<li>设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile<span class="operator">=</span><span class="number">1</span>；</span><br></pre></td></tr></table></figure>
<p># 可以再用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@local_infile</span>；</span><br></pre></td></tr></table></figure>
<p>查看值为多少，是否开启</p>
<ul>
<li>执行load指令将准备好的数据，加载到表结构中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">load data <span class="keyword">local</span> infile ‘<span class="operator">/</span>root<span class="operator">/</span>文件名’ <span class="keyword">into</span> ‘表名’ fields terminated <span class="keyword">by</span>  ‘，’ lines terminated <span class="keyword">by</span> ‘\n<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure>
<p># ‘，’表示指定用，分割每个字段，‘\n’表示指定用\n分割每一行数据</p>
<p># 需要先将文件上传到服务器中</p>
<p># 同样要按照主键顺序插入</p>
<h3 id="2-主键优化">2.主键优化</h3>
<h4 id="1-数据组织方式">1.数据组织方式</h4>
<ul>
<li>
<p>在innodb存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（iot）</p>
</li>
<li>
<p>页分裂</p>
</li>
<li>
<p>页可以为空，也可以填充一半，或者全部填充，每个页至少包含2行数据（如果某一行数据过大，会行溢出），根据主键排列</p>
</li>
<li>
<p>主键顺序插入：当第一个页填充满了，数据会在第二个页继续填充，同时会在一二页中维护一个双向指针</p>
</li>
<li>
<p>主键乱序插入：例如第一个页中有值为1 5 9 23 47，第二个页中有值为55 67 89 101 107，且这两页已经填充满，此时插入一个值为50的行数据，那么会先生成一个新的数据页，再找到第一个页的50%的位置，即1 5 9和23 47，则先将23 47移动到生成的第三个页，再将50插入到第三个页，那么原本的链表指针是一二之间的，则重新设置一三间的双向指针和三二之间的双向指针，此现象被称为页分裂</p>
</li>
<li>
<p>页合并</p>
</li>
<li>
<p>当删除一行数据时，并没有真正的删除，只是数据被标记为删除并且它的空间允许被其他数据声明使用</p>
</li>
<li>
<p>当页中删除的数据达到merge_threshold（合并页的阈值，默认为页的50%，可以自己设置，在创建表或者创建索引时指定），innodb会开始寻找最近的页查看是否可以将两个页合并以优化空间使用</p>
</li>
</ul>
<h4 id="2-主键设计原则">2.主键设计原则</h4>
<ul>
<li>
<p>满足业务需求的情况下，尽可能降低主键的长度，过长会占用空间，耗费大量磁盘io</p>
</li>
<li>
<p>插入数据时，尽量选择顺序插入，选择auto_increment自增主键</p>
</li>
<li>
<p>尽量不要使用uuid（每次生成的是无序的，导致乱序插入，可能页分裂，uuid v7是有序的）做主键或者其他自然主键，如身份证号（长度较长）</p>
</li>
<li>
<p>业务操作时，避免对主键的修改</p>
</li>
</ul>
<h3 id="3-order-by优化">3.order by优化</h3>
<ul>
<li>
<p>using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所以不是通过索引直接返回排序结果的排序都叫FileSort排序</p>
</li>
<li>
<p>using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高</p>
</li>
<li>
<p>索引创建出来默认是升序排序的，在信息collation中显示A（asc），所以如果在查询时order by后面的字段都是倒序，就会在explain的extra中提示backward index scan（反向扫描索引）</p>
</li>
<li>
<p>如果既有升序又有降序那么在extra中就会既有using index又有using filesort</p>
</li>
</ul>
<p># <strong>可以在创建索引的时候在字段名后加asc/desc来指定升序或降序</strong></p>
<ul>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li>
<li>尽量使用覆盖索引</li>
<li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则</li>
<li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k）</li>
</ul>
<p># 可以用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> ‘sort_buffer_size’；</span><br></pre></td></tr></table></figure>
<p>来查看排序缓冲区的大小</p>
<p># 如果排序缓冲区满了，会在磁盘文件中排序，性能就会较低</p>
<h3 id="4-group-by优化">4.group by优化</h3>
<ul>
<li>通过索引来提升效率</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的</li>
</ul>
<p># 在group by后面使用字段也可以走联合索引</p>
<h3 id="5-limit优化">5.limit优化</h3>
<ul>
<li>正常limit查询时，如从200000000条开始一页10行数据，这时会将前200000010都排序，但是最终只返回10条记录</li>
<li>可以通过覆盖索引和子查询来解决</li>
</ul>
<h3 id="6-count优化">6.count优化</h3>
<ul>
<li>InnoDB中查询count（*）会很耗时，执行时需要把每一行数据从引擎里读出来，然后累加</li>
<li>erMyISAM引擎把一个表的总行数存在了磁盘上，因此执行count（*）的时候会直接返回这个数，效率高</li>
</ul>
<p># 前提是查询时后面没有where条件</p>
<ul>
<li>
<p>count的几种用法</p>
<ul>
<li>
<p>count（）是一个聚合函数，对于返回的结果集，一行一行地判断，如果count函数的参数不是null，累计值就加1，否则不加，最后返回累计值</p>
</li>
<li>
<p>用法：</p>
<ul>
<li>count（*）：InnoDB引擎不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行累加</li>
<li>count（主键）：InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层，服务层获取主键后直接按行进行累加（主键不可能是null）</li>
<li>count（字段）：
<ul>
<li>没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null则计数</li>
<li>有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回服务层直接累加</li>
</ul>
</li>
<li>count（1）：InnoDB引擎会遍历整张表，但不取值，服务层对于返回的每一行，放一个数字1进去，直接按行累加</li>
</ul>
<p># 官方文档中说，count（*）和count（1）的优化是一样的</p>
<p># 效率：count（字段）&lt;count（主键）&lt;count（1）=count（*）</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-update优化">7.update优化</h3>
<ul>
<li>InnoDB的行锁是针对索引加的锁，不是针对记录加的，并且该索引不能失效，否则会从行锁升级为表锁</li>
</ul>
<p># 在一个窗口中开启事务，where条件后跟的是有索引的且不能是前面提到过的各种索引失效的字段，则符合条件的行数据会被锁定（在另一个会话中可以对其他行数据进行update），否则则会将整张表锁住，在另一个会话中开启事务对表中任意一行数据update都无法成功</p>
<h2 id="4-视图">4.视图</h2>
<h3 id="1-介绍">1.介绍</h3>
<ul>
<li>视图（view）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图查询中使用的表（基表/基础表），并且在使用视图时动态生成的</li>
<li>视图只保存查询的SQL逻辑，不保存查询结果，所以在创建视图的时候，主要在于创建SQL查询语句</li>
</ul>
<h3 id="2-基本语法">2.基本语法</h3>
<h4 id="1-创建">1.创建</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名称（列名列表） <span class="keyword">as</span> <span class="keyword">select</span>语句 wtih <span class="keyword">cascaded</span><span class="operator">/</span>loacl <span class="keyword">check</span> option；</span><br></pre></td></tr></table></figure>
<p># 如不需要替换视图则or replace可以省略</p>
<p># 不需要检查增删改是否满足条件时wtih cascaded/loacl check option可以省略</p>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> stu_i_n <span class="keyword">as</span> <span class="keyword">select</span> id，name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-查询">2.查询</h4>
<ul>
<li>查看创建视图的语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名称；</span><br></pre></td></tr></table></figure>
<ul>
<li>查看视图数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 视图名称 .........;</span><br></pre></td></tr></table></figure>
<p># 后面可以添加条件</p>
<h4 id="3-修改">3.修改</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名称（列名列表） <span class="keyword">as</span> <span class="keyword">select</span>语句 wtih <span class="keyword">cascaded</span><span class="operator">/</span>loacl <span class="keyword">check</span> option；</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称（列名列表） <span class="keyword">as</span> <span class="keyword">select</span>语句 wtih <span class="keyword">cascaded</span><span class="operator">/</span>loacl <span class="keyword">check</span> option；</span><br></pre></td></tr></table></figure>
<h4 id="4-删除">4.删除</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> 视图名称 <span class="number">1</span>，视图名称<span class="number">2</span>， .......；</span><br></pre></td></tr></table></figure>
<h3 id="3-检查选项">3.检查选项</h3>
<ul>
<li>
<p>当使用with check option子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的条件。MySQL允许基于另一个视图创建视图，它还会检查<strong>所依赖视图</strong> 中的规则以保持一致性。为了确定检查的范围，MySQL提供了两个选项：cascaded和local，默认值为cascaded（级联）</p>
</li>
<li>
<p><strong>cascaded</strong> ：检查视图以及其所依赖的视图的条件</p>
</li>
<li>
<p><strong>local</strong> ：检查视图条件，再查看其所依赖的视图是否有with check option来检查条件，有则检查，没有则只需满足当前视图条件</p>
</li>
</ul>
<h3 id="4-更新">4.更新</h3>
<ul>
<li>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则视图不可更新
<ul>
<li>聚合函数或窗口函数（sum，min，max，count）</li>
<li>distinct</li>
<li>group by</li>
<li>having</li>
<li>union或union all</li>
</ul>
</li>
</ul>
<h3 id="5-作用">5.作用</h3>
<ul>
<li>简单
<ul>
<li>视图不仅可以简化用户对数据的理解，也可以简化操作。经常使用的查询可以被定义为视图（类似于封装成函数），从而使得用户不必为以后的操作每次指定全部的条件</li>
</ul>
</li>
<li>安全
<ul>
<li>数据库可以授权，但不能授权到数据库的特定行和列上。通过视图用户只能查询修改授权的数据</li>
</ul>
</li>
<li>数据独立
<ul>
<li>视图可以帮助用户屏蔽真实表结构变化带来的影响，当基表的字段名改变时，可以通过起别名的方式使视图的字段名和基表原始字段相同</li>
</ul>
</li>
</ul>
<h2 id="5-储存过程">5.储存过程</h2>
<h3 id="1-介绍-2">1.介绍</h3>
<ul>
<li>
<p>存储过程是事先经过编译并存储在数据库中的一段SQL语句集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器间的传输，提高数据处理的效率</p>
</li>
<li>
<p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>封装，重用</li>
<li>可以接收参数，也可以返回数据</li>
<li>减少网络交互，提升效率</li>
</ul>
</li>
</ul>
<h3 id="2-基本语法-2">2.基本语法</h3>
<h4 id="1-创建-2">1.创建</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称（参数列表）</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">SQL</span>语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>；</span><br></pre></td></tr></table></figure>
<p># 在<strong>命令行</strong> 中创建存储过程时，SQL语句中会有**；** ，导致判定为SQL语句完成</p>
<p># <strong>需要用关键字delimiter指定SQL语句的结束符</strong></p>
<ul>
<li>
<p>即<strong>delimiter</strong> 指定符号</p>
</li>
<li>
<p>在end后将；改为指定符号</p>
</li>
<li>
<p>同样也可以改回；</p>
</li>
</ul>
<h4 id="2-调用">2.调用</h4>
<ul>
<li><strong>call 名称（参数）；</strong></li>
</ul>
<h4 id="3-查看">3.查看</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema <span class="operator">=</span> <span class="string">&#x27;xxxx&#x27;</span>；</span><br></pre></td></tr></table></figure>
<p># 在information_schema这个数据库中的routines这张表中，routine_schema限制数据库名称</p>
<p># 查询指定数据库的存储过程及状态信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称；</span><br></pre></td></tr></table></figure>
<ul>
<li># 查询某个存储过程的定义</li>
</ul>
<h4 id="4-删除-2">4.删除</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> 存储过程名称；</span><br></pre></td></tr></table></figure>
<h3 id="3-变量">3.变量</h3>
<h4 id="1-系统变量">1.系统变量</h4>
<ul>
<li>是MySQL服务器提供，不是用户自定义的，属于服务器层面，分为全局变量（global），会话变量(session）</li>
</ul>
<p># 没有指定session或global则默认为session</p>
<h5 id="1-查看系统变量">1.查看系统变量</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> session<span class="operator">/</span><span class="keyword">global</span> variables；</span><br></pre></td></tr></table></figure>
<p># 查看所有系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> session<span class="operator">/</span><span class="keyword">global</span> variables <span class="keyword">like</span> ‘.........’；</span><br></pre></td></tr></table></figure>
<p># 通过like模糊匹配查找变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span><span class="operator">/</span>global.系统变量名；</span><br></pre></td></tr></table></figure>
<p># 查看指定变量的值</p>
<h5 id="2-设置系统变量">2.设置系统变量</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session<span class="operator">/</span><span class="keyword">global</span> 系统变量名<span class="operator">=</span>值；</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@session</span><span class="operator">/</span><span class="keyword">global</span> 系统变量名<span class="operator">=</span>值；</span><br></pre></td></tr></table></figure>
<p># 重启后设置的全局参数会恢复默认值，可以在/etc/my.cnf中配置</p>
<h4 id="2-用户自定义变量">2.用户自定义变量</h4>
<ul>
<li>是用户根据需要自己定义的变量，<strong>用户变量不用提前声明</strong> ，在用的时候直接用**@变量名** 使用就可以，其作用域为当前连接</li>
</ul>
<h5 id="1-赋值">1.赋值</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @变量名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>，......；</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @变量名<span class="number">1</span> ：<span class="operator">=</span>值<span class="number">1</span>，......；</span><br></pre></td></tr></table></figure>
<p># 建议使用**：=**</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @变量名<span class="number">1</span> ：<span class="operator">=</span>值<span class="number">1</span>，......；</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> @变量名 <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p># 将查询结果赋给变量</p>
<h5 id="2-使用">2.使用</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @变量名<span class="number">1</span>，......；</span><br></pre></td></tr></table></figure>
<p># 直接使用一个未赋值的变量也不会报错，只会返回null</p>
<h4 id="3-局部变量">3.局部变量</h4>
<ul>
<li>是根据需要定义的在局部生效的变量，<strong>访问前需要declare声明</strong> ，可用作存储过程内的局部变量和输入参数，<strong>局部变量的范围是在其内声明的begin…end块</strong></li>
</ul>
<h5 id="1-声明">1.声明</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> 变量名 变量类型 <span class="keyword">default</span> ....；</span><br></pre></td></tr></table></figure>
<h5 id="2-赋值">2.赋值</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名<span class="operator">=</span>值；</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名 ：<span class="operator">=</span>值；</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名 ......；</span><br></pre></td></tr></table></figure>
<h3 id="4-if">4.if</h3>
<ul>
<li>语法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if 条件<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">	.......</span><br><span class="line">elseif 条件<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">	........</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	........</span><br><span class="line"><span class="keyword">end</span> if；</span><br></pre></td></tr></table></figure>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> score <span class="type">int</span> <span class="keyword">default</span> <span class="number">58</span> #这里将分数的默认值设为<span class="number">58</span>，没有参数</span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">	if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">	elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;不及格&#x27;</span></span><br><span class="line">	<span class="keyword">end</span> if;</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-参数">5.参数</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td># 默认为in</td>
</tr>
<tr>
<td>out</td>
<td>该类参数作为输出，也就是该参数可以作为返回值</td>
<td></td>
</tr>
<tr>
<td>inout</td>
<td>既可以作为输入参数，也可以作为输出参数</td>
<td># 可以用于作为百分制转化的参数</td>
</tr>
</tbody>
</table>
<ul>
<li>语法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称（<span class="keyword">in</span><span class="operator">/</span><span class="keyword">out</span><span class="operator">/</span><span class="keyword">inout</span> 参数名 参数类型）</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">SQL</span>语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>；</span><br></pre></td></tr></table></figure>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1(<span class="keyword">in</span> score <span class="type">int</span>，<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>)) #这里将分数的类型设置为<span class="keyword">in</span>传入，同时设置<span class="keyword">result</span>为<span class="keyword">out</span>返回</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">	elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;不及格&#x27;</span></span><br><span class="line">	<span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p># call的时候就要传入一个参数，同时还要自定义一个变量来接收返回的结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> p1(<span class="number">68</span>,<span class="variable">@result1</span>);</span><br></pre></td></tr></table></figure>
<p># 这里执行完不会直接显示result，要查询@result1才能显示</p>
<h3 id="6-case">6.case</h3>
<ul>
<li>语法一</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 表达式</span><br><span class="line">	<span class="keyword">when</span> 值<span class="number">1</span> <span class="keyword">then</span> sql1语句</span><br><span class="line">	<span class="keyword">when</span> 值<span class="number">2</span> <span class="keyword">then</span> sql2语句</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">else</span> sql3语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>语法二</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br><span class="line">	<span class="keyword">when</span> 条件表达式<span class="number">1</span> <span class="keyword">then</span> sql1语句</span><br><span class="line">	<span class="keyword">when</span> 条件表达式<span class="number">2</span> <span class="keyword">then</span> sql2语句</span><br><span class="line">	.......</span><br><span class="line">	<span class="keyword">else</span> sql3语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p6(<span class="keyword">in</span> <span class="keyword">month</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>）；</span><br><span class="line">	<span class="keyword">case</span></span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;第一季度&#x27;</span>；</span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">6</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;第二季度&#x27;</span>；</span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">9</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;第三季度&#x27;</span>；</span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">12</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;第四季度&#x27;</span>；</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;非法参数&#x27;</span>；</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">case</span>；</span><br><span class="line">	<span class="keyword">select</span> concat(<span class="string">&#x27;您输入的月份为：&#x27;</span>,<span class="keyword">month</span>，<span class="string">&#x27;，所属的季度为：&#x27;</span>，<span class="keyword">result</span>）；</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-循环">7.循环</h3>
<h4 id="1-while">1.while</h4>
<ul>
<li>
<p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">while 条件 do</span><br><span class="line">	<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure>
<p># 先判定条件，如果为true，则执行语句，否则不执行</p>
<p># 例如从1到n的累加</p>
<h4 id="2-repeat">2.repeat</h4>
<ul>
<li>
<p>repeat是有条件的循环控制语句，当满足条件时退出循环</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">repeat</span><br><span class="line">	<span class="keyword">sql</span>语句</span><br><span class="line">	until 条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure>
<p># 先执行一次语句，然后判定是否满足条件，满足则退出，不满足则继续下一次循环</p>
<p># 同样也可以做累加的操作</p>
<h4 id="3-loop">3.loop</h4>
<ul>
<li>
<p>loop实现简单的循环，如果不在SQL语句中增加退出循环的条件，可以用其来实现简单的死循环</p>
</li>
<li>
<p>loop配合以下两个语句使用</p>
</li>
<li>
<p><strong>leave</strong> ：配合循环使用，退出循环</p>
</li>
<li>
<p><strong>iterate</strong> ：必须用在循环中，作用时跳过当前循环剩下的语句，直接进入下一次循环</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">标识名:loop</span><br><span class="line">	<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span> loop 标识名;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">leave 标识名;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">iterate 标识名;</span><br></pre></td></tr></table></figure>
<p># 同样可以做累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	sum:loop</span><br><span class="line">		if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">			Leave sum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">set</span> total:<span class="operator">=</span> total<span class="operator">+</span>n;</span><br><span class="line">		<span class="keyword">set</span> n:<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">end</span> loop sum;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p># 配合iterate可以做到累加偶数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	sum:loop</span><br><span class="line">		if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">			Leave sum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line">		</span><br><span class="line">		if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">			iterate sum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">set</span> total:<span class="operator">=</span> total<span class="operator">+</span>n;</span><br><span class="line">		<span class="keyword">set</span> n:<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">end</span> loop sum;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-游标（光标）">8.游标（光标）</h3>
<ul>
<li>
<p>游标（cursor）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环处理。游标的使用包括游标的声明，open，fetch，close</p>
</li>
<li>
<p>语法</p>
</li>
<li>
<p>声明游标</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> 游标名称 <span class="keyword">cursor</span> <span class="keyword">for</span> 查询语句;</span><br></pre></td></tr></table></figure>
<p># 游标的声明要在普通变量声明的后面</p>
<ul>
<li>打开游标</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> 游标名称;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取游标记录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fetch</span> 游标名称 <span class="keyword">into</span> 变量<span class="number">1</span>，变量<span class="number">2</span>，......;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭游标</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">close</span> 游标名称;</span><br></pre></td></tr></table></figure>
<h3 id="9-条件处理程序">9.条件处理程序</h3>
<ul>
<li>
<p>条件处理程序（handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> handler_action handler <span class="keyword">for</span> condition_value,condition_value,.... <span class="keyword">sql</span>语句;</span><br></pre></td></tr></table></figure>
<p># handler_action:</p>
<p>​	continue：继续执行当前程序</p>
<p>​	exit：终止执行当前程序</p>
<p># condition_value</p>
<p>​	sqlstate：状态码，如0200</p>
<p>​	sqlwarning：所有以01开头的sqlstate代码的简称</p>
<p>​	not found：所有以02开头的sqlstate代码的简称</p>
<p>​	sqlexception：所有没有被sqlwarning和not found捕获的sqlstate代码的简称</p>
<p># 例如要查询所有年龄小于uage的用户的名称和专业</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>）</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>）；</span><br><span class="line">	<span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>）；</span><br><span class="line">	<span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line">	#游标在普通声明后声明</span><br><span class="line">    <span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor；</span><br><span class="line">	#条件处理程序，用于在循环体里结束循环</span><br><span class="line"></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">	<span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">		id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment，</span><br><span class="line">		name <span class="type">varchar</span>(<span class="number">100</span>），</span><br><span class="line">		profession <span class="type">varchar</span>(<span class="number">100</span>）</span><br><span class="line">	）；</span><br><span class="line">	#创建空的表来接收查询出来的数据</span><br><span class="line">                         </span><br><span class="line">    <span class="keyword">open</span> u_cursor；</span><br><span class="line">	while <span class="literal">true</span> do</span><br><span class="line">		<span class="keyword">fetch</span> ucursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">		<span class="keyword">insert into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>, uname, upro)；</span><br><span class="line">	<span class="keyword">end</span> while；</span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line">	#将游标中的数据循环读出，当读完所有数据时仍会循环读取，就会报错<span class="number">02000</span>，上面的条件处理程序就会使其停止执行</span><br><span class="line">                           </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="6-存储函数">6.存储函数</h2>
<ul>
<li>
<p>存储函数是有返回值的存储过程，存储函数的参数只能是in类型的</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数名称（参数列表）</span><br><span class="line"><span class="keyword">returns</span> 数据类型 characteristic</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">sql</span>语句</span><br><span class="line">	return.......;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p># characteristic：</p>
<p>​	deterministic：相同的输入参数总是产生相同的结果</p>
<p>​	no sql：不包含sql语句</p>
<p>​	reads sql data：包含读取数据的语句，但不包含写入数据的语句</p>
<p># 二进制制在版本8是默认开启的，所以会强制指定一个characteristic</p>
<p># 因为有return…;所以可以直接查询这个存储函数来获取结果</p>
<p># 使用较少，存储过程可以替代存储函数</p>
<h2 id="7-触发器">7.触发器</h2>
<h3 id="1-介绍-3">1.介绍</h3>
<ul>
<li>触发器是与表有关的数据库对象，值在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作</li>
<li>使用别名old和new来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发</li>
</ul>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>new和old</th>
</tr>
</thead>
<tbody>
<tr>
<td>insert型触发器</td>
<td>new表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>update型触发器</td>
<td>old表示修改之前的数据，new表示将要或者已经修改后的数据</td>
</tr>
<tr>
<td>delete型触发器</td>
<td>old表示将要或者已经修改的数据</td>
</tr>
</tbody>
</table>
<h3 id="2-语法">2.语法</h3>
<ul>
<li>创建</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名称</span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> #行级触发器</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	具体逻辑;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> 数据库名称.触发器名称</span><br></pre></td></tr></table></figure>
<p># 如果没有指定数据库名称则默认为当前的数据库</p>
<p>#例如一个用户表在增删改时要将增删改的内容记录到一个日志中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> user_logs(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> auto_increment,</span><br><span class="line">operation <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;操作类型，insert/update/delete&#x27;</span>,</span><br><span class="line">operate_time datetime <span class="keyword">not null</span> comment <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">operate_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;操作的ID&#x27;</span>,</span><br><span class="line">operate_params <span class="type">varchar</span>(<span class="number">500</span>) comment <span class="string">&#x27;操作参数&#x27;</span>,</span><br><span class="line"><span class="keyword">primary key</span>(`id`）</span><br><span class="line">engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p># 先创建一个日志用于记录</p>
<p># 创建插入数据触发器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert <span class="keyword">trigger</span></span><br><span class="line">	after <span class="keyword">insert</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">	#插入数据触发必然是after</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <span class="keyword">VALUES</span></span><br><span class="line">	(<span class="keyword">null</span>, <span class="string">&#x27;insert&#x27;</span>, now(), new.id, concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,NEW.phpne,<span class="string">&#x27;,email=&#x27;</span>,NEW.email,<span class="string">&#x27;,professiom=&#x27;</span>,NEW.profession))</span><br><span class="line">	#id是自增的</span><br><span class="line">	#<span class="keyword">insert</span>表示数据操作的类型</span><br><span class="line">	#now()获取当前数据操作时的实际</span><br><span class="line">	#new.id获取操作数据的id</span><br><span class="line">	#concat用于拼接后面这些新的数据</span><br><span class="line"><span class="keyword">end</span>；</span><br></pre></td></tr></table></figure>
<p># 更新和删除也类似，更新时要同时记录更新前和更新后的数据，就再用old.字段名来获取，删除则只记录删除操作前的数据，只需要old.字段名</p>
<h2 id="8-锁">8.锁</h2>
<h3 id="1-介绍-4">1.介绍</h3>
<ul>
<li>锁是计算机协调多个进程或者线程并发访问某一资源的机制。在数据库中，除传统的计算资源（cpu，ram，i/o）的争用以外，数据也是一种供许多用户享用的资源。任何保证数据并发访问的一致性，有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素</li>
</ul>
<h3 id="2-全局锁">2.全局锁</h3>
<ul>
<li>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于<strong>只读状态</strong> ，后续的dml语句，ddl语句和已经更新操作的事务提交语句都会被阻塞</li>
<li>典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性</li>
</ul>
<h4 id="1-语法">1.语法</h4>
<ul>
<li>加全局锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure>
<ul>
<li>备份时可以使用MySQL的工具mysqldump（不要在MySQL中执行，这是MySQL的工具）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p密码 表名&gt;要转移到的表的表名.sql</span><br></pre></td></tr></table></figure>
<ul>
<li>解锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<h4 id="2-特点">2.特点</h4>
<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务停摆</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟</li>
</ul>
<p># 在InnoDB引擎中，可以在备份时加上参数 --single-transaction参数来完成不加锁的一致性数据备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -p密码 表名&gt;要转移到的表的表名.sql</span><br></pre></td></tr></table></figure>
<h3 id="3-表级锁">3.表级锁</h3>
<ul>
<li>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率高，并发度最低。应用在MyISAM，InnoDB，BDB等存储引擎中</li>
</ul>
<h4 id="1-表锁">1.表锁</h4>
<ul>
<li>
<p>可以分为两类：</p>
<ul>
<li>1.表共享读锁（read lock，读锁）:所有客户端都只能读取数据，加了表锁的客户端写入会报错，其他客户端会被阻塞</li>
<li>2.表独占写锁（write lock，写锁）：加了表锁的客户端可以读写，其他客户端读写会被阻塞</li>
</ul>
</li>
<li>
<p>语法：</p>
</li>
<li>
<p>加锁</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lock tables 表名..... read<span class="operator">/</span>write;</span><br></pre></td></tr></table></figure>
<p># 可以锁定多张表</p>
<ul>
<li>释放锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<p># 或者直接将客户端关闭</p>
<h4 id="2-元数据锁（meta-data-lock，mdl）">2.元数据锁（meta data lock，mdl）</h4>
<ul>
<li>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作，为了避免DML和DDL冲突，保证读写的正确性</li>
<li>MySQL5.5中引入的MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）</li>
</ul>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock tables xxx read/write</td>
<td>shared_read_only/shared_no_read_write</td>
<td></td>
</tr>
<tr>
<td>select，select…lock in share mode</td>
<td>shared_read（共享）</td>
<td>与shared_read，shared_write兼容，与exclusive互斥</td>
</tr>
<tr>
<td>insert，update，delete，select…for update</td>
<td>shared_write（共享）</td>
<td>与shared_read，shared_write兼容，与exclusive互斥</td>
</tr>
<tr>
<td>alter table…</td>
<td>exclusive（排他）</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody>
</table>
<ul>
<li>查看元数据锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure>
<p># metadata_locks这张表中记录了当前数据库中是元数据锁</p>
<h4 id="3-意向锁">3.意向锁</h4>
<ul>
<li>
<p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</p>
</li>
<li>
<p>分为两种：</p>
<ul>
<li>意向共享锁（IS）：由语句select … lock in share mode添加
<ul>
<li>与表锁共享锁（read）兼容，与表锁排他锁（write）互斥，会被阻塞</li>
</ul>
</li>
<li>意向排他锁（IX）：由insert，upadte，delete，select … for update 添加
<ul>
<li>与表锁共享锁（read）及排他锁（write）都互斥。意向锁之间不会互斥</li>
</ul>
</li>
</ul>
</li>
<li>
<p>查看意向锁及行锁的加锁情况</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure>
<h3 id="4-行级锁">4.行级锁</h3>
<h4 id="1-介绍-5">1.介绍</h4>
<ul>
<li>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中</li>
<li>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，不是对记录加锁。</li>
<li>主要分为三类：
<ul>
<li>行锁（record lock，记录锁）：锁定单个行数据的锁，防止其他事务对此行进行update和delete。在rc（read commit），rr（repeatable read）隔离级别下都支持</li>
<li>间隙锁（gap lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在rr隔离级别下都支持</li>
<li>临建锁（next-key lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙gap。在rr隔离级别下支持</li>
</ul>
</li>
</ul>
<h4 id="2-行锁">2.行锁</h4>
<ul>
<li>InnoDB实现了以下两种类型的行锁
<ul>
<li>共享锁（s）：允许一个事务去读一行，即共享锁之间兼容，阻止其他事务获得相同数据集的排他锁</li>
<li>排他锁（x）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">请求锁类型</th>
<th style="text-align:center">s（共享锁）</th>
<th style="text-align:center">x（排他锁）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">当前锁类型：s（共享锁）</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">冲突</td>
</tr>
<tr>
<td style="text-align:left">x（排他锁）</td>
<td style="text-align:center">冲突</td>
<td style="text-align:center">冲突</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>insert</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>update</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>delete</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>select</td>
<td>不加任何锁</td>
<td></td>
</tr>
<tr>
<td>select…lock in share mode</td>
<td>共享锁</td>
<td>需要手动在select后加lock in share mode</td>
</tr>
<tr>
<td>select…for update</td>
<td>排他锁</td>
<td>需要手动在select后加for update</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>在默认情况下，InnoDB在repeatable read事务隔离级别运行，InnoDB使用next-key锁进行搜素和索引扫描，以防止幻读</p>
</li>
<li>
<p>1.针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁</p>
</li>
<li>
<p>2.InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁</p>
</li>
<li>
<p>查看意向锁及行锁的加锁情况</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure>
<h4 id="3-间隙锁-临建锁">3.间隙锁/临建锁</h4>
<ul>
<li>默认情况下，InnoDB在repeatable read事务隔离级别运行，InnoDB使用next-key锁进行搜素和索引扫描，以防止幻读</li>
<li>1.索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁</li>
<li>2.索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁</li>
<li>3.索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止</li>
</ul>
<p># 间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙采用间隙锁</p>
<h2 id="9-InnoDB引擎">9.InnoDB引擎</h2>
<h3 id="1-逻辑存储结构">1.逻辑存储结构</h3>
<ul>
<li>tablespace：表空间（ibd文件）一个mysql实例可以对应多个表空间，用于存储记录，索引等数据
<ul>
<li>segment：段，分为数据段（leaf node segment），索引段（non-leaf node segment），回滚段（rollback segment），InnoDB是索引组织表，数据段就是B+tree的叶子节点，索引是B+tree的非叶子节点。段用来管理多个区
<ul>
<li>extent：区，表空间的单元结构，每个页的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页
<ul>
<li>page：页，是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区
<ul>
<li>row：行，InnoDB存储引擎数据是按行进行存放的
<ul>
<li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给Trx_id隐藏列</li>
<li>Roll_pointer：每次对某条记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-架构">2.架构</h3>
<ul>
<li>MySQL5.5之后，默认使用InnoDB存储引擎，它擅长事务处理，具有奔溃恢复特性，在日常开发中使用广泛</li>
</ul>
<h4 id="1-内存架构">1.内存架构</h4>
<h5 id="1-Buffer-Pool">1.Buffer Pool</h5>
<ul>
<li>
<p>缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</p>
</li>
<li>
<p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态将Page分为三种类型：</p>
<ul>
<li>free page：空闲page，未被使用</li>
<li>clean page：被使用page，数据没有被修改过</li>
<li>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘数据产生了不一致，还未刷新到磁盘</li>
</ul>
</li>
</ul>
<h5 id="2-Change-Buffer">2.Change Buffer</h5>
<ul>
<li>
<p>更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中</p>
</li>
<li>
<p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更<br>
新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了<br>
ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p>
</li>
</ul>
<h5 id="3-Adaptive-Hash-Index">3.Adaptive Hash Index</h5>
<ul>
<li>自适应hash索引，用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引</li>
<li>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</li>
<li>参数：adaptive_hash_index，可以查询是否开启</li>
</ul>
<h5 id="4-Log-Buffer">4.Log Buffer</h5>
<ul>
<li>日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘IO</li>
<li>参数：
<ul>
<li>缓冲区大小：innodb_log_buffer_size</li>
<li>日志刷新到磁盘时机：innodb_flush_log_at_trx_commit
<ul>
<li>1：日志在每次事务提交时写入并刷新磁盘</li>
<li>0：每秒将日志写入并刷新磁盘一次</li>
<li>2：日志在每次事务提交后写入，并每秒刷新到磁盘一次</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-磁盘结构">2.磁盘结构</h4>
<h5 id="1-System-Tablespace">1.System Tablespace</h5>
<ul>
<li>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等）</li>
<li>参数：innodb_data_file_path</li>
</ul>
<h5 id="2-File-Per-Table-Tablespaces">2.File-Per-Table Tablespaces</h5>
<ul>
<li>每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。</li>
<li>参数：innodb_file_per_table</li>
</ul>
<p># 默认开启</p>
<h5 id="3-General-Tablespaces">3.General Tablespaces</h5>
<ul>
<li>
<p>通用表空间，需要通过CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p>
</li>
<li>
<p>语法：</p>
</li>
<li>
<p>创建通用表空间</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> tablespace xxxx <span class="keyword">add</span> datafile <span class="string">&#x27;表空间关联的表空间文件&#x27;</span> engine<span class="operator">=</span><span class="string">&#x27;引擎名称&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>指定表空间</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> xxx... tablespace 表空间名称;</span><br></pre></td></tr></table></figure>
<h5 id="4-Undo-Tablespaces">4.Undo Tablespaces</h5>
<ul>
<li>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间(初始大小16M)，用于存储undo log日志。</li>
</ul>
<h5 id="5-Temporary-Tablespaces">5.Temporary Tablespaces</h5>
<ul>
<li>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</li>
</ul>
<h5 id="6-Doublewrite-Buffer-Files">6.Doublewrite Buffer Files</h5>
<ul>
<li>
<p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p>
</li>
<li>
<p>dblwr后缀文件</p>
</li>
</ul>
<h5 id="7-Redo-Log">7.Redo Log</h5>
<ul>
<li>
<p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：</p>
<ul>
<li>重做日志缓冲(redo log buffer），在内存中</li>
<li>重做日志文件（redo log）在磁盘中。</li>
</ul>
</li>
<li>
<p>当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p>
</li>
<li>
<p>以循环方式写入重做日志，涉及两个文件ib_logfile0和ib_logfile1</p>
</li>
</ul>
<h4 id="3-后台线程">3.后台线程</h4>
<h5 id="1-Master-Thread">1.Master Thread</h5>
<ul>
<li>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。</li>
</ul>
<h5 id="2-IO-Thread"><a href="http://2.IO">2.IO</a> Thread</h5>
<ul>
<li>在InnoDB存储引擎中大量使用了AIO来处理IO请求，这样可以极大地提高数据库的性能，而IO Thread主要负素这些IO请求的回调。</li>
</ul>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>默认个数</th>
<th>职责</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read thread</td>
<td>4</td>
<td>负责读操作</td>
</tr>
<tr>
<td>Write thread</td>
<td>4</td>
<td>负责写操作</td>
</tr>
<tr>
<td>Log thread</td>
<td>1</td>
<td>负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td>Insert buffer thread</td>
<td>1</td>
<td>负责将写缓冲区内容刷新到磁盘</td>
</tr>
</tbody>
</table>
<h5 id="3-Purge-Thread">3.Purge Thread</h5>
<ul>
<li>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收</li>
</ul>
<h5 id="4-Page-Cleaner-Thread">4.Page Cleaner Thread</h5>
<ul>
<li>协助Master Thread刷新脏页到磁盘的线程，它可以减轻Master Thread的工作压力，减少阻塞</li>
</ul>
<h4 id="4-总结">4.总结</h4>
<ul>
<li>业务操作时直接操作缓冲区中的数据，缓冲区中没有数据时，将磁盘中的数据加载回来再存储到缓冲区中，缓冲区中的数据再以一定的频率，通过后台线程刷新到磁盘中，在磁盘中进行永久化保留</li>
</ul>
<h3 id="3-事务原理">3.事务原理</h3>
<h4 id="1-概述">1.概述</h4>
<ul>
<li>
<p>事务有四个特性：</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
</li>
<li>
<p>其中原子性，一致性，持久性由redo log和undo log这两份日志来保证</p>
</li>
<li>
<p>隔离性则由锁机制和MVCC多版本并发控制来实现</p>
</li>
</ul>
<h4 id="2-redo-log">2.redo log</h4>
<ul>
<li>
<p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>
</li>
<li>
<p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
</li>
<li>
<p>这种先写日志再将脏页中的数据刷新到磁盘的机制称为WAL(Write-Ahead-Logging)</p>
</li>
<li>
<p>保证了事务的持久性</p>
</li>
</ul>
<h4 id="3-undo-log">3.undo log</h4>
<ul>
<li>回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和 MVCC(多版本并发控制)。</li>
<li>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录（updata之前的数据）。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li>
<li>保证了事务的原子性</li>
<li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li>
<li>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</li>
</ul>
<h3 id="4-MVCC">4.MVCC</h3>
<h4 id="1-基本概念">1.基本概念</h4>
<h5 id="1-当前读">1.当前读</h5>
<ul>
<li>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于日常操作，如select…lock in share mode（共享锁），select …for update，update，insert，delete（排他锁）都是一种当前读</li>
</ul>
<h5 id="2-快照读">2.快照读</h5>
<ul>
<li>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</li>
<li>Read Committed：每次select，都生成一个快照读。</li>
<li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li>
<li>Serializable：快照读会退化为当前读。</li>
</ul>
<h5 id="3-MVCC">3.MVCC</h5>
<ul>
<li>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现</li>
<li>MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</li>
</ul>
<h4 id="2-实现原理">2.实现原理</h4>
<h5 id="1-隐藏字段">1.隐藏字段</h5>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DB_TRX_ID</td>
<td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td>
</tr>
</tbody>
</table>
<h5 id="2-undo-log">2.undo log</h5>
<ul>
<li>
<p>回滚日志，在insert、 update、delete的时候产生的便于数据回滚的日志。</p>
<ul>
<li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</li>
<li>而update、delete的时候，产生的undo log不仅在回滚时需要，在快照读时也需要，不会立即被删除。</li>
</ul>
</li>
<li>
<p>undo log版本链</p>
</li>
<li>
<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录</p>
</li>
<li>
<p>DB_ROLL_PTR指向上一个修改的记录</p>
</li>
</ul>
<h5 id="3-readview">3.readview</h5>
<ul>
<li>readview（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交）id</li>
<li>readview中包含四个核心字段：</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>m_ids</td>
<td>当前活跃的事务id集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务id</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务id，当前最大事务id+1（因为事务id是自增的）</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>readview创建者的事务id</td>
</tr>
</tbody>
</table>
<ul>
<li>版本链数据访问规则
<ul>
<li>trx_id==creator_trx_id？可以访问该版本
<ul>
<li>说明数据是当前这个事务更改的</li>
</ul>
</li>
<li>trx_id&lt;min_trx_id？可以访问该版本
<ul>
<li>说明数据已经提交了</li>
</ul>
</li>
<li>trx_id&gt;max_trx_id？不可以访问该版本
<ul>
<li>说明该事务是再readview生成后才开启</li>
</ul>
</li>
<li>min_trx_id&lt;=trx_id&lt;=max_trx_id？如果trx_id<strong>不在</strong> m_ids中是可以访问该版本的
<ul>
<li>说明数据已经提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<p># trx_id：代表undo log中每一条数据的当前事务id</p>
<p># 从最新的undo log记录，逐条数据进行比对，直到查找到符合规则的记录返回</p>
<ul>
<li>不同的隔离级别，生成readview的时机不同
<ul>
<li>rc：在事务每一次执行快照读时生成readview</li>
<li>rr：仅在事务中第一次执行快照读时生成readview，后续复用该readview</li>
</ul>
</li>
</ul>
<h2 id="10-MySQL管理">10.MySQL管理</h2>
<h3 id="1-系统数据库">1.系统数据库</h3>
<ul>
<li>在MySQL数据库安装完后，自带了四个数据库</li>
</ul>
<table>
<thead>
<tr>
<th>数据库</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql</td>
<td>存储MySQL服务器正常运行所需要的各种信息（时区，主从，用户，权限）</td>
</tr>
<tr>
<td>information_schema</td>
<td>提供了访问数据库元数据的各种表和视图，包含数据库，表，字段类型及访问权限等</td>
</tr>
<tr>
<td>performance_schema</td>
<td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td>
</tr>
<tr>
<td>sys</td>
<td>包含了一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</td>
</tr>
</tbody>
</table>
<h3 id="2-常用工具">2.常用工具</h3>
<h4 id="1-mysql">1.mysql</h4>
<ul>
<li>
<p>mysql的客户端工具</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql 选项 数据库</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>选项：</p>
<ul>
<li>
<p>-u，指定用户名</p>
</li>
<li>
<p>-p，指定密码</p>
</li>
<li>
<p>-h，指定服务器IP或域名</p>
</li>
<li>
<p>-P，指定连接端口</p>
</li>
<li>
<p>-e，执行SQL语句并退出</p>
<ul>
<li>
<p>-e这个选项可以在MySQL客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式较为方便</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p密码 数据库名 -e&#x27;sql语句&#x27;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h4 id="2-mysqladmin">2.mysqladmin</h4>
<ul>
<li>
<p>mysqladmin是一个执行管理操作的客户端程序，可以用它来检查服务器的配置和当前状态，创建并删除数据库等</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p密码 drop 数据库名</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p密码 version</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过帮助文档查看选项：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqladmin --help</span><br></pre></td></tr></table></figure>
<h4 id="3-mysqlbinlog">3.mysqlbinlog</h4>
<ul>
<li>
<p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog日志管理工具</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlbinlog 选项 binlog文件名1 binlog文件名2 ...</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>选项：</p>
<ul>
<li>-d，指定数据库名称，只列出指定的数据库相关操作</li>
<li>-o，忽略掉日志中的前n行命令</li>
<li>-r，将输出的文本格式日志输出到指定文件中</li>
<li>-s，显示简单格式，省略掉一些信息</li>
<li>–start-datetime=起始日期 --stop-datetime=截止日期，指定日期间隔内的所有日志</li>
<li>–start-positon=日志起始位置 --stop-position=日志截止位置，指定位置间隔内的所有日志</li>
</ul>
</li>
</ul>
<h4 id="4-mysqlshow">4.mysqlshow</h4>
<ul>
<li>
<p>mysqlshow客户端对象查找工具，用来快速查找存在哪些数据库，数据库中的表，表中的列或者索引</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlshow 选项 数据库名称 表名称 字段名称</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>选项：</p>
<ul>
<li>–count，显示数据库及表的统计信息（数据库，表均可不指定）</li>
<li>-i，显示指定数据库或者指定表的状态信息</li>
</ul>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlshow -uroot -p密码 --count</span><br></pre></td></tr></table></figure>
<p># 查询每个数据库的表的数量及表中记录的数量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlshow -uroot -p密码 数据库名 --count</span><br></pre></td></tr></table></figure>
<p># 查询指定数据库中每个表中的字段数及行数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlshow -uroot -p密码 数据库名 表名 --count</span><br></pre></td></tr></table></figure>
<p># 查询指定数据库中指定表的详细情况</p>
<h4 id="5-mysqldump">5.mysqldump</h4>
<ul>
<li>
<p>mysqldump客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump 选项 数据库名 表名</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump 选项 --database 数据库名1 数据库名2 ...</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump 选项 -B 数据库名1 数据库名2 ...</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump 选项 --all-databases</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump 选项 -A</span><br></pre></td></tr></table></figure>
<p># 后面加**&gt; 文件名.sql** 来指定保存到哪个文件</p>
<ul>
<li>
<p>选项：</p>
<ul>
<li>
<p>连接选项：</p>
<ul>
<li>
<p>-u，指定用户名</p>
</li>
<li>
<p>-p，指定密码</p>
</li>
<li>
<p>-h，指定服务器IP或域名</p>
</li>
<li>
<p>-P，指定连接端口</p>
</li>
</ul>
</li>
<li>
<p>输出选项：</p>
<ul>
<li>–add-drop-database，在每个数据库创建语句前加上drop database语句</li>
<li>–add-drop-table，在每个表创建语句前加上drop table语句，默认开启；不开启（–skip-add-drop-table）</li>
<li>-n，不包含数据库的创建语句</li>
<li>-t，不包含数据表的创建语句</li>
<li>-d，不包含数据</li>
<li>-T，自动生成两个文件：
<ul>
<li>.sql后缀文件，创建表结构的语句</li>
<li>.txt后缀文件，数据文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-mysqlimport-source">6.mysqlimport/source</h4>
<ul>
<li>
<p>mysqlimport是客户端数据导入工具，用来导入mysqldump加-T参数后导出的文本文件</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlimport 选项 数据库名 文件位置</span><br></pre></td></tr></table></figure>
<ul>
<li>例如：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlimport -uroot -p密码 数据库名 文件目录/文件名.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果需要导入sql文件，可以使用mysql中的source指令</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /root/文件名.sql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>小六壬起课器</title>
    <url>/2025/02/24/%E5%B0%8F%E5%85%AD%E5%A3%AC%E8%B5%B7%E8%AF%BE%E5%99%A8/</url>
    <content><![CDATA[<h1><a href="http://xn--65q44jg8bzxec56fv3b.py">小六壬起课器.py</a></h1>
<h2 id="（仅起到起课作用）">（仅起到起课作用）</h2>
<p>​	小六壬，古代中国占卜法，古代主要用于军事韬略，尤以别名诸葛亮马前课著名。</p>
<p>​	在所有术数中时间都是首位，所以第一则是获取当前用户时间。在运行时可能会遇到用户输入各种类型的数据，所以使用try来运行可能出错的代码，并且在报错后循环让用户重新输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#无限循环</span></span><br><span class="line">   <span class="keyword">try</span>: <span class="comment">#尝试运行可能出错的代码</span></span><br><span class="line">      time=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;以24时制输入当地当前时:&quot;</span>)) <span class="comment">#获取时间  </span></span><br><span class="line">   <span class="keyword">except</span> (ValueError, TypeError): <span class="comment">#数值错误和数值类型错误时的处理</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;错误,输入数字有误,例:当前13:11,则输入13&quot;</span>)</span><br><span class="line">      <span class="keyword">continue</span> <span class="comment">#跳过下面的循环，防止因为上面错误导致time没有获取数值而使下面的判断报错</span></span><br><span class="line">   <span class="keyword">if</span> time <span class="keyword">in</span> list10: <span class="comment">#判断输入数字是否为0~23</span></span><br><span class="line">      <span class="keyword">break</span> <span class="comment">#正常则执行下面的代码</span></span><br><span class="line">   <span class="keyword">else</span>: <span class="comment">#不符合则提示并循环</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;错误,输入数字有误,例:当前13:11,则输入13&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>​	小六壬中常见起课方式有日期起课以及随机数起课，在这里仅做了随机数起课。（后续可能增加以日期起课的选择）仍然使用try语句来处理可能遇到的输入数据类型错误，再将得到三个随机数储存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入心中立即想到的任意大小的正整数&quot;</span>)</span><br><span class="line">numbers1 = [<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]  <span class="comment"># 用列表存储 x, y, z</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment"># 循环三次以获取三个数字</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#无限循环</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            numbers1[i] = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">f&quot;请输入第 <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> 个数字: &quot;</span>)) <span class="comment">#使用f语句</span></span><br><span class="line">            <span class="keyword">if</span> numbers1[i] &lt;= <span class="number">0</span>:  <span class="comment"># 检查输入的数字是否为正整数</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;输入数字有误，请输入正负整数&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 如果输入有效，则退出当前的 while 循环</span></span><br><span class="line">        <span class="keyword">except</span> (ValueError,TypeError):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入数字有误，请输入正负整数&quot;</span>)</span><br><span class="line">x, y, z = numbers1 <span class="comment"># 将输入的数字赋值给 x, y, z</span></span><br></pre></td></tr></table></figure>
<p>​	创建一个列表储存十二个时辰，由于一个时辰对应两个小时，所以列表中时辰储存两次，再将时间对应列表中的时辰，以便后续输出，以及字典的调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;子&#x27;</span>,<span class="string">&#x27;丑&#x27;</span>,<span class="string">&#x27;丑&#x27;</span>,<span class="string">&#x27;寅&#x27;</span>,<span class="string">&#x27;寅&#x27;</span>,<span class="string">&#x27;卯&#x27;</span>,<span class="string">&#x27;卯&#x27;</span>,<span class="string">&#x27;辰&#x27;</span>,<span class="string">&#x27;辰&#x27;</span>,<span class="string">&#x27;巳&#x27;</span>,<span class="string">&#x27;巳&#x27;</span>,<span class="string">&#x27;午&#x27;</span>,<span class="string">&#x27;午&#x27;</span>,<span class="string">&#x27;未&#x27;</span>,<span class="string">&#x27;未&#x27;</span>,<span class="string">&#x27;申&#x27;</span>,<span class="string">&#x27;申&#x27;</span>,<span class="string">&#x27;酉&#x27;</span>,<span class="string">&#x27;酉&#x27;</span>,<span class="string">&#x27;戌&#x27;</span>,<span class="string">&#x27;戌&#x27;</span>,<span class="string">&#x27;亥&#x27;</span>,<span class="string">&#x27;亥&#x27;</span>,<span class="string">&#x27;子&#x27;</span>] <span class="comment">#创建时辰列表</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time1 = list1[time] <span class="comment">#将时间对应时辰</span></span><br></pre></td></tr></table></figure>
<p>​	再调用字典将时辰对应12小时制的数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time2 = dict1.get(time1,<span class="string">&#x27;无效值&#x27;</span>) <span class="comment">#调用字典将时辰与数字对应，time1上不用加&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>​	相较于第一版，增加了活六神的功能,仅做展示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time3 = time2%<span class="number">6</span> <span class="comment">#对time2取余数，可知龙头宫位</span></span><br><span class="line">whole = <span class="number">6</span>-time3 <span class="comment">#得出青龙后还有几个元素作为整体</span></span><br><span class="line">element=list11[:whole+<span class="number">1</span>] <span class="comment">#将青龙以及后面的元素作为整体</span></span><br><span class="line"><span class="keyword">if</span> time3 == <span class="number">1</span>:</span><br><span class="line">   list12=list11</span><br><span class="line"><span class="keyword">elif</span> time3 == <span class="number">0</span>:</span><br><span class="line">   list12=[<span class="string">&#x27;朱雀&#x27;</span>,<span class="string">&#x27;勾陈&#x27;</span>,<span class="string">&#x27;白虎&#x27;</span>,<span class="string">&#x27;玄武&#x27;</span>,<span class="string">&#x27;腾蛇&#x27;</span>,<span class="string">&#x27;青龙&#x27;</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   list12=[x <span class="keyword">for</span> x <span class="keyword">in</span> list11 <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> element]+element <span class="comment">#先遍历列表8不属于整体的元素再加上整体中的元素生成新列表10</span></span><br><span class="line">x5,y5,z5 = list5[x1],list5[y1],list5[z1] <span class="comment">#分别给三才赋值六神</span></span><br><span class="line">x6,y6,z6 = list12[x1],list12[y1],list12[z1] <span class="comment">#分别给三才赋值活六神</span></span><br><span class="line">number1,number2,number3 = dict2.get(x3),dict2.get(y3),dict2.get(z3) <span class="comment">#调用字典将五行与列表数字对应</span></span><br><span class="line">list13,list14,list15=<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number1&#125;</span>&#x27;</span>],<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number2&#125;</span>&#x27;</span>],<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number3&#125;</span>&#x27;</span>] <span class="comment">#使用globals()作用于全局区别于locals()只能在一个函数局部内返回变量，生成三才对应的十二长生列表</span></span><br></pre></td></tr></table></figure>
<p>​	由于python自带的以及库中的居中对齐功能无法正常使用，为了美观增加了根据字数增加空格的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_xyz</span>(<span class="params">x,y,z</span>): <span class="comment">#封装成函数</span></span><br><span class="line">   x_len,y_len,z_len = <span class="built_in">len</span>(x),<span class="built_in">len</span>(y),<span class="built_in">len</span>(z)</span><br><span class="line">   <span class="keyword">if</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27; &#x27;</span>, y, <span class="string">&#x27; &#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27; &#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27;&#x27;</span>, y, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27; &#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, y, z)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​	以下是完整代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;子&#x27;</span>,<span class="string">&#x27;丑&#x27;</span>,<span class="string">&#x27;丑&#x27;</span>,<span class="string">&#x27;寅&#x27;</span>,<span class="string">&#x27;寅&#x27;</span>,<span class="string">&#x27;卯&#x27;</span>,<span class="string">&#x27;卯&#x27;</span>,<span class="string">&#x27;辰&#x27;</span>,<span class="string">&#x27;辰&#x27;</span>,<span class="string">&#x27;巳&#x27;</span>,<span class="string">&#x27;巳&#x27;</span>,<span class="string">&#x27;午&#x27;</span>,<span class="string">&#x27;午&#x27;</span>,<span class="string">&#x27;未&#x27;</span>,<span class="string">&#x27;未&#x27;</span>,<span class="string">&#x27;申&#x27;</span>,<span class="string">&#x27;申&#x27;</span>,<span class="string">&#x27;酉&#x27;</span>,<span class="string">&#x27;酉&#x27;</span>,<span class="string">&#x27;戌&#x27;</span>,<span class="string">&#x27;戌&#x27;</span>,<span class="string">&#x27;亥&#x27;</span>,<span class="string">&#x27;亥&#x27;</span>,<span class="string">&#x27;子&#x27;</span>] <span class="comment">#创建时辰列表</span></span><br><span class="line">list2=[<span class="string">&#x27;大安&#x27;</span>,<span class="string">&#x27;留连&#x27;</span>,<span class="string">&#x27;速喜&#x27;</span>,<span class="string">&#x27;赤口&#x27;</span>,<span class="string">&#x27;小吉&#x27;</span>,<span class="string">&#x27;空亡&#x27;</span>] <span class="comment">#创建六宫列表</span></span><br><span class="line">list3=[<span class="string">&#x27;木&#x27;</span>,<span class="string">&#x27;土&#x27;</span>,<span class="string">&#x27;火&#x27;</span>,<span class="string">&#x27;金&#x27;</span>,<span class="string">&#x27;水&#x27;</span>,<span class="string">&#x27;土&#x27;</span>] <span class="comment">#创建五行列表</span></span><br><span class="line">list4=[<span class="string">&#x27;东&#x27;</span>,<span class="string">&#x27;四方&#x27;</span>,<span class="string">&#x27;南&#x27;</span>,<span class="string">&#x27;西&#x27;</span>,<span class="string">&#x27;北&#x27;</span>,<span class="string">&#x27;中央&#x27;</span>] <span class="comment">#创建方位列表</span></span><br><span class="line">list5=[<span class="string">&#x27;青龙&#x27;</span>,<span class="string">&#x27;腾蛇&#x27;</span>,<span class="string">&#x27;朱雀&#x27;</span>,<span class="string">&#x27;白虎&#x27;</span>,<span class="string">&#x27;玄武&#x27;</span>,<span class="string">&#x27;勾陈&#x27;</span>] <span class="comment">#创建六神列表</span></span><br><span class="line">list6=[<span class="string">&#x27;沐浴&#x27;</span>,<span class="string">&#x27;冠带&#x27;</span>,<span class="string">&#x27;临官&#x27;</span>,<span class="string">&#x27;帝旺&#x27;</span>,<span class="string">&#x27;衰&#x27;</span>,<span class="string">&#x27;死&#x27;</span>,<span class="string">&#x27;病&#x27;</span>,<span class="string">&#x27;墓&#x27;</span>,<span class="string">&#x27;绝&#x27;</span>,<span class="string">&#x27;胎&#x27;</span>,<span class="string">&#x27;养&#x27;</span>,<span class="string">&#x27;长生&#x27;</span>] <span class="comment">#创建木对应的十二长生列表</span></span><br><span class="line">list7=[<span class="string">&#x27;胎&#x27;</span>,<span class="string">&#x27;养&#x27;</span>,<span class="string">&#x27;长生&#x27;</span>,<span class="string">&#x27;沐浴&#x27;</span>,<span class="string">&#x27;冠带&#x27;</span>,<span class="string">&#x27;临官&#x27;</span>,<span class="string">&#x27;帝旺&#x27;</span>,<span class="string">&#x27;衰&#x27;</span>,<span class="string">&#x27;死&#x27;</span>,<span class="string">&#x27;病&#x27;</span>,<span class="string">&#x27;墓&#x27;</span>,<span class="string">&#x27;绝&#x27;</span>] <span class="comment">#创建火对应的十二长生列表</span></span><br><span class="line">list8=[<span class="string">&#x27;死&#x27;</span>,<span class="string">&#x27;病&#x27;</span>,<span class="string">&#x27;墓&#x27;</span>,<span class="string">&#x27;绝&#x27;</span>,<span class="string">&#x27;胎&#x27;</span>,<span class="string">&#x27;养&#x27;</span>,<span class="string">&#x27;长生&#x27;</span>,<span class="string">&#x27;沐浴&#x27;</span>,<span class="string">&#x27;冠带&#x27;</span>,<span class="string">&#x27;临官&#x27;</span>,<span class="string">&#x27;帝旺&#x27;</span>,<span class="string">&#x27;衰&#x27;</span>] <span class="comment">#创建金对应的十二长生列表</span></span><br><span class="line">list9=[<span class="string">&#x27;帝旺&#x27;</span>,<span class="string">&#x27;衰&#x27;</span>,<span class="string">&#x27;死&#x27;</span>,<span class="string">&#x27;病&#x27;</span>,<span class="string">&#x27;墓&#x27;</span>,<span class="string">&#x27;绝&#x27;</span>,<span class="string">&#x27;胎&#x27;</span>,<span class="string">&#x27;养&#x27;</span>,<span class="string">&#x27;长生&#x27;</span>,<span class="string">&#x27;沐浴&#x27;</span>,<span class="string">&#x27;冠带&#x27;</span>,<span class="string">&#x27;临官&#x27;</span>] <span class="comment">#创建水，土对应的十二长生列表</span></span><br><span class="line">list10=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>] <span class="comment">#创建时间列表</span></span><br><span class="line">list11=[<span class="string">&#x27;青龙&#x27;</span>,<span class="string">&#x27;朱雀&#x27;</span>,<span class="string">&#x27;勾陈&#x27;</span>,<span class="string">&#x27;白虎&#x27;</span>,<span class="string">&#x27;玄武&#x27;</span>,<span class="string">&#x27;腾蛇&#x27;</span>] <span class="comment">#创建活六神顺序列表</span></span><br><span class="line">dict1=&#123;<span class="string">&#x27;子&#x27;</span>: <span class="number">1</span>,<span class="string">&#x27;丑&#x27;</span>: <span class="number">2</span>,<span class="string">&#x27;寅&#x27;</span>: <span class="number">3</span>,<span class="string">&#x27;卯&#x27;</span>: <span class="number">4</span>,<span class="string">&#x27;辰&#x27;</span>: <span class="number">5</span>,<span class="string">&#x27;巳&#x27;</span>: <span class="number">6</span>,<span class="string">&#x27;午&#x27;</span>: <span class="number">7</span>,<span class="string">&#x27;未&#x27;</span>: <span class="number">8</span>,<span class="string">&#x27;申&#x27;</span>: <span class="number">9</span>,<span class="string">&#x27;酉&#x27;</span>: <span class="number">10</span>,<span class="string">&#x27;戌&#x27;</span>: <span class="number">11</span>,<span class="string">&#x27;亥&#x27;</span>: <span class="number">12</span>&#125; <span class="comment">#创建时辰字典</span></span><br><span class="line">dict2=&#123;<span class="string">&#x27;木&#x27;</span>:<span class="number">6</span>,<span class="string">&#x27;火&#x27;</span>:<span class="number">7</span>,<span class="string">&#x27;金&#x27;</span>:<span class="number">8</span>,<span class="string">&#x27;水&#x27;</span>:<span class="number">9</span>,<span class="string">&#x27;土&#x27;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#无限循环</span></span><br><span class="line">   <span class="keyword">try</span>: <span class="comment">#尝试运行可能出错的代码</span></span><br><span class="line">      time=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;以24时制输入当地当前时:&quot;</span>)) <span class="comment">#获取时间  </span></span><br><span class="line">   <span class="keyword">except</span> (ValueError, TypeError): <span class="comment">#数值错误和数值类型错误时的处理</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;错误,输入数字有误,例:当前13:11,则输入13&quot;</span>)</span><br><span class="line">      <span class="keyword">continue</span> <span class="comment">#跳过下面的循环，防止因为上面错误导致time没有获取数值而使下面的判断报错</span></span><br><span class="line">   <span class="keyword">if</span> time <span class="keyword">in</span> list10: <span class="comment">#判断输入数字是否为0~23</span></span><br><span class="line">      <span class="keyword">break</span> <span class="comment">#正常则执行下面的代码</span></span><br><span class="line">   <span class="keyword">else</span>: <span class="comment">#不符合则提示并循环</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;错误,输入数字有误,例:当前13:11,则输入13&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入心中立即想到的任意大小的正整数&quot;</span>)</span><br><span class="line">numbers1 = [<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]  <span class="comment"># 用列表存储 x, y, z</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment"># 循环三次以获取三个数字</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#无限循环</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            numbers1[i] = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">f&quot;请输入第 <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> 个数字: &quot;</span>)) <span class="comment">#使用f语句</span></span><br><span class="line">            <span class="keyword">if</span> numbers1[i] &lt;= <span class="number">0</span>:  <span class="comment"># 检查输入的数字是否为正整数</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;输入数字有误，请输入正负整数&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 如果输入有效，则退出当前的 while 循环</span></span><br><span class="line">        <span class="keyword">except</span> (ValueError,TypeError):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入数字有误，请输入正负整数&quot;</span>)</span><br><span class="line">x, y, z = numbers1 <span class="comment"># 将输入的数字赋值给 x, y, z</span></span><br><span class="line">time1 = list1[time] <span class="comment">#将时间对应时辰</span></span><br><span class="line">time2 = dict1.get(time1,<span class="string">&#x27;无效值&#x27;</span>) <span class="comment">#调用字典将时辰与数字对应，time1上不用加&#x27;&#x27;</span></span><br><span class="line">time3 = time2%<span class="number">6</span> <span class="comment">#对time2取余数，可知龙头宫位</span></span><br><span class="line">whole = <span class="number">6</span>-time3 <span class="comment">#得出青龙后还有几个元素作为整体</span></span><br><span class="line">element=list11[:whole+<span class="number">1</span>] <span class="comment">#将青龙以及后面的元素作为整体</span></span><br><span class="line">x1,y1,z1= (x-<span class="number">1</span>)%<span class="number">6</span>,(x+y-<span class="number">2</span>)%<span class="number">6</span>,(x+y+z-<span class="number">3</span>)%<span class="number">6</span> <span class="comment">#分别取余数</span></span><br><span class="line">x2,y2,z2 = list2[x1],list2[y1],list2[z1] <span class="comment">#分别给三才赋值六宫</span></span><br><span class="line">x3,y3,z3 = list3[x1],list3[y1],list3[z1] <span class="comment">#分别给三才赋值五行</span></span><br><span class="line">x4,y4,z4 = list4[x1],list4[y1],list4[z1] <span class="comment">#分别给三才赋值方位</span></span><br><span class="line"><span class="keyword">if</span> time3 == <span class="number">1</span>:</span><br><span class="line">   list12=list11</span><br><span class="line"><span class="keyword">elif</span> time3 == <span class="number">0</span>:</span><br><span class="line">   list12=[<span class="string">&#x27;朱雀&#x27;</span>,<span class="string">&#x27;勾陈&#x27;</span>,<span class="string">&#x27;白虎&#x27;</span>,<span class="string">&#x27;玄武&#x27;</span>,<span class="string">&#x27;腾蛇&#x27;</span>,<span class="string">&#x27;青龙&#x27;</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   list12=[x <span class="keyword">for</span> x <span class="keyword">in</span> list11 <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> element]+element <span class="comment">#先遍历列表8不属于整体的元素再加上整体中的元素生成新列表10</span></span><br><span class="line">x5,y5,z5 = list5[x1],list5[y1],list5[z1] <span class="comment">#分别给三才赋值六神</span></span><br><span class="line">x6,y6,z6 = list12[x1],list12[y1],list12[z1] <span class="comment">#分别给三才赋值活六神</span></span><br><span class="line">number1,number2,number3 = dict2.get(x3),dict2.get(y3),dict2.get(z3) <span class="comment">#调用字典将五行与列表数字对应</span></span><br><span class="line">list13,list14,list15=<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number1&#125;</span>&#x27;</span>],<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number2&#125;</span>&#x27;</span>],<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number3&#125;</span>&#x27;</span>] <span class="comment">#使用globals()作用于全局区别于locals()只能在一个函数局部内返回变量，生成三才对应的十二长生列表</span></span><br><span class="line">x7,y7,z7 =list13[time2-<span class="number">1</span>],list14[time2-<span class="number">1</span>],list15[time2-<span class="number">1</span>]</span><br><span class="line">time_len = <span class="built_in">len</span>(<span class="built_in">str</span>(time))</span><br><span class="line"><span class="keyword">if</span> time_len == <span class="number">1</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;时间&#x27;</span>,<span class="string">&#x27;&#x27;</span>,time,<span class="string">&#x27;  &#x27;</span>,time1)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;时间&#x27;</span>,<span class="string">&#x27;&#x27;</span>,time,<span class="string">&#x27; &#x27;</span>,time1)</span><br><span class="line"><span class="built_in">print</span>(x2,y2,z2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>,x3,<span class="string">&#x27; &#x27;</span>,y3,<span class="string">&#x27; &#x27;</span>,z3)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_xyz</span>(<span class="params">x,y,z</span>): <span class="comment">#封装成函数</span></span><br><span class="line">   x_len,y_len,z_len = <span class="built_in">len</span>(x),<span class="built_in">len</span>(y),<span class="built_in">len</span>(z)</span><br><span class="line">   <span class="keyword">if</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27; &#x27;</span>, y, <span class="string">&#x27; &#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27; &#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27;&#x27;</span>, y, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27; &#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, y, z)</span><br><span class="line">print_xyz(x4,y4,z4) <span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">print</span>(x5,y5,z5)</span><br><span class="line"><span class="built_in">print</span>(x6,y6,z6)</span><br><span class="line">print_xyz(x7,y7,z7) <span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;按下Enter退出&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>术数</category>
      </categories>
      <tags>
        <tag>小六壬</tag>
        <tag>起课器</tag>
      </tags>
  </entry>
  <entry>
    <title>在butterfly主题添加一个副标题，并能够输出自定义的随机语录</title>
    <url>/2025/08/30/%E5%9C%A8butterfly%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%89%AF%E6%A0%87%E9%A2%98%EF%BC%8C%E5%B9%B6%E8%83%BD%E5%A4%9F%E8%BE%93%E5%87%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%AD%E5%BD%95/</url>
    <content><![CDATA[<h1>在butterfly主题添加一个副标题，并能够输出自定义的随机语录</h1>
<p>目前已经有许多在主题中接入一言来实现输出随机语录，但是对于自定义语录库的教程，暂未看到能够明了的讲清楚如何实现这一功能的</p>
<p>通过参考<a href="https://fanyiming.life/?p=128">Butterfly主题首页副标题自定义随机句子 – Eamon’s Blog</a>和deepseek完成了此功能</p>
<h2 id="注意在所有操作前都要确保备份"># 注意在所有操作前都要确保备份</h2>
<h2 id="1-创建语录库">1.创建语录库</h2>
<p>在博客的根目录下的source下(注意不是主题下的source)创建subtitle.json，在里面放句子</p>
<p>格式如下：</p>
<p>[“争知我，倚阑杆处，正恁凝愁！”,</p>
<p>“衣懒换，酒难赊。可怜此夕看梅花。”,</p>
<p>“为伊判作梦中人，索向画图清夜唤真真。”</p>
<p>]</p>
<h2 id="2-修改pug文件">2.修改pug文件</h2>
<p>在主题的文件夹下找到layout\includes\thrid-party\subtitle.pug</p>
<p>划到最下面会有一个case source开头的代码下面有多个when开头的分支和default开头的分支</p>
<p>将default及以下的代码替换为如下的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default</span><br><span class="line">  script.</span><br><span class="line">    // 获取默认内容作为后备</span><br><span class="line">    var defaultQuote = !&#123;JSON.stringify(subContent[0] || &#x27;&#x27;)&#125;;</span><br><span class="line">    // 页面加载完成后执行</span><br><span class="line">    document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123;</span><br><span class="line">      // 尝试从 subtitle.json 获取内容</span><br><span class="line">      fetch(&#x27;/subtitle.json&#x27;)</span><br><span class="line">        .then(response =&gt; &#123;</span><br><span class="line">          if (!response.ok) &#123;</span><br><span class="line">            throw new Error(&#x27;网络响应不正常&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          return response.json();</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(quotes =&gt; &#123;</span><br><span class="line">          // 确保 quotes 是数组且有内容</span><br><span class="line">          if (Array.isArray(quotes) &amp;&amp; quotes.length &gt; 0) &#123;</span><br><span class="line">            // 随机选择一条语录</span><br><span class="line">            var randomIndex = Math.floor(Math.random() * quotes.length);</span><br><span class="line">            displayQuote(quotes[randomIndex]);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // 如果 quotes 无效，使用默认内容</span><br><span class="line">            displayQuote(defaultQuote);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(error =&gt; &#123;</span><br><span class="line">          console.error(&#x27;加载自定义语录失败:&#x27;, error);</span><br><span class="line">          // 出错时使用默认内容</span><br><span class="line">          displayQuote(defaultQuote);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 显示语录的函数</span><br><span class="line">    function displayQuote(quote) &#123;</span><br><span class="line">      var subtitleElement = document.getElementById(&quot;subtitle&quot;);</span><br><span class="line">      if (subtitleElement) &#123;</span><br><span class="line">        subtitleElement.innerHTML = quote;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p># 注意，deepseek提示这段代码需要与上面的when语句对齐，至于没有对齐是否能完成此功能，未进行测试</p>
<h2 id="3-配置博客的配置文件">3.配置博客的配置文件</h2>
<p>在博客的根目录下打开_config.yml文件，查找</p>
<p>subtitle:<br>
enable: true</p>
<p>确保enable后的是true开启</p>
<h2 id="4-关于打字机效果">4.关于打字机效果</h2>
<p>在enable下面会有effect，后面也为true则为开启</p>
<p>但是实际实现中共没有能做到这个效果，在浏览器控制台中会有报错</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>副标题</tag>
        <tag>语录</tag>
      </tags>
  </entry>
  <entry>
    <title>CQB理论</title>
    <url>/2025/10/03/CQB%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="CQB理论">CQB理论</h2>
<h2 id="1-认识CQB">1.认识CQB</h2>
<h3 id="1-概述">1.概述</h3>
<ul>
<li>英文中<strong>close quarter battle</strong>的简写</li>
<li>即<strong>室内近距离</strong> 作战</li>
</ul>
<h3 id="2-特点">2.特点</h3>
<ul>
<li>由于和敌人是保持一个极近的距离，所以双方开火都能以很<strong>快</strong> ，很<strong>密集</strong> 的火力快速覆盖敌人
<ul>
<li>近距离</li>
<li>激烈性</li>
<li>短时性</li>
</ul>
</li>
<li>是特种作战</li>
<li>具有高度独立性</li>
</ul>
<p># 这里是CQB的特点，而不是CQB战术的特点</p>
<h3 id="3-驱动CQB的底层逻辑">3.驱动CQB的底层逻辑</h3>
<h4 id="1-具有十分明确的目的性">1.具有十分明确的目的性</h4>
<ul>
<li>
<p>其目的包括：</p>
<ul>
<li>
<p>解救人质</p>
</li>
<li>
<p>获取某些重要的情报</p>
</li>
<li>
<p>保证公共财产的安全</p>
</li>
</ul>
</li>
<li>
<p>这就解释了为什么CQB如此危险但仍然存在，没有被大规模的火力压制取代</p>
</li>
<li>
<p>所以CQB的本质上是一种<strong>限制性</strong> 战斗</p>
</li>
</ul>
<h4 id="2-严谨性">2.严谨性</h4>
<ul>
<li>在实际战斗中会面对各种各样的情况，对于各种威胁
<ul>
<li>要从实际的角度出发</li>
<li>站在客观的角度上分析问题和解决问题</li>
<li>因地制宜地去选择装备和战术</li>
<li>警惕教条主义和经验主义</li>
</ul>
</li>
</ul>
<h2 id="2-CQB战术">2.CQB战术</h2>
<ul>
<li>
<p>战术即战斗方法</p>
</li>
<li>
<p>CQB战术即是室内近距离战斗方法</p>
</li>
<li>
<p>CQB战术共有两个分类，即CQB战术的两大核心</p>
<ul>
<li><strong>迅猛</strong></li>
<li><strong>静默</strong></li>
</ul>
</li>
</ul>
<h3 id="1-特点">1.特点</h3>
<h4 id="1-隐蔽性">1.隐蔽性</h4>
<ul>
<li>例如：在敌人未知我方要进攻时
<ul>
<li>迅猛：
<ul>
<li>易引起敌方警觉</li>
</ul>
</li>
<li>静默：
<ul>
<li>不易被发现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-机动性（灵活性）">2.机动性（灵活性）</h4>
<ul>
<li>例如：在敌方已知我方要进攻时
<ul>
<li>静默：
<ul>
<li>移动缓慢，易被敌方集火</li>
</ul>
</li>
<li>迅猛：
<ul>
<li>可以使用火力压制，进行快速突入</li>
</ul>
</li>
</ul>
</li>
<li>但是这种情况的问题在于，敌人掌握我方行动。我方失去行动突然性。
<ul>
<li>突然性为<strong>硬性指标</strong></li>
<li>优秀的CQB战术是海浪式的进攻
<ul>
<li>在一波进攻结束后</li>
<li>队伍进入隐蔽状态，即重新获得突然性</li>
<li>再进行下一波的进攻</li>
</ul>
</li>
</ul>
</li>
<li>缺少了信息不对称的优势，属于巨大失误</li>
</ul>
<h4 id="3-时效性">3.时效性</h4>
<ul>
<li>例如：炸弹爆炸场景
<ul>
<li>迅猛：
<ul>
<li>易被敌方发现，导致炸弹提取爆炸</li>
</ul>
</li>
<li>静默：
<ul>
<li>不易被敌方发现，但行动缓慢，可能导致无法在爆炸前完成拆除任务</li>
</ul>
</li>
<li>两者相结合：
<ul>
<li>以静默靠近敌人，再以迅猛清除所有敌人</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-CQB流程">3.CQB流程</h2>
<h3 id="1-前期">1.前期</h3>
<ul>
<li>
<p>即获得任务并且已知任务目标</p>
</li>
<li>
<p>对任务有初步的了解</p>
</li>
<li>
<p>根据对目标的了解</p>
<ul>
<li>针对目标进行搜索信息
<ul>
<li>搜集到的信息在进一步的检索后，可能会获得潜在信息</li>
</ul>
</li>
</ul>
</li>
<li>
<p>例如：匪徒正在抢劫一个银行</p>
<ul>
<li>首先银行是一个公共场所</li>
<li>匪徒不可能对其长期占有，对其进行过非法改装的可能性较小</li>
<li>即银行建筑图可以被信任</li>
</ul>
</li>
</ul>
<h4 id="基础信息总汇">基础信息总汇</h4>
<ul>
<li>信息四要素</li>
</ul>
<h5 id="1-时间">1.时间</h5>
<ul>
<li>光照角度</li>
<li>照明情况</li>
<li>人流情况（早晚高峰）</li>
</ul>
<h5 id="2-地点">2.地点</h5>
<ul>
<li>改造情况</li>
<li>地图要求</li>
<li>战前规划</li>
</ul>
<h5 id="3-人物">3.人物</h5>
<ul>
<li>训练经验</li>
<li>武装情况</li>
</ul>
<h5 id="4-动机">4.动机</h5>
<ul>
<li>敌人的犯罪目标</li>
</ul>
<p># 可以有针对性的制定相应的交火规则以及开火规则限制</p>
<h3 id="2-中期">2.中期</h3>
<h4 id="1-瞄准">1.瞄准</h4>
<ul>
<li>在行动中严禁瞄准敌人头部（除非敌人挟持人质）</li>
<li>只能瞄准胸口
<ul>
<li>问题：
<ul>
<li>射击精度不够，无法一击毙命</li>
<li>瞄准头部会导致手臂下的部分视野缺失</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-死亡漏斗">2.死亡漏斗</h4>
<ul>
<li>
<p>在门前后150度左右的扇形区域</p>
</li>
<li>
<p>进攻方在漏斗里面会暴露自己的身体位置和信息的</p>
</li>
<li>
<p>因此会有三点要求</p>
<ul>
<li>在进门之前尽量减少身体在漏斗区域的暴露</li>
<li>进门的时候<strong>不可以在门口逗留</strong></li>
<li>不要随便越过漏斗，如果要越过漏斗，必须枪指着漏斗越过</li>
</ul>
<p># 在非必要情况下，一般不会经常越过漏斗</p>
</li>
</ul>
<h4 id="3-强弱原则">3.强弱原则</h4>
<h5 id="1-强弱手">1.强弱手</h5>
<ul>
<li>
<p>队员对于自己的控制</p>
</li>
<li>
<p>利手则为强手</p>
</li>
</ul>
<h5 id="2-强弱手位">2.强弱手位</h5>
<ul>
<li>
<p>整个队伍对于进攻的状态</p>
</li>
<li>
<p>利于进攻的位置即为强手位</p>
</li>
<li>
<p><strong>判断强弱手位原则</strong> ：</p>
<ul>
<li>
<p>第一原则：</p>
<ul>
<li>
<p>视野原则：</p>
<ul>
<li>具有<strong>更大视野</strong> 的为强手位</li>
</ul>
<p># 这个原则可以解决大部分的强弱手位判断，有极强的适用性</p>
</li>
</ul>
</li>
<li>
<p>第二原则：</p>
<ul>
<li>视角原则：
<ul>
<li>进攻动作让枪械在更小的范围内更精确的锁定敌人</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第三原则：</p>
<ul>
<li>
<p>外开原则：</p>
<ul>
<li>即门是向外开的，那么开门的人就是弱手位</li>
</ul>
<p># 但如果门可以打开至完全和墙贴合，那么可以视为没有门</p>
</li>
</ul>
</li>
</ul>
<p># 这些原则都是建立在没有使用任何战术道具的前提上，如果涉及到就要重新分配位置</p>
</li>
<li>
<p><strong>单开门双纵队交叉进门区分强弱手位及具体站位</strong></p>
</li>
<li>
<p>强手位先进门，弱手位后进门</p>
<ul>
<li>
<p>单开门：</p>
<ul>
<li>
<p>门轴处为<strong>强手位</strong></p>
<ul>
<li>在门外列队时，最外侧的脚不可以超过门轴，保证大部分身体有掩体</li>
<li>离墙半个身位的距离
<ul>
<li>防止敌人穿射</li>
<li>防止单片弹射</li>
</ul>
</li>
<li>斜45度架设门内区域</li>
<li>完成和门有关的一切动作</li>
<li>在开小门后
<ul>
<li>先观察门后是否安全</li>
<li>查看是否有绊线，选择强手位或弱手位拆除
<ul>
<li>弱手位拆绊线，可以保证身体大部分处于掩体，但需要强手位提示绊线位置</li>
<li>强手位拆绊线则需要，让队友架设强手位的前方</li>
</ul>
</li>
</ul>
</li>
<li>等待弱手位信号，再大开门</li>
<li>放弃45度架设位，回退至安全角</li>
<li>再从安全角慢切至90度</li>
<li>确认安全后，再回到45度架设，进行决策</li>
<li>准备进攻前先抬头示意队友并等待队友抬头回应同意</li>
<li>按照强手先出的顺序收枪移动进门</li>
</ul>
<p># 一定要先收枪再进门</p>
<ul>
<li>直线进门</li>
</ul>
</li>
<li>
<p>门把手位为<strong>弱手位</strong></p>
<ul>
<li>只负责架设，和拆除绊线</li>
<li>完成开小门和拆除绊线后
<ul>
<li>弱手位抬头给出信号，示意强手位打开门
<ul>
<li>即弱手位来协同开门时间</li>
</ul>
</li>
</ul>
</li>
<li>放弃45度架设位，回退至安全角</li>
<li>再从安全角慢切至90度</li>
<li>确认安全后，再回到45度架设，进行决策</li>
<li>准备进攻前先抬头示意队友并等待队友抬头回应同意</li>
<li>按照弱手后出的顺序收枪移动进门</li>
</ul>
<p># 一定要先收枪再进门</p>
<ul>
<li>直线进门</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p># 在开门后，如果弱手位获取到了任何不安全的信息，那么弱手位就变成强手位</p>
<p><strong>单开门单纵队交替进入</strong></p>
<ul>
<li>
<p>适用于两侧队员都在门的一侧就位</p>
</li>
<li>
<p>或门的两侧任意一侧没有位置站</p>
</li>
<li>
<p>在第一个的尖兵：</p>
<ul>
<li>先开小门确认门后安全</li>
<li>检察绊线</li>
<li>大开门</li>
<li>观察45度后立马再观察90</li>
<li>全都安全后收枪</li>
<li>然后往左侧或右侧钩进门，向观察过的位置的另一侧（即危险区域）</li>
</ul>
</li>
<li>
<p>二号位：</p>
<ul>
<li>在尖兵钩进门之后，立马跟进</li>
<li>观察门后以及尖兵后</li>
</ul>
</li>
</ul>
<p><strong>双开门双纵队双勾进入</strong></p>
<ul>
<li>适用于能够容纳两个人同时进入的门的区域</li>
<li>这种情况就不区分强弱手位</li>
<li>门大开后左侧队员钩左，右侧队员钩右</li>
<li>两侧先45度架设门内</li>
<li>由左侧队员控门
<ul>
<li>先开自己一侧的门</li>
<li>观察是否有敌人</li>
<li>再将门切换到对侧
<ul>
<li>由右侧观察是否有敌人</li>
</ul>
</li>
<li>等待队员抬头示意</li>
<li>大开门</li>
<li>由45度顺着门大开的方向转到90度观察</li>
<li>做决策进门</li>
</ul>
</li>
<li>右侧队员等待左侧队员开门
<ul>
<li>门切换至右侧时观察门后情况</li>
<li>抬头示意</li>
<li>等待门大开后由45度顺着门大开的方向转到90度观察</li>
<li>做决策进门</li>
</ul>
</li>
</ul>
<h4 id="4-责任区间">4.责任区间</h4>
<ul>
<li>
<p>为了以最快的速度全面控制和警戒</p>
</li>
<li>
<p>责任区间不能重叠</p>
</li>
<li>
<p>如果在移动后可能会导致越过队友枪线</p>
</li>
<li>
<p>则需要更改责任区间</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CQB</category>
      </categories>
      <tags>
        <tag>CQB</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2025/10/07/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>Java基础</h1>
<h2 id="1-基础概念">1.基础概念</h2>
<h3 id="1-注释">1.注释</h3>
<h4 id="1-单行注释">1.单行注释</h4>
<ul>
<li>//注释</li>
</ul>
<h4 id="2-多行注释">2.多行注释</h4>
<ul>
<li>/*注释*/</li>
</ul>
<h4 id="3-文档注释">3.文档注释</h4>
<ul>
<li>/**注释*/</li>
</ul>
<h3 id="2-关键字">2.关键字</h3>
<h4 id="1-关键字特点">1.关键字特点</h4>
<ul>
<li>关键字的字母全部<strong>小写</strong></li>
</ul>
<h4 id="2-class">2.class</h4>
<ul>
<li>用于<strong>创建/定义</strong> 一个类
<ul>
<li>类是Java最基本的<strong>组成单元</strong></li>
</ul>
</li>
</ul>
<h3 id="3-字面量">3.字面量</h3>
<table>
<thead>
<tr>
<th>字面量类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数类型</td>
<td>不带小数点的数字</td>
</tr>
<tr>
<td>小数类型</td>
<td>带小数点的数字</td>
</tr>
<tr>
<td>字符串类型</td>
<td>用双引号括起来的内容（即使没有内容）</td>
</tr>
<tr>
<td>字符类型</td>
<td>用单引号括起来的，且内容只能有一个</td>
</tr>
<tr>
<td>布尔类型</td>
<td>布尔值：true/false，表示真假</td>
</tr>
<tr>
<td>空类型</td>
<td>一个特殊的值：null，空值，需要用字符串的形式打印出来，不能直接打印</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>特殊字面量</p>
</li>
<li>
<p>\t 制表符</p>
<ul>
<li>打印的时候，会把前面的字符串的长度去补齐到8，或者是8的整数倍，最少补一个空格，最多补8个空格</li>
<li>在两个字符串中间**+‘\t’+**，可以使中间补齐</li>
</ul>
</li>
</ul>
<h3 id="4-变量">4.变量</h3>
<ul>
<li>在程序执行过程中，其值有可能发生<strong>改变</strong> 的量（数据）</li>
</ul>
<h4 id="基本用法">基本用法</h4>
<h5 id="1-使用场景">1.使用场景</h5>
<ul>
<li>当某个数据经常发生改变时，可以用变量存储，当数据变化时，只要修改变量里面记录的值即可</li>
</ul>
<h5 id="2-定义格式">2.定义格式</h5>
<ul>
<li><strong>数据类型 变量名=数据值；</strong></li>
</ul>
<h5 id="3-使用方式">3.使用方式</h5>
<ul>
<li>
<p>输出打印</p>
</li>
<li>
<p>参与计算</p>
</li>
<li>
<p>修改记录的值</p>
</li>
</ul>
<h5 id="4-注意事项">4.注意事项</h5>
<ul>
<li>只能存一个值</li>
<li>变量名不允许重复定义</li>
<li>一条语句可以定义多个变量</li>
<li>变量在使用之前一定要进行赋值</li>
<li>变量的作用域范围</li>
<li>使用前必须赋值</li>
</ul>
<h3 id="5-计算机中的数据存储">5.计算机中的数据存储</h3>
<ul>
<li>任意数据都是以二进制的形式来存储的</li>
</ul>
<h4 id="1-文本数据">1.文本数据</h4>
<h5 id="1-常见进制">1.常见进制</h5>
<ul>
<li>二进制（bin）：由0和1组成，Java中以0b开头，如果用了0b开头，后面的数字中又有0和以外的数字则报错</li>
<li>十进制（oct）：由0-9组成，不加前缀</li>
<li>八进制（dec）：由0-7组成，以0开头</li>
<li>十六进制（hex）：由0-9和a-f组成，以0x开头</li>
</ul>
<p># 在jdk7后加前缀</p>
<h5 id="2-任意进制转为十进制">2.任意进制转为十进制</h5>
<ul>
<li><strong>每个系数*基数的权次幂 相加</strong>
<ul>
<li>系数：每一位上的数</li>
<li>基数：当前进制数</li>
<li>权：从右向左，依次为0，1，2，3，……</li>
</ul>
</li>
</ul>
<h5 id="3-十进制转为其他进制">3.十进制转为其他进制</h5>
<ul>
<li><strong>除基取余法</strong>：不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来</li>
</ul>
<h5 id="4-ASCII表">4.ASCII表</h5>
<ul>
<li>用7位二进制数字对应字母和符号</li>
<li>可以将字母转化为二进制存储</li>
</ul>
<h5 id="5-编码">5.编码</h5>
<h6 id="1-GB2312编码">1.GB2312编码</h6>
<ul>
<li>简体中文</li>
</ul>
<h6 id="2-BIG5编码">2.BIG5编码</h6>
<ul>
<li>繁体中文</li>
</ul>
<h6 id="3-GBK编码">3.GBK编码</h6>
<ul>
<li>收录汉字，包含国家标准GB13000-1中的全部中日韩汉字，和BIG5编码中的所有汉字</li>
<li>计算机默认编码</li>
</ul>
<h6 id="4-Unicode编码">4.Unicode编码</h6>
<ul>
<li>国际标准字符集，将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言，跨平台的文本信息转化</li>
</ul>
<h4 id="2-图片数据">2.图片数据</h4>
<h5 id="1-黑白图">1.黑白图</h5>
<ul>
<li>每个像素点，0为黑，1为白</li>
</ul>
<h5 id="2-灰度图">2.灰度图</h5>
<ul>
<li>每个像素点，0为黑，255为白，中间数字为不同程度的灰</li>
</ul>
<h5 id="3-彩色图">3.彩色图</h5>
<ul>
<li>
<p>由光学三原色（红绿蓝，rgb）作为一个整体来作为一个像素点，可以通过设置一个像素点中的三原色的深浅来调整颜色</p>
</li>
<li>
<p>每个原色的取值范围都是0-255</p>
</li>
<li>
<p>可以写成十进制（255，120，156）</p>
</li>
<li>
<p>也可以写成十六进制</p>
</li>
</ul>
<h4 id="3-声音数据">3.声音数据</h4>
<ul>
<li>对声波采样，形成波形图，波形图中的每个点会数字对应，采样的点多则还原度高（无损），采样点少则还原度低（全损）</li>
</ul>
<h3 id="6-数据类型">6.数据类型</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>byte</td>
<td>-128~127</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>-32768~32767</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>int</td>
<td>十位数</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>十九位数</td>
<td>8</td>
</tr>
<tr>
<td>浮点数</td>
<td>float</td>
<td>-3.401298e-38~3.402823e+38</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>-4.9000000e-324~1.797693e+308</td>
<td>8</td>
</tr>
<tr>
<td>字符</td>
<td>char</td>
<td>0~65535</td>
<td>2</td>
</tr>
<tr>
<td>布尔</td>
<td>boolean</td>
<td>true,false</td>
<td>1</td>
</tr>
</tbody>
</table>
<p># 定义<strong>long类型</strong> 的变量，在数字的后面要<strong>加一个L作为后缀</strong></p>
<p># 同理<strong>float类型</strong> 的变量。数字后<strong>加F作为后缀</strong></p>
<h3 id="7-标识符">7.标识符</h3>
<ul>
<li>标识符：给类，方法，变量等起的名字</li>
</ul>
<h4 id="标识符命名规则">标识符命名规则</h4>
<h5 id="1-硬性要求">1.硬性要求</h5>
<ul>
<li>由数字，字母，下划线，美元符号组成</li>
<li>不能以数字开头</li>
<li>不能是关键字</li>
<li>区分大小写</li>
</ul>
<h5 id="2-软性建议">2.软性建议</h5>
<ul>
<li>
<p>小驼峰命名法（适合方法和变量）</p>
<ul>
<li>
<p>标识符是<strong>一个单词</strong> 的时候，<strong>全部小写</strong>：name</p>
</li>
<li>
<p>标识符由<strong>多个单词</strong> 组成时，<strong>第一个单词的首字母小写</strong>，<strong>其他单词首字母大写</strong>：firstName</p>
</li>
</ul>
</li>
<li>
<p>大驼峰命名法（适合类名）</p>
<ul>
<li>标识符是<strong>一个单词</strong> 的时候，<strong>首字母大写</strong>：Student</li>
<li>标识符由<strong>多个单词</strong> 组成的时候，<strong>每个单词的首字母大写</strong>：GoodStudent</li>
</ul>
</li>
</ul>
<h3 id="8-键盘录入">8.键盘录入</h3>
<h4 id="1-概述">1.概述</h4>
<ul>
<li>java中有一个写好的类叫Scanner，可以接收键盘输入的数据</li>
<li>步骤：
<ul>
<li>导包：在java.util.Scanner这个包</li>
<li>创建对象</li>
<li>接收数据</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">//导包要写在类定义的上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//创建对象，这里只有变量名可以改变</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>sc.nextInt(); <span class="comment">//接收整数类型的数据</span></span><br><span class="line">        System.out.println(i); <span class="comment">//输出数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 两个变量都要接收数据，就要写两遍接收数据的一行，不能在同一行两个变量接收数据</p>
<p># Java中没有提供直接接收字符数据的方法，要先接收字符串数据，再进行转化，用charAct()来获取输入的字符串中的某个字符</p>
<h3 id="9-IDEA">9.IDEA</h3>
<h4 id="1-概述-2">1.概述</h4>
<ul>
<li>结构
<ul>
<li>项目
<ul>
<li>模块
<ul>
<li>包
<ul>
<li>类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-快捷键">2.快捷键</h4>
<ul>
<li>ctrl+alt+L，自动格式代码</li>
<li>ctrl+alt+M，自动抽取方法</li>
<li>alt+insert/alt+Fn+insert，生成构造方法，可以用shift多选</li>
</ul>
<p># PTG插件也可以更快速的实现</p>
<ul>
<li>ctrl+alt+v，快速在调用的方法前生成一个对应数据类型以及变量来接收</li>
</ul>
<p># 例如：sc.nextDouble()，ctrl+alt+v，则生成double v = sc.nextDouble();</p>
<ul>
<li>
<p>ctrl+b，查看源码</p>
</li>
<li>
<p>选中一段代码后ctrl+alt+t，选择被哪种代码包裹，如for，if，while等</p>
</li>
<li>
<p>shift+alt+方向键，将代码移动</p>
</li>
<li>
<p>对报错的地方alt+enter会给出解决方法</p>
</li>
<li>
<p>选中后ctrl+shift+u，全部大写/小写</p>
</li>
</ul>
<h4 id="3-快捷功能">3.快捷功能</h4>
<ul>
<li>
<p>psvm</p>
<ul>
<li>快速生成main方法</li>
</ul>
</li>
<li>
<p>鼠标滚轮/alt</p>
<ul>
<li>竖列选中</li>
</ul>
</li>
<li>
<p>fori</p>
<ul>
<li>快速生成一个for循环其中变量为i</li>
<li>如果在fori前加上数字.则会生成i&lt;这个数字的循环</li>
</ul>
</li>
<li>
<p>数组名.fori</p>
<ul>
<li>快速生成数组的遍历</li>
</ul>
</li>
<li>
<p>集合名.fori</p>
<ul>
<li>快速生成集合的遍历</li>
</ul>
</li>
</ul>
<h2 id="2-运算符">2.运算符</h2>
<ul>
<li>运算符：对字面量或者变量进行操作的符号</li>
<li>表达式：用运算符把字面量或者变量连接起来，<strong>符合java语法</strong> 的句子</li>
</ul>
<h3 id="1-算术运算符">1.算术运算符</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
</tr>
<tr>
<td>%</td>
<td>取模：取余数</td>
</tr>
</tbody>
</table>
<p># 如果有小数参与运算，则结果不一定准确</p>
<p># 如果都是整数参与运算，结果为整数</p>
<h4 id="1-数字相加">1.数字相加</h4>
<h5 id="类型转换">类型转换</h5>
<h6 id="1-隐式转换（自动类型提升）（默认）">1.隐式转换（自动类型提升）（默认）</h6>
<ul>
<li>
<p>把一个取值范围小的数值，转成取值范围大的数据，再进行计算</p>
</li>
<li>
<p>byte，short，char三种类型，在运算时，都会先提升为int再进行运算</p>
</li>
</ul>
<h6 id="2-强制转换">2.强制转换</h6>
<ul>
<li>把一个取值范围大的数值，赋值给取值范围小的变量</li>
<li><strong>目标数据类型 变量名=（目标数据类型）被强转的数据</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> a=<span class="number">12.3</span>;</span><br><span class="line"><span class="type">int</span> b=(<span class="type">int</span>)a;</span><br></pre></td></tr></table></figure>
<p># 可能会发生数据错误，可以用<strong>补码</strong> 来解释为什么会出错，以及会转为什么数据</p>
<p># 如果要强转的是变量相加，需要把变量相加<strong>加括号</strong></p>
<h4 id="2-字符串相加">2.字符串相加</h4>
<ul>
<li>当相加操作中出现字符串时，+就是字符串连接符，会将前后的数据进行拼接，产生一个新的字符串</li>
<li><strong>连续进行相加操作时</strong>，<strong>从左到右逐个执行</strong></li>
<li>例如1+2+“人”，从左到右，先1+2没有字符串出现，则进行计算=3，3再余后面的&quot;人&quot;进行拼接，得到3人</li>
</ul>
<h4 id="3-字符相加">3.字符相加</h4>
<ul>
<li>字符加字符/数字时，会先从ASCII中查询相应字符对应的数字，再进行计算</li>
</ul>
<h3 id="2-自增自减运算符">2.自增自减运算符</h3>
<h4 id="1-自增">1.自增</h4>
<ul>
<li>++，变量的值加1</li>
</ul>
<p># 既可以写在变量前，也可以写在变量后</p>
<h4 id="2-自减">2.自减</h4>
<ul>
<li>–，变量的值减1</li>
</ul>
<p># 既可以写在变量前，也可以写在变量后</p>
<h4 id="3-参与计算">3.参与计算</h4>
<ul>
<li>写在变量后，则先用后增/减</li>
<li>写在变量后，则先增/减后用</li>
</ul>
<h3 id="3-赋值运算符">3.赋值运算符</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值</td>
</tr>
<tr>
<td>+=</td>
<td>加后赋值</td>
</tr>
<tr>
<td>-=</td>
<td>减后赋值</td>
</tr>
<tr>
<td>*=</td>
<td>乘后赋值</td>
</tr>
<tr>
<td>/=</td>
<td>除后赋值</td>
</tr>
<tr>
<td>%=</td>
<td>取余后赋值（是两个整数相除的余数）</td>
</tr>
</tbody>
</table>
<p># 除了=，其他都会进行强制转换，转换为前面的变量的类型</p>
<h3 id="4-关系运算符（比较运算符）">4.关系运算符（比较运算符）</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>判断两个变量是否相等，成立为true，否则false</td>
</tr>
<tr>
<td>!=</td>
<td>判断是否不等</td>
</tr>
<tr>
<td>&gt;</td>
<td>判断是否大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>判断是否大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>判断是否小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>判断是否小于等于</td>
</tr>
</tbody>
</table>
<p># 结果都是boolean类型，只有true和false</p>
<h3 id="5-逻辑运算符">5.逻辑运算符</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>逻辑与（且）</td>
<td>并且，两边都为真，结果才为真，1为true，0为false</td>
</tr>
<tr>
<td>|</td>
<td>逻辑或</td>
<td>或者，两边都为假，结果才是假，1为true，0为false</td>
</tr>
<tr>
<td>^</td>
<td>逻辑异或</td>
<td>相同为false，不同为true</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非</td>
<td>取反，真值取反就是假值</td>
</tr>
</tbody>
</table>
<p># &amp;和|可以用<strong>补码</strong> 来解释</p>
<ul>
<li>短路逻辑运算符</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>短路与</td>
<td>结果和&amp;相同，但是有短路效果</td>
</tr>
<tr>
<td>||</td>
<td>短路或</td>
<td>结果和|相同，但是有短路效果</td>
</tr>
</tbody>
</table>
<p># 如果<strong>左边能确定整个表达式的结果</strong>，则右边不执行</p>
<h3 id="6-三元运算符">6.三元运算符</h3>
<ul>
<li>
<p><strong>关系表达式?表达式1:表达式2;</strong></p>
</li>
<li>
<p>先计算关系表达式，如果结果为真，则执行表达式1，为假则执行表达式2</p>
</li>
</ul>
<p># 三元运算符的结果<strong>必须要被使用</strong></p>
<h3 id="7-运算符优先级">7.运算符优先级</h3>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>. () {}</td>
</tr>
<tr>
<td>2</td>
<td>!、~、++、–</td>
</tr>
<tr>
<td>3</td>
<td>*、/、%</td>
</tr>
<tr>
<td>4</td>
<td>+、-</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td>
</tr>
<tr>
<td>6</td>
<td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
</tr>
<tr>
<td>7</td>
<td>==、!=</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
</tr>
<tr>
<td>13</td>
<td>?  :</td>
</tr>
<tr>
<td>14</td>
<td>=、+=、-=、*=、/=、%=、&amp;=</td>
</tr>
</tbody>
</table>
<p># &lt;&lt;左移，补码向左移动，右边就会空出，在这个低位补0，同理右移高位正数补0负数1</p>
<p># &gt;&gt;&gt;无符号右移，向右移动，高位补0</p>
<h3 id="8-原码，反码，补码">8.原码，反码，补码</h3>
<h4 id="1-原码">1.原码</h4>
<ul>
<li>十进制数据的二进制表现形式，最左边是符号位，0为正，1为负</li>
<li>八个bit为一个字节</li>
<li>最大值：01111111=127</li>
<li>最小值：11111111=-127</li>
</ul>
<h5 id="1-原码的计算">1.原码的计算</h5>
<ul>
<li>二进制的计算方式，加1，则直接在末位加1，满二进一</li>
</ul>
<h5 id="2-原码的弊端">2.原码的弊端</h5>
<ul>
<li>用原码对正数进行计算是不会有问题的</li>
<li>但如果是负数计算，结果就出错，实际运算的结果与预期的结果是相反的</li>
</ul>
<h4 id="2-反码">2.反码</h4>
<ul>
<li>为了解决<strong>原码不能计算负数</strong> 的问题而出现的</li>
</ul>
<h5 id="1-反码的计算">1.反码的计算</h5>
<ul>
<li>
<p>正数的反码不变，负数的反码在原码的基础上，符号位不变，数字取反，0变1，1变0</p>
</li>
<li>
<p>如果加1，则在末位加1，满二进一，得到的就是加1后的反码</p>
</li>
</ul>
<h5 id="2-反码的弊端">2.反码的弊端</h5>
<ul>
<li>反码的11111111表示-0，如果再加1，则变为00000000=0</li>
<li>同样类似于-4的反码+7，跨0，会比正确结果小1</li>
</ul>
<p># 因为反码中的0有11111111和00000000两种表示方式</p>
<h4 id="3-补码">3.补码</h4>
<ul>
<li>
<p>在负数的反码的基础上加1，这样-0就是00000000，-1就是11111111，反码再依次向后，形成补码</p>
</li>
<li>
<p>-127就是10000001，-128就是10000000，-128只有补码，没有原码</p>
</li>
<li>
<p><strong>计算机中数字的存储计算都是以补码的形式来操作的</strong></p>
</li>
<li>
<p>所以<strong>一个字节</strong> 的范围就是**-128~127**</p>
</li>
</ul>
<h2 id="3-判断与循环">3.判断与循环</h2>
<h3 id="1-顺序结构">1.顺序结构</h3>
<ul>
<li>java程序默认的执行流程，按照代码的先后顺序，从上到下依次执行</li>
</ul>
<h3 id="2-分支结构">2.分支结构</h3>
<h4 id="1-if语句">1.if语句</h4>
<h5 id="1-第一种格式">1.第一种格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算关系表达式的值</li>
<li>如果关系表达式的值为true就执行语句体</li>
<li>如果关系式的值为false就不执行语句体</li>
<li>继续执行后面的其他语句</li>
</ul>
</li>
</ul>
<p># 只有一条语句的时候可以省略，但是尽量不要省略，如定义并初始化一个变量的语句，写成一句，但是是两句，不加{}会报错</p>
<h5 id="2-第二种格式">2.第二种格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算关系表达式的值</li>
<li>如果关系表达式的值为true就执行语句1</li>
<li>如果关系表达式的值为false就执行语句2</li>
<li>继续执行后面的语句</li>
</ul>
</li>
</ul>
<h5 id="3-第三种格式">3.第三种格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式<span class="number">1</span>)&#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(关系表达式<span class="number">2</span>)&#123;</span><br><span class="line">	语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算关系表达式1的值</li>
<li>如果为true就执行语句体1；如果为false就计算关系表达式2的值</li>
<li>如果为true就执行语句体2；如果为false就计算关系表达式3的值</li>
<li>……</li>
<li>如果所有关系表达式结果都为false，就执行else后的语句</li>
</ul>
</li>
</ul>
<h4 id="2-switch语句">2.switch语句</h4>
<h5 id="1-格式">1.格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>;</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span>;</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句体;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算表达式的值</li>
<li>依次和case后面的值进行比较，如果有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束</li>
<li>如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后结束整个switch语句</li>
</ul>
</li>
</ul>
<p># case后面的值只能是字面量，<strong>不能写变量</strong></p>
<h5 id="2-case穿透">2.case穿透</h5>
<ul>
<li><strong>没有加break</strong>，正常有break就会结束整个switch，如果没有就会一直向下执行，直到有break或者}</li>
</ul>
<p># default也是特殊的case</p>
<ul>
<li>可以在case后面的多个语句重复的时候，利用case穿透</li>
</ul>
<p># 将前面case后面的语句删除，只保留最后一个重复的语句，这样就会一直穿透到最后一个重复语句，然后break</p>
<p># 同时可以将重复的语句的几个值都写在一个，case1，2，3，4，5</p>
<p># 同样也可以用下面的写法优化</p>
<h5 id="3-写法优化">3.写法优化</h5>
<ul>
<li>在jdk12以后</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span> -&gt;&#123;</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span> -&gt;&#123;</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">default</span> -&gt;&#123;</span><br><span class="line">		语句体;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 如果{}中只有一个语句，还能把{}省略，把case/default和语句体写在同一行</p>
<h3 id="3-循环结构">3.循环结构</h3>
<h4 id="1-for循环">1.for循环</h4>
<h5 id="1-格式-2">1.格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句;条件判断语句;条件控制语句)&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>执行初始化语句</li>
<li>执行条件判断语句，看其结果是true还是false
<ul>
<li>如果是false，循环结束</li>
<li>如果是true，执行循环体语句</li>
</ul>
</li>
<li>执行条件控制语句</li>
<li>回到第二步继续执行条件判断语句</li>
</ul>
</li>
</ul>
<h5 id="2-注意">2.注意</h5>
<ul>
<li>不要在循环语句中写定义赋值语句，然后在语句外使用，变量只在循环中有效</li>
<li>变量定义在循环中，变量只能在本次循环中有效</li>
</ul>
<h4 id="2-while循环">2.while循环</h4>
<h5 id="1-格式-3">1.格式</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line">while(条件判断语句)&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-和for循环的对比">2.和for循环的对比</h5>
<h6 id="1-相同点">1.相同点</h6>
<ul>
<li>运行规则是一样的</li>
</ul>
<h6 id="2-区别">2.区别</h6>
<ul>
<li>for循环中，控制循环的变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了
<ul>
<li>知道循环次数或者循环的范围</li>
</ul>
</li>
<li>while循环中，控制循环的变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用
<ul>
<li>不知道循环的次数和范围，只知道循环的结束条件</li>
</ul>
</li>
</ul>
<h4 id="3-do……while循环"><a href="http://3.do">3.do</a>……while循环</h4>
<h5 id="格式">格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句);</span><br></pre></td></tr></table></figure>
<ul>
<li>先执行后判断</li>
</ul>
<h4 id="4-无限循环">4.无限循环</h4>
<ul>
<li>for循环中不写条件</li>
<li>while/do……while循环中条件写true</li>
</ul>
<p># 无限循环下面就不能再写代码了，会报错无法达到的代码</p>
<h4 id="5-跳转控制语句">5.跳转控制语句</h4>
<ul>
<li>
<p>continue，用于结束<strong>本次循环</strong>，开始下一次循环</p>
</li>
<li>
<p>break，结束<strong>整个循环</strong></p>
</li>
</ul>
<h2 id="4-数组">4.数组</h2>
<h3 id="1-数组介绍">1.数组介绍</h3>
<ul>
<li>数组指的是一种容器，可以用来存储<strong>同种数据类型</strong> 的多个值</li>
</ul>
<p># 并不一定是完全一样的数组类型，要结合隐式转化</p>
<h3 id="2-数组的定义与静态初始化">2.数组的定义与静态初始化</h3>
<h4 id="1-定义">1.定义</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 数组名[];</span><br></pre></td></tr></table></figure>
<h4 id="2-静态初始化">2.静态初始化</h4>
<ul>
<li>
<p>初始化：在内存中，为数组开辟空间，并将数据存入容器中的过程</p>
</li>
<li>
<p>完整格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>简写格式</p>
</li>
<li>
<pre><code>数据类型[] 数组名 = &#123;元素&#125;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\# 初始化后长度不可变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.数组元素访问</span><br><span class="line"></span><br><span class="line">#### 1.数组的地址值</span><br><span class="line"></span><br><span class="line">* 直接打印数组名，会显示数组的地址值，而不是数组里面的元素</span><br><span class="line">* 地址值的格式</span><br><span class="line">  * [：表示当前是一个数组</span><br><span class="line">  * D，I：表示数组里面元素的类型</span><br><span class="line">  * @：间隔符号，固定格式</span><br><span class="line">  * 数字加字母：十六进制，真正的地址值</span><br><span class="line">  * 一般将这些统称为地址值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.索引</span><br><span class="line"></span><br><span class="line">* 索引：也称下标，角标</span><br><span class="line">* **从0开始**，逐个+1，连续不间断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4.数组遍历</span><br><span class="line"></span><br><span class="line">* 数组遍历：将数组中所有的内容取出</span><br><span class="line">* **遍历是指取出数据的过程**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 可以使用循环来遍历数组</span><br><span class="line"></span><br><span class="line">* 数组过长时为了获取数组的长度可以使用**length**</span><br><span class="line"></span><br><span class="line">* 调用方法：</span><br><span class="line"></span><br><span class="line">  * 数组名.length</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 5.数组动态初始化</span><br><span class="line"></span><br><span class="line">* 动态初始化：初始化时只指定数组的长度，由系统分配初始值</span><br><span class="line"></span><br><span class="line">* 格式</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">数据类型[] 数组名 = new 数据类型[数组长度]</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
<li>
<p>默认初始化值</p>
<ul>
<li>整数：0</li>
<li>小数：0.0</li>
<li>字符：/u0000，即空格</li>
<li>布尔：false</li>
<li>引用：null</li>
</ul>
</li>
</ul>
<h4 id="动态与静态的区别">动态与静态的区别</h4>
<ul>
<li>动态：手动指定数组长度，系统给出默认初始化值
<ul>
<li>只明确元素个数，不明确具体数组</li>
</ul>
</li>
<li>静态：手动指定数组元素，系统根据元素个数，计算出数组的长度
<ul>
<li>已经明确了要操作的具体数据，直接静态初始化</li>
</ul>
</li>
</ul>
<h3 id="6-数组内存图">6.数组内存图</h3>
<h4 id="1-内存分配">1.内存分配</h4>
<ul>
<li>
<p>JVM虚拟机，将其内存空间分为五个部分</p>
<ul>
<li>栈：方法运行时使用的空间，如main方法运行，进入方法栈中执行</li>
<li>堆：存储对象或者数组，new来创建的，都存储在堆内存</li>
<li>方法区：存储可以运行的class文件</li>
<li>本地方法栈：JVM在使用操作系统功能的时候使用</li>
<li>寄存器：给cpu使用</li>
</ul>
<p># jdk8后将方法区取消，改为元空间，原方法区的功能放在了堆和元空间中</p>
</li>
</ul>
<h4 id="2-数组的内存">2.数组的内存</h4>
<ul>
<li>main方法进入栈内存
<ul>
<li>定义数组进入栈内存</li>
<li>定义的同时new在堆内存中开辟空间</li>
<li>堆中的空间地址值赋值给栈内存中的数组
<ul>
<li>调用时，先通过栈内存中的数组变量的地址值，找到堆内存中的数据，再通过索引找到对应数据</li>
<li>赋值也同理，覆盖原来索引上的元素
<ul>
<li>创建第二个数组也同理，在堆内存中开辟一个新的独立空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-两个数组指向同一个空间">3.两个数组指向同一个空间</h4>
<ul>
<li>定义完第一个数组后，第二个数组定义并直接将第一个数组赋值给第二个数组，这时候就没有new</li>
<li>堆内存中是同一个空间，两个数组变量的地址值也是相同</li>
<li>修改任意一个数组中的数据，另一个数组也会被修改</li>
</ul>
<h3 id="7-数组常见问题">7.数组常见问题</h3>
<ul>
<li>索引越界异常：访问了数组中不存在的索引</li>
</ul>
<h3 id="8-数组常见操作">8.数组常见操作</h3>
<h4 id="1-求最值">1.求最值</h4>
<ul>
<li>先定义一个变量记录最值（变量初始化的值必须是数组中的一个值）
<ul>
<li>遍历数组获取每一个元素
<ul>
<li>让每一个元素和最值比较，比最值更大/更小，就让变量记录新的元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<p># 遍历输出可以使用print使其输出在同一行</p>
<h4 id="2-求和">2.求和</h4>
<ul>
<li>先定义一个求和变量
<ul>
<li>再循环得到每一个元素
<ul>
<li>加到变量中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-交换数据">3.交换数据</h4>
<ul>
<li>和两个变量交换数据一样
<ul>
<li>将两个索引的数据交换，需要一个空的变量</li>
</ul>
</li>
</ul>
<p># 可以使用循环实现数组首尾交换</p>
<h4 id="4-打乱数据">4.打乱数据</h4>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br></pre></td></tr></table></figure>
<p># 需要先导入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random 变量 = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>构造函数使用当前时间作为种子值</p>
<ul>
<li>
<pre><code class="language-java">变量.nextInt(整数)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    \# 这是Random类中的一个方法，可以返回一个0~整数（不包含）的一个随机数</span><br><span class="line"></span><br><span class="line">  * 再赋值给一个新的变量</span><br><span class="line"></span><br><span class="line">    * 循环遍历数组</span><br><span class="line">      * 从第一个元素开始，和随机数元素交换</span><br><span class="line">        * 获取随机数写在循环中，所以每次生成的随机数不同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5.方法</span><br><span class="line"></span><br><span class="line">### 1.方法的介绍</span><br><span class="line"></span><br><span class="line">#### 1.定义</span><br><span class="line"></span><br><span class="line">* **方法**（method）是程序当中**最小** 的执行单元</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.使用场景</span><br><span class="line"></span><br><span class="line">* 将重复的代码，具有独立功能的代码抽取到方法中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.方法的格式</span><br><span class="line"></span><br><span class="line">#### 1.最简单的</span><br><span class="line"></span><br><span class="line">##### 1.定义</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void 方法名()&#123;</span><br><span class="line">	方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="2-调用">2.调用</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名();</span><br></pre></td></tr></table></figure>
<h4 id="2-带参数的">2.带参数的</h4>
<h5 id="1-定义-2">1.定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名(参数<span class="number">1</span>,参数<span class="number">2</span>,……)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-调用-2">2.调用</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名(参数<span class="number">1</span>,参数<span class="number">2</span>,……)</span><br></pre></td></tr></table></figure>
<p># 参数个数必须和方法中的一样</p>
<h5 id="3-形参和实参">3.形参和实参</h5>
<ul>
<li>形参：形式参数，是指方法定义中的参数</li>
<li>实参：实际参数，方法调用中的参数</li>
</ul>
<h4 id="3-带返回值的">3.带返回值的</h4>
<h5 id="1-定义-3">1.定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 方法名(参数<span class="number">1</span>,参数<span class="number">2</span>,……)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>return表示<strong>结束方法</strong>，return后就不能再写了</li>
</ul>
<p># 返回类型[]表示返回一个此数据类型的数组</p>
<h5 id="2-调用-3">2.调用</h5>
<h6 id="1-直接调用">1.直接调用</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名(实参);</span><br></pre></td></tr></table></figure>
<h6 id="2-赋值调用">2.赋值调用</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名 = 方法名(实参);</span><br></pre></td></tr></table></figure>
<h6 id="3-输出调用">3.输出调用</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(方法名(实参));</span><br></pre></td></tr></table></figure>
<h3 id="3-方法的重载">3.方法的重载</h3>
<ul>
<li>在<strong>同一个类</strong> 中，定义了<strong>多个同名</strong> 的方法，这些同名的方法具有<strong>同种的功能</strong></li>
<li>每个方法具有不同的参数类型和参数个数，这些同名的方法，就构成了重载关系</li>
<li>参数不同
<ul>
<li>个数不同</li>
<li>类型不同</li>
<li>顺序不同：定义的形参的类型的顺序</li>
</ul>
</li>
</ul>
<p># Java虚拟机会通过参数的不同来区分同名的方法</p>
<h3 id="4-方法的内存">4.方法的内存</h3>
<h4 id="1-方法调用的基本内存原理">1.方法调用的基本内存原理</h4>
<ul>
<li>被调用则入栈，方法中调用了其他的方法则会再将其他的方法入栈，当栈顶的方法使用完后，出栈，再接着运行下面一个方法</li>
</ul>
<h4 id="2-方法传递基本数据类型的内存原理">2.方法传递基本数据类型的内存原理</h4>
<h5 id="基本数据类型">基本数据类型</h5>
<ul>
<li>
<p>变量中存储的是真实的数据</p>
</li>
<li>
<p>数据值是存储在自己的空间中</p>
</li>
<li>
<p>赋值给其他变量，也是赋的真实的值</p>
</li>
<li>
<p>传递基本数据类型时，传递的是真实的数据，形参的改变不会影响实际参数的值</p>
</li>
</ul>
<p># 例如先定义一个变量并赋值为1，再方法中将变量赋值为2，调用方法传入定义的变量，输出变量，此时显示的值仍为1</p>
<p>定义并赋值时，先入栈，然后调用的方法再入栈，给变量赋值为2，然后方法出栈，但是<strong>先入栈的变量并没有被修改值</strong>，所以再打印变量，输出的仍然是原来的值</p>
<p>要解决这个问题，可以在方法中返回修改后的变量，同时使用方法格式中的带返回值的格式中的赋值调用，再赋给一个新的变量，再将这个变量输出</p>
<h4 id="3-方法传递引用数据类型的内存原理">3.方法传递引用数据类型的内存原理</h4>
<h5 id="引用数据类型">引用数据类型</h5>
<ul>
<li>
<p>变量中存储的是地址值，即使用其他空间中的数据，自己空间中存储的是地址值</p>
</li>
<li>
<p>传递引用数据类型，传递的是地址值，形参的改变会影响到实际参数的值</p>
</li>
</ul>
<p># 和数组的内存相同</p>
<h2 id="6-面向对象">6.面向对象</h2>
<h3 id="1-设计对象并使用">1.设计对象并使用</h3>
<h4 id="1-类和对象">1.类和对象</h4>
<ul>
<li>类：是对象共同特征的描述</li>
<li>对象：是真实存在的东西</li>
</ul>
<p># java中必须先设计类，才能获得对象</p>
<h5 id="1-如何定义类">1.如何定义类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">	<span class="number">1.</span>成员变量（属性）</span><br><span class="line">    <span class="number">2.</span>成员方法（行为）</span><br><span class="line">    <span class="number">3.</span>构造器</span><br><span class="line">    <span class="number">4.</span>代码块</span><br><span class="line">    <span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-如何获得类的对象">2.如何获得类的对象</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>
<h5 id="3-如何使用对象">3.如何使用对象</h5>
<ul>
<li>访问属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.成员变量</span><br></pre></td></tr></table></figure>
<ul>
<li>访问行为</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.方法名(……)</span><br></pre></td></tr></table></figure>
<h4 id="2-类的补充">2.类的补充</h4>
<h5 id="1-定义类的补充事项">1.定义类的补充事项</h5>
<ul>
<li>
<p>用来描述一类事物的类，叫做：Jvavbean类</p>
</li>
<li>
<p>在Jvavbean类中，是不写main方法的</p>
</li>
<li>
<p>编写的main方法的类，叫做测试类</p>
</li>
<li>
<p>测试类中可以创建javabean类的对象并进行赋值调用</p>
</li>
<li>
<p>一个java文件中可以定义多个类，且只能有一个类是public修饰</p>
</li>
<li>
<p>public修饰的类名必须成为代码文件名</p>
</li>
</ul>
<p># 实际开放中一个文件定义一个class类</p>
<ul>
<li>成员变量的完整定义格式是</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 数据类型 变量名 = 初始化值;</span><br></pre></td></tr></table></figure>
<p># 一般无需指定初始化值，存在默认值</p>
<h5 id="2-开发中类的设计">2.开发中类的设计</h5>
<ul>
<li>根据需求，从中提取名词，作为属性</li>
<li>根据需求，从中提取动词，作为行为</li>
</ul>
<h3 id="2-封装">2.封装</h3>
<ul>
<li>封装：如何正确设计对象的属性和方法</li>
</ul>
<p># 面向对象三大特征之一</p>
<h4 id="1-原则">1.原则</h4>
<ul>
<li><strong>对象代表什么，就得到封装对应的数据，并提供数据对应的行为</strong></li>
</ul>
<h4 id="2-private关键字">2.private关键字</h4>
<ul>
<li>
<p>是一个<strong>权限修饰符</strong></p>
</li>
<li>
<p>可以修饰成员（成员变量和成员方法）</p>
</li>
<li>
<p>被private修饰的成员<strong>只能在本类中才能访问</strong></p>
</li>
<li>
<p>保证数据安全性</p>
</li>
</ul>
<p># 与public相反</p>
<ul>
<li>如果要使其他类能够使用，可以提供两个方法
<ul>
<li>set：给成员赋值</li>
<li>get：对外提供成员变量的值</li>
</ul>
</li>
</ul>
<p># 这两个需要用public修饰</p>
<h3 id="3-this关键字">3.this关键字</h3>
<h4 id="1-成员变量和局部变量">1.成员变量和局部变量</h4>
<h5 id="1-局部变量">1.局部变量</h5>
<ul>
<li>定义在方法内</li>
</ul>
<h5 id="2-成员变量">2.成员变量</h5>
<ul>
<li>定义在类内，方法外</li>
</ul>
<h5 id="3-就近原则">3.就近原则</h5>
<ul>
<li>
<p>局部变量和成员变量重名时</p>
</li>
<li>
<p>使用本方法的变量</p>
</li>
</ul>
<h4 id="2-this">2.this</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.变量名</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用成员变量</li>
</ul>
<h3 id="4-构造方法">4.构造方法</h3>
<h4 id="1-概述-3">1.概述</h4>
<ul>
<li>构造方法：也叫构造器，构造函数</li>
<li>作用：在创建对象的时候给成员变量进行赋值的</li>
</ul>
<h4 id="2-构造方法的格式">2.构造方法的格式</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">	修饰符 类名(参数)&#123;</span><br><span class="line">		方法体;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>特点</p>
<ul>
<li>
<p>方法名与类名相同</p>
</li>
<li>
<p>没有返回值类型，void也没有</p>
</li>
<li>
<p>没有具体的返回值（不能由return带回结果数据）</p>
</li>
</ul>
</li>
<li>
<p>执行时机</p>
<ul>
<li>创建对象的时候由虚拟机调用，不能手动调用构造方法</li>
<li>每创建一次对象，就会调用一次构造方法</li>
</ul>
</li>
</ul>
<h4 id="3-构造方法注意事项">3.构造方法注意事项</h4>
<ul>
<li>
<p>定义</p>
<ul>
<li>如果没有定义构造方法，系统将给出一个默认的无参数构造方法</li>
<li>如果定义了构造方法，系统将不再提供默认的构造方法</li>
</ul>
</li>
<li>
<p>重载</p>
<ul>
<li>带参构造方法，和无参数构造方法，两者方法名相同，但是参数不同，这就叫构造方法的重载</li>
</ul>
</li>
<li>
<p>推荐使用方式</p>
<ul>
<li>无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法</li>
</ul>
</li>
</ul>
<h3 id="5-标准JavaBean">5.标准JavaBean</h3>
<ul>
<li>标准的JavaBean类
<ul>
<li>类名要<strong>见名知意</strong></li>
<li>成员变量使用<strong>private修饰</strong></li>
<li>提供至少<strong>两个构造方法</strong>
<ul>
<li>无参构造方法</li>
<li>带全部参数的构造方法</li>
</ul>
</li>
<li>成员方法
<ul>
<li>提供每一个成员变量<strong>对应的set/get</strong></li>
<li>如果还有其他行为，也需要写上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-对象内存图">6.对象内存图</h3>
<h4 id="1-一个对象的内存图">1.一个对象的内存图</h4>
<ul>
<li>例如</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>1.加载class文件到<strong>方法区</strong>
<ul>
<li>main（）同时临时存储到方法区</li>
<li>再加载JavaBean类的class文件
<ul>
<li>包含所有成员变量和成员方法等</li>
</ul>
</li>
</ul>
</li>
<li>2.申明局部变量
<ul>
<li>在栈内存中，main方法进栈后，在方法中开辟一个空间即s</li>
</ul>
</li>
<li>3.在堆内存中开辟一个空间
<ul>
<li>new的Student
<ul>
<li>其中存储所有成员变量</li>
<li>还有成员方法的地址
<ul>
<li>指向方法区的方法</li>
<li>用对象调用方法时可以找到对应方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>4.默认初始化
<ul>
<li>给堆内存中的成员变量默认初始化</li>
</ul>
</li>
<li>5.显示初始化
<ul>
<li>如果一开始赋值了，堆内存中的成员变量就按赋的值初始化</li>
</ul>
</li>
<li>6.构造方法初始化
<ul>
<li>空参构造或者有参构造</li>
</ul>
</li>
<li>7.将堆内存中的地址赋值给左边的局部变量
<ul>
<li>堆内存中的地址值赋值给栈内存中的s</li>
</ul>
</li>
<li>8.方法进栈
<ul>
<li>调用方法</li>
</ul>
</li>
<li>9.方法出栈
<ul>
<li>main方法中调用的方法使用完后先出栈</li>
<li>main方法再出栈
<ul>
<li>其中的变量也消失
<ul>
<li>变量指向的堆内存中的空间也消失</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-多个对象的内存图">2.多个对象的内存图</h4>
<ul>
<li>和一个对象的内存图相似</li>
<li>但是JavaBean类的class文件只需要加载一次</li>
<li>堆内存中的两个方法地址都指向方法区的同一个方法</li>
</ul>
<h4 id="3-两个变量指向同一个对象内存图">3.两个变量指向同一个对象内存图</h4>
<ul>
<li>
<p>和前面的两个数组指向同一个空间相似</p>
</li>
<li>
<p>如果将第一个变量赋值null，表示不存在的空间</p>
<ul>
<li>则这个变量就会和堆内存中的空间的连接断开</li>
<li>输出时就会显示NullPointerException报错</li>
</ul>
</li>
<li>
<p>但是第二个变量和堆内存中的空间并没有断开，所以还能正常输出变量</p>
</li>
<li>
<p>如果两个变量都赋值null则和堆内存的连接都断开，堆内存中的空间就变成会垃圾消失</p>
</li>
</ul>
<h4 id="4-this的内存原理">4.this的内存原理</h4>
<ul>
<li>this的本质：代表方法<strong>调用者的地址值</strong></li>
</ul>
<h4 id="5-基本数据类型和引用数据类型的区别">5.基本数据类型和引用数据类型的区别</h4>
<h5 id="1-基本数据类型">1.基本数据类型</h5>
<ul>
<li>数据直接存储在栈内存中</li>
</ul>
<p># 赋值给其他变量，也是赋的真实的值</p>
<h5 id="2-引用数据类型">2.引用数据类型</h5>
<ul>
<li>栈内存中记录的是其他空间的地址值</li>
</ul>
<p># 赋值给其他变量，赋的<strong>地址值</strong></p>
<h4 id="6-局部变量和成员变量的区别">6.局部变量和成员变量的区别</h4>
<table>
<thead>
<tr>
<th>区别</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>类中的位置不同</td>
<td>类中，方法外</td>
<td>方法内，方法申明上</td>
</tr>
<tr>
<td>初始化值不同</td>
<td>有默认初始化值</td>
<td>没有，使用之前需要完成赋值</td>
</tr>
<tr>
<td>内存位置不同</td>
<td>堆内存</td>
<td>栈内存</td>
</tr>
<tr>
<td>生命周期不同</td>
<td>随着对象的创建而存在，随着对象的消失而消失</td>
<td>随着方法的调用而存在，随着方法的运行结束而消失</td>
</tr>
<tr>
<td>作用域</td>
<td>整个类中有效</td>
<td>当前方法中有效</td>
</tr>
</tbody>
</table>
<h2 id="7-字符串">7.字符串</h2>
<h3 id="1-API">1.API</h3>
<ul>
<li>API（Application Programming Interface）：应用程序编程接口</li>
</ul>
<h3 id="2-String">2.String</h3>
<h4 id="1-概述-4">1.概述</h4>
<ul>
<li>
<p>java.lang.String类代表字符串，java程序中的所有字符串文字都为此类的对象</p>
</li>
<li>
<p>字符串的内容是不会发生改变的，它的对象在创建后不能被改变</p>
</li>
</ul>
<p># 要修改就要先对原字符串，创建一个数组，里面存储每个字符，再修改对应的字符</p>
<h4 id="2-创建String对象的两种方式">2.创建String对象的两种方式</h4>
<h5 id="1-直接赋值">1.直接赋值</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Sting</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-new">2.new</h5>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String()</td>
<td>创建空白字符串，不含任何内容</td>
</tr>
<tr>
<td>public String(String original)</td>
<td>根据传入的字符串，创建字符串对象</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符数组，创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] chs)</td>
<td>根据字节数组，创建字符串对象</td>
</tr>
</tbody>
</table>
<p># 后两个都要先创建一个对应的数组即char[] chs和byte[] chs</p>
<h5 id="3-内存分析">3.内存分析</h5>
<ul>
<li>有一个单独的串池（StringTable）</li>
</ul>
<p># 7以前在方法区，后在堆内存中</p>
<ul>
<li>
<p><strong>直接创建</strong> 的，在赋值时，系统先在串池观察是否有这个字符串，如果没有则创建，然后将地址赋值到栈内存中的变量，如果有则直接赋值到栈内存中的变量（复用）</p>
</li>
<li>
<p>new的，不会涉及到串池，直接在堆内存中开辟空间，直接把地址值赋值到栈内存中，不会有复用现象，占用更多空间</p>
</li>
</ul>
<p># 键盘录入的也是new的</p>
<h3 id="3-String的比较">3.String的比较</h3>
<h4 id="1-号">1.==号</h4>
<h5 id="1-基本数据类型-2">1.基本数据类型</h5>
<ul>
<li>比较的是具体的数据值</li>
</ul>
<h5 id="2-引用数据类型-2">2.引用数据类型</h5>
<ul>
<li>比较的是数据的的地址值</li>
</ul>
<h4 id="2-bolean-equals方法">2.bolean equals方法</h4>
<ul>
<li>变量名.equals(要比较的字符串)：完全一样结果才是true，否则为false</li>
</ul>
<h4 id="3-bolean-equalslgnoreCase方法">3.bolean equalslgnoreCase方法</h4>
<ul>
<li>变量名.equalslgnoreCase(要比较的字符串)：忽略大小写的比较</li>
</ul>
<h3 id="4-StringBuilder">4.StringBuilder</h3>
<h4 id="1-概述-5">1.概述</h4>
<ul>
<li>StringBuilder可以看作一个容器，创建后里面的内容是可变的</li>
<li>作用：提高字符串的操作效率</li>
</ul>
<h4 id="2-构造方法">2.构造方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringBuilder()</td>
<td>创建一个空白可变字符串对象，不含任何内容</td>
</tr>
<tr>
<td>public StringBuilder(String str)</td>
<td>根据字符串的内容，来创建可变字符串对象</td>
</tr>
</tbody>
</table>
<h4 id="3-常用方法">3.常用方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringBuilder append(任意类型)</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>public StringBuilder reverse()</td>
<td>反转容器中的内容</td>
</tr>
<tr>
<td>public int length()</td>
<td>返回长度（字符出现的个数）</td>
</tr>
<tr>
<td>public String toString()</td>
<td>通过toString()就可以实现把StringBuilder转换为String</td>
</tr>
</tbody>
</table>
<h3 id="5-StringJoiner">5.StringJoiner</h3>
<ul>
<li>StringJoiner和StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的</li>
<li>作用：提高字符串的操作效率，而且代码编写更加简洁</li>
</ul>
<p># 因为在jdk8后才出现，所以使用较少</p>
<h4 id="1-构造方法">1.构造方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringJoiner （间隔符号）</td>
<td>创建一个StringJoiner对象，指定拼接时的间隔符号</td>
</tr>
<tr>
<td>public StringJoiner（间隔符号，开始符号，结束符号）</td>
<td>创建一个StringJoiner对象，指定拼接时的间隔符号，开始符号，结束符号</td>
</tr>
</tbody>
</table>
<h4 id="2-成员方法">2.成员方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringJoiner add（添加的内容）</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>public int length（）</td>
<td>返回长度（字符出现的个数）</td>
</tr>
<tr>
<td>public String toString（）</td>
<td>返回一个字符串（该字符串就是拼接之后的结果）</td>
</tr>
</tbody>
</table>
<h3 id="6-字符串原理">6.字符串原理</h3>
<h4 id="1-字符串存储的内存原理">1.字符串存储的内存原理</h4>
<ul>
<li>直接赋值的
<ul>
<li>会<strong>复用</strong> 字符串常量池中的</li>
</ul>
</li>
<li>new出来的
<ul>
<li>不会复用，而是<strong>开辟一个新的空间</strong></li>
</ul>
</li>
</ul>
<h4 id="2-比较的原理">2.==比较的原理</h4>
<ul>
<li><strong>基本数据类型</strong> 比较<strong>数据值</strong></li>
<li><strong>引用数据类型</strong> 比较<strong>地址值</strong></li>
</ul>
<h4 id="3-字符串拼接的底层原理">3.字符串拼接的底层原理</h4>
<ul>
<li>
<p>拼接的时候没有变量，都是字符串</p>
<ul>
<li>触发字符串的优化机制</li>
<li>在编译的时候就已经是最终的结果了</li>
</ul>
</li>
<li>
<p>有变量和字符参与拼接</p>
<ul>
<li>jdk8前使用StringBuilder
<ul>
<li>main方法进栈</li>
<li>变量直接赋值，并且在串池生成一个对应字符串</li>
<li>在堆内存中创建一个StringBuilder的方法，通过append方法将参与的变量和字符放到StringBuilder中</li>
<li>再用toString将其变回字符串，字符串就变成了拼接好的
<ul>
<li>toString中使用了一个名为newString的方法，这个方法在返回的时候是new了一个新的字符串</li>
</ul>
</li>
</ul>
</li>
<li>jdk8
<ul>
<li>先预估最终字符串的长度并创建该长度的数组</li>
<li>把字符存进去后，再把数组整体变成一个字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-StringBuilder提高效率原理图">4.StringBuilder提高效率原理图</h4>
<ul>
<li>main方法进栈</li>
<li>StringBuilder方法进栈，同时在堆内存中开辟空间</li>
<li>调用append方法把字符全部添加到堆内存中的空间中</li>
</ul>
<h4 id="5-StringBuilder原码分析">5.StringBuilder原码分析</h4>
<ul>
<li>在创建的时候会创建一个字节数组，默认<strong>容量</strong> 16，表示最多能存储16</li>
<li>向其中添加字符串时，添加的是ASCII码
<ul>
<li>当添加的字符串大于16，就会扩容，创建一个新的数组，容量=老容量*2+2</li>
<li>如果添加的数据超出了扩容后的容量，则会创建一个当前数据量的容量的数组</li>
</ul>
</li>
</ul>
<h2 id="8-ArrayList">8.ArrayList</h2>
<h3 id="1-集合介绍">1.集合介绍</h3>
<ul>
<li>与数组类似，用于存储元素，但区别于数组的是可以自动扩容</li>
<li>但是集合只能存储引用数据类型
<ul>
<li>如果要存储基本数据类型就要包装类</li>
<li>基本数据类型中int对应Integer，char对应Character，其余数据类型都将首字母大写</li>
</ul>
</li>
</ul>
<h3 id="2-集合">2.集合</h3>
<h4 id="ArrayList">ArrayList</h4>
<ul>
<li>
<p>ArrayList是Java中写好的一个类</p>
</li>
<li>
<p>需要导包：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure>
<h5 id="1-泛型">1.泛型</h5>
<ul>
<li>限定集合中存储数据的类型</li>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;类型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;类型&gt;();</span><br></pre></td></tr></table></figure>
<p># jdk7前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;类型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p># jdk7后</p>
<h5 id="2-成员方法-2">2.成员方法</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(E e)</td>
<td>添加元素，返回值表示是否添加成功</td>
</tr>
<tr>
<td>boolean remove(E e)</td>
<td>删除指定元素，返回值表示是否删除成功</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定索引的元素，返回被删除元素</td>
</tr>
<tr>
<td>E set(int index,E e)</td>
<td>修改指定索引下的元素，返回原来的元素</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>获取指定索引的元素</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中元素的个数</td>
</tr>
</tbody>
</table>
<h2 id="9-面向对象进阶">9.面向对象进阶</h2>
<h3 id="1-static">1.static</h3>
<h4 id="1-static-2">1.static</h4>
<ul>
<li>static表示静态，是Java中的一个修饰符，可以修饰成员方法，成员变量</li>
</ul>
<h5 id="1-静态变量">1.静态变量</h5>
<ul>
<li>
<p>特点：</p>
<ul>
<li>被该类所有对象<strong>共享</strong></li>
<li>不属于对象，属于类</li>
<li><strong>静态变量是随着类的加载而加载的，优先于对象出现</strong></li>
</ul>
</li>
<li>
<p>调用方式：</p>
<ul>
<li>类名调用（推荐）</li>
<li>对象名调用</li>
</ul>
</li>
<li>
<p>内存图</p>
<ul>
<li>
<p>main方法进栈</p>
</li>
<li>
<p>用类名调用静态变量</p>
<ul>
<li>类名的字节码会加载到方法区</li>
<li>在堆内存中会创建一个静态存储位置（静态区）</li>
</ul>
<p># jdk8前静态区在方法区</p>
<ul>
<li>在静态区存入静态变量
<ul>
<li><strong>静态变量是随着类的加载而加载的，优先于对象出现</strong></li>
</ul>
</li>
<li>给变量赋值</li>
</ul>
</li>
<li>
<p>创建一个对象</p>
</li>
<li>
<p>在堆内存中为非静态变量开辟空间</p>
</li>
<li>
<p>给对象的属性赋值</p>
</li>
</ul>
</li>
</ul>
<h5 id="2-静态方法">2.静态方法</h5>
<ul>
<li>
<p>特点：</p>
<ul>
<li>多用于<strong>测试类</strong> 和<strong>工具类</strong>
<ul>
<li>工具类：
<ul>
<li>不描述任何事物的类
<ul>
<li>类名见名知意</li>
<li>私有化构造方法</li>
<li>方法定义为静态便于调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>JavaBean类中很少使用</li>
</ul>
</li>
<li>
<p>调用方式：</p>
<ul>
<li>类名调用（推荐）</li>
<li>对象名调用</li>
</ul>
</li>
</ul>
<h4 id="2-注意事项">2.注意事项</h4>
<ul>
<li>
<p>静态方法只能访问静态变量和静态方法</p>
</li>
<li>
<p>非静态方法可以访问静态变量或静态方法，也可以访问非静态的成员变量和非静态的成员方法</p>
</li>
<li>
<p>静态方法中没有this关键字</p>
</li>
<li>
<p>内存图</p>
<ul>
<li>静态：
<ul>
<li>随着类的加载而加载</li>
</ul>
</li>
<li>非静态：
<ul>
<li>跟对象有关</li>
</ul>
</li>
<li>静态方法不能访问非静态变量（实例变量）：
<ul>
<li>main方法进栈</li>
<li>将对象的字节码文件加载到方法区
<ul>
<li>包含对象的属性变量和方法</li>
</ul>
</li>
<li>将静态的变量存到堆内存中的静态区</li>
<li>静态方法进栈</li>
<li>方法调用变量会到静态区调用
<ul>
<li>但是静态区中只有静态的变量，非静态的在方法区</li>
</ul>
</li>
</ul>
</li>
<li>非静态可以访问所有：
<ul>
<li>main方法进栈</li>
<li>将对象的字节码文件加载到方法区
<ul>
<li>包含对象的属性变量和方法</li>
</ul>
</li>
<li>将静态的变量存到堆内存中的静态区</li>
<li>有new在堆内存中开辟空间
<ul>
<li>存储对象的属性变量</li>
<li>空间关联静态区</li>
</ul>
</li>
<li>空间的地址赋值给栈内存中的变量</li>
<li>非静态方法调用到堆内存中访问开辟的空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-继承">2.继承</h3>
<h4 id="1-概述-6">1.概述</h4>
<ul>
<li>
<p>面向对象的三大特点之一</p>
</li>
<li>
<p>Java中提供一个关键字extends，用这个关键字，可以让一个类和另一个类建立起继承关系</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Student称为<strong>子类（派生类）</strong>，Person称为<strong>父类（基类或超类）</strong></p>
</li>
<li>
<p>将多个子类中重复的代码抽取到父类中，提高了代码的复用性</p>
</li>
<li>
<p>子类可以在父类的基础上，增加其他功能，使子类更强大</p>
</li>
</ul>
<h4 id="2-什么时候使用继承">2.什么时候使用继承</h4>
<ul>
<li>在类与类之间，存在相同的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码</li>
</ul>
<h4 id="3-特点">3.特点</h4>
<ul>
<li>Java只支持单继承，不支持多继承，但支持多层继承，子类只能<strong>访问</strong> 父类中非私有的成员</li>
<li>只支持单继承：
<ul>
<li>一个子类只能继承一个父类</li>
</ul>
</li>
<li>不支持多继承：
<ul>
<li>子类不能同时继承多个父类</li>
</ul>
</li>
<li>支持多层继承：
<ul>
<li>子类的父类可以有父类
<ul>
<li>父类的父类就是子类的<strong>间接父类</strong></li>
<li>所有类都直接或间接继承<strong>Object</strong>
<ul>
<li>默认继承于<strong>Object</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-子类能继承的">4.子类能继承的</h4>
<table>
<thead>
<tr>
<th>父类中的</th>
<th>非私有</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造方法</td>
<td>不能</td>
<td>不能</td>
</tr>
<tr>
<td>成员变量</td>
<td>能</td>
<td>能</td>
</tr>
<tr>
<td>成员方法</td>
<td>能</td>
<td>不能</td>
</tr>
</tbody>
</table>
<h5 id="1-构造方法-2">1.构造方法</h5>
<ul>
<li>如果继承父类的构造方法则构造方法的名字和父类相同，但是构造方法的特点是方法名和类名相同</li>
</ul>
<h5 id="2-成员变量-2">2.成员变量</h5>
<ul>
<li>
<p>内存图</p>
<ul>
<li>
<p>main方法进栈</p>
</li>
<li>
<p>字节码加载进方法区</p>
</li>
<li>
<p>将子类的字节码文件加载到方法区</p>
</li>
<li>
<p>将子类的父类的字节码文件加载到方法区</p>
</li>
<li>
<p>在栈内存中声明变量</p>
<ul>
<li>在堆内存中开辟空间
<ul>
<li>把这个空间一分为二</li>
<li>存储子类和父类的成员</li>
</ul>
</li>
</ul>
</li>
<li>
<p>赋值时，先在堆内存的子类中找是否有对应的成员，没有则在父类中找，再赋值</p>
</li>
</ul>
</li>
</ul>
<p># 但是如果父类中的变量private了，则不能赋值</p>
<h5 id="3-成员方法">3.成员方法</h5>
<ul>
<li>不会直接继承方法</li>
<li>而是会有一个<strong>虚方法表</strong>
<ul>
<li>虚方法：
<ul>
<li>非private</li>
<li>非static</li>
<li>非final</li>
</ul>
</li>
</ul>
</li>
<li>每个子类中继承父类的虚方法表的同时再加上自己的虚方法，然后给其子类继承</li>
</ul>
<h4 id="5-继承中的访问特点">5.继承中的访问特点</h4>
<h5 id="1-成员变量">1.成员变量</h5>
<ul>
<li>就近原则：逐级查找最近的变量</li>
<li>如果几个类中的变量重名：
<ul>
<li>不加关键字：从局部开始向上找</li>
<li>加this关键字：从本类中开始向上找</li>
<li>加super关键字：从父类中开始向上找</li>
</ul>
</li>
</ul>
<h5 id="2-成员方法-3">2.成员方法</h5>
<ul>
<li>
<p>与成员变量的特点相同</p>
</li>
<li>
<p>方法的重写：当父类的方法不能满足子类现在的需求时，需要进行方法重写</p>
<ul>
<li>
<p>书写格式：在继承体系中，子类出现了和父类一样的方法声明，则这个子类的方法就是重写的方法</p>
</li>
<li>
<p>@Override重写注解：@Override写在重写后的方法上，校验子类重写时语法是否正确</p>
</li>
<li>
<p>本质：将原来继承的虚方法表中的方法覆盖为当前类的方法，其子类继承的虚方法表也就是覆盖后的虚方法表</p>
</li>
</ul>
</li>
<li>
<p>注意事项</p>
<ul>
<li>重写方法的名称和形参列表必须和父类中的一致</li>
<li>子类重写父类方法时，访问权限子类必须大于等于父类</li>
<li>子类重写父类方法时，返回值类型子类必须小于等于父类</li>
<li>只有被添加到虚方法表中的方法才能被重写</li>
</ul>
</li>
</ul>
<h5 id="3-构造方法">3.构造方法</h5>
<ul>
<li>
<p>父类中的构造方法不会被子类继承</p>
</li>
<li>
<p>子类中所有的构造方法默认先访问父类中的无参构造，再执行自己</p>
<ul>
<li>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类就无法使用</li>
<li>子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化</li>
</ul>
</li>
<li>
<p>子类的构造方法第一行语句默认都是super();（不写也是默认存在的），第二行才可以写构造方法</p>
</li>
<li>
<p>如果要调用父类的有参构造，则需要加上super(父类中带参构造的变量名);</p>
</li>
</ul>
<h4 id="6-this，super使用总结">6.this，super使用总结</h4>
<h5 id="1-this">1.this</h5>
<ul>
<li>可以理解为一个变量，表示当前方法调用者的地址值</li>
</ul>
<h5 id="2-super">2.super</h5>
<ul>
<li>代表父类存储空间</li>
</ul>
<h3 id="3-多态">3.多态</h3>
<ul>
<li>面向对象三大特点之一</li>
</ul>
<h4 id="1-概述-7">1.概述</h4>
<ul>
<li>同类型的对象，表现出的不同形态</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 对象名称 = 子类对象;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>前提：</p>
<ul>
<li>有继承关系</li>
<li>有父类引用指向子类对象</li>
<li>有方法重写</li>
</ul>
</li>
<li>
<p>好处：</p>
<ul>
<li>使用父类型作为参数，可以接收所有子类的对象</li>
</ul>
</li>
</ul>
<h4 id="2-调用成员的特点">2.调用成员的特点</h4>
<h5 id="1-变量调用">1.变量调用</h5>
<ul>
<li>编译看左边，运行看左边</li>
</ul>
<p># javac在编译的时候看左边的父类中有没有这个变量，有则能编译成功</p>
<p># 运行时，实际获取的就是左边父类中成员变量的值</p>
<h5 id="2-方法调用">2.方法调用</h5>
<ul>
<li>编译看左边，运行看右边</li>
</ul>
<p># javac在编译的时候看左边的父类中有没有这个方法，有则能编译成功</p>
<p># 运行时，实际运行的是子类中的方法</p>
<h4 id="3-优势">3.优势</h4>
<ul>
<li>在多态形式下，右边对象可以实现解耦合，便于扩展和维护</li>
<li>定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性和便利</li>
</ul>
<h4 id="4-弊端">4.弊端</h4>
<ul>
<li>不能使用子类的特有功能</li>
<li>如果要使用就要转换类型</li>
</ul>
<p># 就可以将其转换为真正的子类类型，从而调用子类的特有功能</p>
<p># 转换类型与真实对象类型不一致会报错</p>
<h5 id="判断是否为某一类型并且强制转换">判断是否为某一类型并且强制转换</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量名<span class="number">1</span> <span class="keyword">instanceof</span> 类型<span class="number">1</span> 变量名<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p># 如果变量名1是类型1则强转为类型1，转换后变量名为变量名2</p>
<p># 如果不是则不强转，结果返回false</p>
<p># 在jdk14后</p>
<h3 id="4-包，final，权限修饰符，代码块">4.包，final，权限修饰符，代码块</h3>
<h5 id="1-包">1.包</h5>
<ul>
<li>
<p>文件夹，用于管理不同功能的Java类，便于后期代码维护</p>
</li>
<li>
<p>包名规则：</p>
<ul>
<li>公司域名反写+包的作用，全部英文小写，见名知意</li>
</ul>
</li>
<li>
<p>全类名（全限定名）：</p>
<ul>
<li>
<p>包名+类名</p>
</li>
<li>
<p>使用其他类时就要使用全类名</p>
</li>
<li>
<p>或者直接导包：</p>
<ul>
<li>import 全类名</li>
</ul>
</li>
<li>
<p>使用同一个包中的类时，不需要导包</p>
</li>
<li>
<p>java.lang包中的类不需要导包</p>
</li>
<li>
<p>如果同时使用两个包中的同名类，需要用全类名</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-final">2.final</h4>
<h5 id="1-修饰方法">1.修饰方法</h5>
<ul>
<li>表示该方法是最终方法，不能被重写</li>
</ul>
<h5 id="2-修饰类">2.修饰类</h5>
<ul>
<li>表示该类是最终类，不能被继承</li>
</ul>
<h5 id="3-修饰变量">3.修饰变量</h5>
<ul>
<li>
<p>叫做常量，只能被赋值一次</p>
<ul>
<li>常量的命名：
<ul>
<li>单个单词：全部大写</li>
<li>多个单词：全部大写，中间用下划线连接</li>
</ul>
</li>
</ul>
</li>
<li>
<p>修饰的变量是基本数据类型：</p>
<ul>
<li>变量存储的数据值不能发生改变</li>
</ul>
</li>
<li>
<p>修饰的变量是引用数据类型：</p>
<ul>
<li>变量存储的地址值不能发生改变，对象内部的可以改变</li>
</ul>
<p># 例如数组中的值可以变，但是数组的地址值是不能变的</p>
</li>
</ul>
<h4 id="3-权限修饰符">3.权限修饰符</h4>
<h5 id="作用范围">作用范围</h5>
<ul>
<li>private&lt;空&lt;protected&lt;public</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类</th>
<th>同一个包中的其他类</th>
<th>不同包下的子类</th>
<th>不同包下的无关类</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody>
</table>
<p># 如果方法中的代码抽取其他方法中共性的代码，这个方法一般也私有</p>
<h4 id="4-代码块">4.代码块</h4>
<h5 id="1-局部代码块">1.局部代码块</h5>
<ul>
<li>{}中的内容，可以其他结束代码块中的变量的生命周期</li>
</ul>
<p># 但是现在已经不需要节省变量的一点空间了</p>
<h5 id="2-构造代码块">2.构造代码块</h5>
<ul>
<li>把构造方法中重复的内容写在成员位置的代码块</li>
<li>执行时机：
<ul>
<li>在创建本类对象的时候会先执行构造代码块再执行构造方法</li>
</ul>
</li>
</ul>
<p># 使用也较少，因为不够灵活</p>
<h5 id="3-静态代码块">3.静态代码块</h5>
<ul>
<li>格式：
<ul>
<li>static{}</li>
</ul>
</li>
<li>特点：
<ul>
<li>需要通过static关键字修饰，随着类的加载而加载，并且自动触发，只执行一次</li>
</ul>
</li>
<li>使用场景：
<ul>
<li>在类加载的时候，做一些数据初始化的时候使用</li>
</ul>
</li>
</ul>
<h3 id="5-抽象类">5.抽象类</h3>
<h4 id="1-抽象方法">1.抽象方法</h4>
<ul>
<li>
<p>一个方法抽取到父类中，但是子类的具体写法不同，这时候就可以写一个抽象方法，起所在的类就是抽象类</p>
</li>
<li>
<p>抽象方法的定义格式：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象类的定义格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-注意事项-2">2.注意事项</h4>
<ul>
<li>抽象类不能实例化
<ul>
<li>即不能创建对象</li>
</ul>
</li>
<li>抽象类不一定有抽象方法，有抽象方法一定是抽象类</li>
<li>抽象类可以有构造方法
<ul>
<li>当创建子类对象时，给属性进行赋值</li>
</ul>
</li>
<li>抽象类的子类
<ul>
<li>重写抽象类中的所有抽象方法</li>
<li>或者是抽象类</li>
</ul>
</li>
</ul>
<h4 id="3-意义">3.意义</h4>
<ul>
<li>强制子类按照格式重写这个抽象方法</li>
<li>在开发时可以更加统一</li>
</ul>
<h3 id="6-接口">6.接口</h3>
<ul>
<li>一个父类下的几个子类，其他几个可以共享一个方法，但也有不能使用这个方法的，这样就不能写在父类中</li>
<li>这时候就需要接口，只给几个子类使用</li>
<li>和抽象类很像
<ul>
<li>但是一般只表示行为</li>
<li>一般不像抽象类表示一种事物</li>
</ul>
</li>
</ul>
<h4 id="1-定义接口并使用接口">1.定义接口并使用接口</h4>
<ul>
<li>接口用关键字interface来定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口不能实例化</li>
<li>接口和类之间是实现关系，通过implements关键字表示</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口的子类（实现类）
<ul>
<li>重写接口中的所有抽象方法</li>
<li>或者是抽象类</li>
</ul>
</li>
</ul>
<h4 id="2-接口中的成员特点">2.接口中的成员特点</h4>
<h5 id="1-成员变量-2">1.成员变量</h5>
<ul>
<li>只能是常量</li>
<li>默认修饰符：public static final</li>
</ul>
<h5 id="2-构造方法-2">2.构造方法</h5>
<ul>
<li>无</li>
</ul>
<h5 id="3-成员方法-2">3.成员方法</h5>
<ul>
<li>只能是抽象方法</li>
<li>默认修饰符：public abstract</li>
</ul>
<p># jdk7前接口中只能定义抽象方法</p>
<h4 id="3-接口和类之间的关系">3.接口和类之间的关系</h4>
<h5 id="1-类和类">1.类和类</h5>
<ul>
<li>继承关系，只能单继承，不能多继承，但是可以多层继承</li>
</ul>
<h5 id="2-类和接口">2.类和接口</h5>
<ul>
<li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li>
</ul>
<p># 在多个接口中有重名的方法，重写的时候所有方法只需要重写一次即可</p>
<h5 id="3-接口和接口">3.接口和接口</h5>
<ul>
<li>继承关系，可以单继承，也可以多继承</li>
</ul>
<p># 实现类在实现的时候就要把接口的继承体系中的所有方法都重写</p>
<h4 id="4-JDK8后的接口">4.JDK8后的接口</h4>
<ul>
<li>
<p>可以定义有方法体的方法，即默认方法</p>
<ul>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以不强制重写，但是重写的时候就要把default去掉</li>
<li>当多个接口中有相同名字的默认方法，子类必须对该方法重写</li>
</ul>
</li>
<li>
<p>允许在接口中定义静态方法，用static修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只能通过接口名调用，不能通过实现类名或者对象名调用</li>
</ul>
</li>
<li>
<p>可以定义私有的方法</p>
<ul>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于静态的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于抽取出方法中重复的代码，再给方法调用，但是不让其他方法调用</li>
</ul>
</li>
</ul>
<p># 私有方法在jdk9后</p>
<h4 id="5-接口的应用">5.接口的应用</h4>
<ul>
<li>
<p>接口代表规则，是行为的抽象，要让一个类拥有这个行为，就让这个类实现对应接口</p>
</li>
<li>
<p>当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方法称之为接口多态</p>
</li>
</ul>
<h4 id="6-适配器设计模式">6.适配器设计模式</h4>
<ul>
<li>
<p><strong>设计模式</strong> ：</p>
<ul>
<li>是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结，使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性，程序的重用性</li>
</ul>
</li>
<li>
<p><strong>适配器设计模式</strong> ：</p>
<ul>
<li>解决接口与接口实现类之间的矛盾问题</li>
<li>当一个接口中有很多抽象方法，但有时候只需要用到其中一部分的时候
<ul>
<li>先编写一个中间类，实现对应接口，对接口中的抽象方法进行空实现，即不写方法体</li>
<li>让真正的实现类继承中间类，并重写需要用到的方法</li>
<li>为了避免其他类创建适配器类的对象，中间类用abstract修饰</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-内部类">7.内部类</h3>
<ul>
<li>
<p>类的五大成员之一</p>
</li>
<li>
<p>在一个类中，再定义一个类</p>
</li>
<li>
<p>内部类表示的事物是外部类的一部分</p>
</li>
<li>
<p>内部类单独出现没有任何意义</p>
</li>
<li>
<p>访问特点：</p>
<ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类要访问内部类的成员，必须创建对象</li>
</ul>
</li>
</ul>
<h4 id="1-成员内部类">1.成员内部类</h4>
<ul>
<li>写在成员位置的，属于外部类的成员</li>
</ul>
<h5 id="1-如何书写">1.如何书写</h5>
<ul>
<li>可以被一些修饰符修饰</li>
<li>成员内部类中的成员，在jdk16后可以定义静态变量</li>
</ul>
<h5 id="2-创建成员内部类">2.创建成员内部类</h5>
<ul>
<li>在外部类中编写方法，对外提供内部类的对象</li>
</ul>
<p># 在内部类私有的时候使用</p>
<p>或</p>
<ul>
<li>直接创建：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = 外部类对象.内部类对象;</span><br></pre></td></tr></table></figure>
<h5 id="3-成员内部类如何获取外部类的成员变量">3.成员内部类如何获取外部类的成员变量</h5>
<ul>
<li>
<p>没有重名的时候可以直接调用</p>
</li>
<li>
<p>有重名时则会<strong>就近原则</strong></p>
</li>
<li>
<p>用this可以调用内部类的方法外的变量</p>
</li>
<li>
<p>要调用外部类的变量则要用<strong>外部类名.this.变量名</strong></p>
</li>
<li>
<p>内存图</p>
<ul>
<li>内部类和外部类是两个字节码加载到方法区</li>
<li>堆内存中开辟两个空间
<ul>
<li>一个是外部类</li>
<li>一个是内部类
<ul>
<li>内部类中除了其本身的成员，还有一个隐藏的this记录外部类对象的地址值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-静态内部类">2.静态内部类</h4>
<ul>
<li>
<p>成员内部类的一种特殊情况</p>
</li>
<li>
<p>被用static修饰</p>
</li>
<li>
<p>创建静态内部类对象的格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.内部类名;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>调用非静态方法的格式</p>
<ul>
<li>先创建对象，用对象调用</li>
</ul>
</li>
<li>
<p>调用静态方法的格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名.方法名();</span><br></pre></td></tr></table></figure>
<h4 id="3-局部内部类">3.局部内部类</h4>
<ul>
<li>将内部类定义在方法里面，类似于方法里面的局部变量</li>
<li>外界是无法直接使用的，需要在方法内部创建对象并使用</li>
<li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li>
</ul>
<h4 id="4-匿名内部类">4.匿名内部类</h4>
<ul>
<li>本质就是隐藏了名字的内部类</li>
<li>可以写在成员位置，也可以写在局部位置</li>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名()&#123;</span><br><span class="line">	重写方法;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>其实际名字：外部类名$序号</li>
<li>这个整体就是一个类的子类对象或者是一个接口的实现类对象</li>
<li>应用场景
<ul>
<li>当方法的参数是接口或者类时</li>
<li>可以传递这个接口的实现类对象</li>
<li>但是如果这个实现类对象只使用一次，就没必要定义，可以用匿名内部类简化代码</li>
</ul>
</li>
</ul>
<h2 id="10-常用API">10.常用API</h2>
<h3 id="1-Math">1.Math</h3>
<ul>
<li>用于进行数学计算的工具类</li>
<li><strong>私有化构造方法，所有方法都是静态的</strong></li>
<li>用<strong>Math.方法名</strong> 调用</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public static int abs(int a)</td>
<td>获取参数绝对值</td>
</tr>
<tr>
<td style="text-align:left">public static double ceil(double a)</td>
<td>向上取整</td>
</tr>
<tr>
<td style="text-align:left">public static double floor(float a)</td>
<td>向下取整</td>
</tr>
<tr>
<td style="text-align:left">public static int round(float a)</td>
<td>四舍五入</td>
</tr>
<tr>
<td style="text-align:left">public static int max(int a, int b)</td>
<td>获取两个int值中的较大值</td>
</tr>
<tr>
<td style="text-align:left">public static double pow(double a,double b)</td>
<td>返回a的b次幂的值</td>
</tr>
<tr>
<td style="text-align:left">public static double random()</td>
<td>返回值为double的随机值，0.0-1.0，包含0.0，不包含1.0</td>
</tr>
</tbody>
</table>
<p># 在int类型中的最小值-2147483648没有绝对值</p>
<h3 id="2-System">2.System</h3>
<ul>
<li>工具类，提供了一些于系统相关的方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static void exit(int status)</td>
<td>终止当前运行的Java虚拟机，其中0为正常停止，非0为异常停止</td>
</tr>
<tr>
<td>public static long currentTimeMills()</td>
<td>返回当前系统的时间毫秒值形式</td>
</tr>
<tr>
<td>public static void arraycopy(数据源数组，起始索引，目的地数组，起始索引，拷贝个数)</td>
<td>数组拷贝</td>
</tr>
</tbody>
</table>
<p># 数组拷贝时如果是基本数据类型则数据类型要一致，如果是引用数据类型则子类类型可以赋值给父类类型也不能超过数组长度</p>
<h3 id="3-Runtime">3.Runtime</h3>
<ul>
<li>表示当前虚拟机的运行环境</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static Runtime grtRuntime()</td>
<td>当前系统的运行环境对象</td>
</tr>
<tr>
<td>public void exit(int status)</td>
<td>停止虚拟机</td>
</tr>
<tr>
<td>public int availableProcessors()</td>
<td>获得CPU的线程数</td>
</tr>
<tr>
<td>public long maxMemory()</td>
<td>JVM能从系统中获取总内存大小（单位byte）</td>
</tr>
<tr>
<td>public long totalMemory()</td>
<td>JVM已经从系统中获取总内存大小（单位byte）</td>
</tr>
<tr>
<td>public long freeMemory()</td>
<td>JVM剩余内存大小（单位byte）</td>
</tr>
<tr>
<td>public Process exec(String command)</td>
<td>运行cmd命令</td>
</tr>
</tbody>
</table>
<h3 id="4-Object和Objects">4.Object和Objects</h3>
<ul>
<li>Java中的父类，所有类都直接或简洁的继承于Object类</li>
</ul>
<h4 id="1-Object的构造方法">1.Object的构造方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Object()</td>
<td>空参构造</td>
</tr>
</tbody>
</table>
<h4 id="2-Object的成员方法">2.Object的成员方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String toString()</td>
<td>返回对象的字符串表示形式</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>比较两个对象是否相等</td>
</tr>
<tr>
<td>protected Object clone(int a)</td>
<td>对象克隆</td>
</tr>
</tbody>
</table>
<p># Object中的equals比较的是地址值，一般需要重写用alt+insert选择自动重写，可以比较具体的属性</p>
<p># toString一般也会重写，打印对象时打印属性</p>
<h4 id="3-对象克隆">3.对象克隆</h4>
<ul>
<li>把A对象的属性值完全拷贝给B对象，也叫对象拷贝，对象复制</li>
<li>要重写Object中的clone方法</li>
<li>在JavaBean类中实现接口</li>
</ul>
<h5 id="1-浅克隆">1.浅克隆</h5>
<ul>
<li>基本数据类型直接拷贝数据</li>
<li>引用数据类型直接拷贝地址值</li>
</ul>
<h5 id="2-深克隆">2.深克隆</h5>
<ul>
<li>基本数据类型直接拷贝数据</li>
<li>字符串复用串池的</li>
<li>引用数据类型
<ul>
<li>例如数组</li>
<li>先创建一个新的数组</li>
<li>把原来数组的数据拷贝到新的数组中</li>
<li>再把新的数组的地址值给对象</li>
</ul>
</li>
</ul>
<h4 id="4-Objects">4.Objects</h4>
<ul>
<li>一个工具类，提供一些方法去完成一些功能</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static boolean equals(Object a,Object b)</td>
<td>先做非空判断，比较两个对象</td>
</tr>
<tr>
<td>public static boolean isNull(Object obj)</td>
<td>判断对象是否为null，为null返回true，反之</td>
</tr>
<tr>
<td>public static boolean nonNull(Object obj)</td>
<td>判断对象是否为null，是isNull的结果相反</td>
</tr>
</tbody>
</table>
<h3 id="5-BigInteger和BigDecimal">5.BigInteger和BigDecimal</h3>
<h4 id="1-BigInteger">1.BigInteger</h4>
<h5 id="1-构造方法-3">1.构造方法</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public BigInteger(int num,Random rnd)</td>
<td>获取随机大整数，范围：0~$2^{num}-1$</td>
</tr>
<tr>
<td>public BigInteger(String val)</td>
<td>获取指定的大整数，字符串中必须是整数</td>
</tr>
<tr>
<td>public BigInteger(String val,int radix)</td>
<td>获取指定进制的大整数</td>
</tr>
<tr>
<td>public static BigInteger valueOf(long val)</td>
<td>静态方法获取BigInteger的对象，内部有优化，对常用数字-16~16进行了优化，会提前创建好，如果多次获取不会重新创建新的</td>
</tr>
</tbody>
</table>
<p># 对象一旦创建，内部记录的值不能发生改变</p>
<h5 id="2-常见成员方法">2.常见成员方法</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public BigInteger add(BigInteger val)</td>
<td>加法</td>
</tr>
<tr>
<td>public BigInteger subtract(BigInteger val)</td>
<td>减法</td>
</tr>
<tr>
<td>public BigInteger multiply(BigInteger val)</td>
<td>乘法</td>
</tr>
<tr>
<td>public BigInteger divide(BigInteger val)</td>
<td>除法，获取商</td>
</tr>
<tr>
<td>public BigInteger[] divideAndRemainder(BigInteger val)</td>
<td>除法，获取商和余数，返回数组，0索引的为商，1索引的为余数</td>
</tr>
<tr>
<td>public bollean equals(Object x)</td>
<td>比较是否相同，比较的是属性值</td>
</tr>
<tr>
<td>public BigInteger pow(int exponent)</td>
<td>次幂</td>
</tr>
<tr>
<td>public BigInteger max/min(BigInteger val)</td>
<td>返回较大值/较小值</td>
</tr>
<tr>
<td>public int inValue(BigInteger val)</td>
<td>转为int类型整数，超出范围数据有误</td>
</tr>
</tbody>
</table>
<h5 id="3-底层存储方式">3.底层存储方式</h5>
<ul>
<li>先把一个大整数转化成补码</li>
<li>再把补码每32位分为一组</li>
<li>再把每一组转成各自的十进制</li>
<li>再按顺序放到一个数组中
<ul>
<li>数组的最大长度的理论值是int的最大值：2147483647约为21亿</li>
<li>数组中的每一位能表示的数字范围：-2147483648~2147483647约为42亿</li>
<li>所以BigInteger能表示的最大数字为42亿的21亿次方
<ul>
<li>几乎是无限的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-BigDecimal">2.BigDecimal</h4>
<ul>
<li>计算机中用二进制存储小数通常需要很多位</li>
<li>而在Java中</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用字节数</th>
<th>总bit位数</th>
<th>小数部分bit位数</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4个字节</td>
<td>32个bit位</td>
<td>23个bit位</td>
</tr>
<tr>
<td>double</td>
<td>8个字节</td>
<td>64个bit位</td>
<td>52个bit位</td>
</tr>
</tbody>
</table>
<h5 id="1-作用">1.作用</h5>
<ul>
<li>用于小数的精确计算</li>
<li>用于表示很大的小数</li>
</ul>
<h5 id="2-创建对象">2.创建对象</h5>
<ul>
<li>通过传递double类型的小数来创建对象</li>
</ul>
<p># 可能不精确</p>
<ul>
<li>
<p>通过传递字符串表示的小数来创建对象</p>
</li>
<li>
<p>通过静态方法获取对象</p>
</li>
</ul>
<p># 如果要表示的数字没有超过double的范围，建议使用这种方法</p>
<p># 如果传递0~10之间的整数，包含0和10，那么方法会返回已经创建好的对象，不会new</p>
<h5 id="3-使用">3.使用</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static BigDecimal valueOf(double val)</td>
<td>获取对象</td>
</tr>
<tr>
<td>public BigDecimal add(BigDecimal val)</td>
<td>加法</td>
</tr>
<tr>
<td>public BigDecimal subtract(BigDecimal val)</td>
<td>减法</td>
</tr>
<tr>
<td>public BigDecimal multiply(BigDecimal val)</td>
<td>乘法</td>
</tr>
<tr>
<td>public BigDecimal divide(BigDecimal val)</td>
<td>除法</td>
</tr>
<tr>
<td>public BigDecimal divide(BigDecimal val,精确几位,舍入模式)</td>
<td>除法</td>
</tr>
</tbody>
</table>
<h5 id="4-底层存储方式">4.底层存储方式</h5>
<ul>
<li>将要存储的字符串形式的小数</li>
<li>先遍历每一个字符</li>
<li>然后将这些字符对应的ASCII码存储到数组中</li>
</ul>
<h4 id="6-正则表达式">6.正则表达式</h4>
<ul>
<li>用**.matches(“规则”)** 使用正则表达式</li>
</ul>
<h5 id="1-作用-2">1.作用</h5>
<ul>
<li>校验字符串是否满足规则</li>
<li>在一段文本中查找满足要求的内容</li>
</ul>
<h5 id="2-规则">2.规则</h5>
<p>字符类（只匹配一个字符）</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]</td>
<td>只能是a，b或c</td>
</tr>
<tr>
<td>[^abc]</td>
<td>除了a，b，c之外的任何字符</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>a到z A到Z</td>
</tr>
<tr>
<td>[a-d[m-p]]</td>
<td>a到d，或m到p</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[def]]</td>
<td>a-z和d，e，f的交集，即d，e，f</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[^bc]]</td>
<td>a-z和非bc的交集（等同于[ad-z]）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[^m-p]]</td>
<td>a到z和除了m到p的交集（等同于[a-lq-z]</td>
</tr>
</tbody>
</table>
<p>预定义字符（只匹配一个字符）</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任何字符</td>
</tr>
<tr>
<td>\d</td>
<td>一个数字[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字[^0-9]</td>
</tr>
<tr>
<td>\s</td>
<td>一个空白字符[\t\n\x08\f\r]</td>
</tr>
<tr>
<td>\S</td>
<td>非空白字符[^\s]</td>
</tr>
<tr>
<td>\w</td>
<td>[a-zA-A_0-9]英文，数字，下划线</td>
</tr>
<tr>
<td>\W</td>
<td>[^\w]一个非单词字符</td>
</tr>
</tbody>
</table>
<p># 用的时候在\前再加一个\</p>
<p>数量词</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>X?</td>
<td>X，一个或0次</td>
</tr>
<tr>
<td>X*</td>
<td>X，0次或多次</td>
</tr>
<tr>
<td>X+</td>
<td>X，一个或多次</td>
</tr>
<tr>
<td>X{n}</td>
<td>X，正好n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X，至少n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X，至少n次但不超过m次</td>
</tr>
</tbody>
</table>
<h5 id="3-分组">3.分组</h5>
<ul>
<li>用()将规则划分组</li>
<li>以左括号为基准，最左为第一组</li>
</ul>
<h5 id="4-捕获分组">4.捕获分组</h5>
<ul>
<li>后续还要使用本组的数据</li>
<li>在正则内部：
<ul>
<li><strong>\\组号</strong></li>
</ul>
</li>
<li>在正则外部：
<ul>
<li><strong>$组号</strong></li>
</ul>
</li>
</ul>
<h5 id="5-非捕获分组">5.非捕获分组</h5>
<ul>
<li>分组后不需要再使用本组数据，仅仅将数据括起来</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>(?:正则)</td>
<td>获取所有</td>
</tr>
<tr>
<td>(?=正则)</td>
<td>获取前面部分</td>
</tr>
<tr>
<td>(?!正则)</td>
<td>获取不是指定内容的前面部分</td>
</tr>
</tbody>
</table>
<p># 非捕获分组是不会占用组号的</p>
<h4 id="7-JDK7以前时间相关类">7.JDK7以前时间相关类</h4>
<h5 id="1-Date时间类">1.Date时间类</h5>
<ul>
<li>JDK写好的JavaBean类，用来描述时间，精确到毫秒</li>
<li>利用空参构造创建的对象，默认表示系统当前时间</li>
<li>利用有参构造创建的对象，表示指定时间</li>
<li>修改时间对象中的毫秒值
<ul>
<li>setTime(毫秒值);</li>
</ul>
</li>
<li>获取时间对象中的毫秒值
<ul>
<li>getTime();</li>
</ul>
</li>
</ul>
<h5 id="2-SimpleDateFormat类">2.SimpleDateFormat类</h5>
<ul>
<li>格式化：
<ul>
<li>将时间转化形式</li>
</ul>
</li>
<li>解析：
<ul>
<li>将字符串表示的时间变成Date对象</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public SimpleDateFormat()</td>
<td>构造一个SimpleDateFormat，使用默认格式</td>
</tr>
<tr>
<td>public SimpleDateFormat(String pattern)</td>
<td>构造一个SimpleDateFormat，使用指定格式</td>
</tr>
</tbody>
</table>
<p># 其中格式例如：yyyy-MM-dd HH:mm:ss或者yyyy年MM月dd日 HH时mm分ss秒</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public final String format(Date date)</td>
<td>格式化（日期对象转化为字符串）</td>
</tr>
<tr>
<td>public Date parse(String source)</td>
<td>解析（字符串转化为日期对象）</td>
</tr>
</tbody>
</table>
<h5 id="3-Calendar">3.Calendar</h5>
<ul>
<li>
<p>代表系统当前时间的日历对象，可以单独修改，获取时间中的年月日</p>
</li>
<li>
<p>是一个抽象类，不能直接创建对象</p>
</li>
<li>
<p>获取Calendar日历类对象的方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static Calendar getInstance()</td>
<td>获取当前时间的日历对象</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public final Date getTime()</td>
<td>获取日期对象</td>
</tr>
<tr>
<td>public final setTime(Date date)</td>
<td>给日历设置日期对象</td>
</tr>
<tr>
<td>public long getTimeInMillis()</td>
<td>拿到时间毫秒值</td>
</tr>
<tr>
<td>public void setTimeInMillis(long millis)</td>
<td>给日历设置时间毫秒值</td>
</tr>
<tr>
<td>public int get(int field)</td>
<td>取日历中的某个字段信息</td>
</tr>
<tr>
<td>public void set(int field,int value)</td>
<td>修改日历的某个字段信息</td>
</tr>
<tr>
<td>public void add(int field,int amount)</td>
<td>为某个字段增加/减少指定的值</td>
</tr>
</tbody>
</table>
<h4 id="8-JDK8新增时间相关类">8.JDK8新增时间相关类</h4>
<ul>
<li>原有的时间对象是不变的</li>
</ul>
<h5 id="1-Date时间类-2">1.Date时间类</h5>
<ul>
<li>ZoneId：时区</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static Set<String> getAvailableZoneIds()</td>
<td>获取Java中支持的所有时区</td>
</tr>
<tr>
<td>static ZoneId systemDefault()</td>
<td>获取系统默认时区</td>
</tr>
<tr>
<td>static ZoneId of(String zonId)</td>
<td>获取一个指定时区</td>
</tr>
</tbody>
</table>
<ul>
<li>Instant：时间戳</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static Instant now()</td>
<td>获取当前时间的Instant对象（标准时间）</td>
</tr>
<tr>
<td>static Instant ofxxxx(long epochMilli)</td>
<td>根据（秒/毫秒/纳秒）获取Instant对象</td>
</tr>
<tr>
<td>ZonedDate atZone(ZoneId zone)</td>
<td>指定时区</td>
</tr>
<tr>
<td>boolean isxxxx(Instant otherInstant)</td>
<td>判断系列的方法</td>
</tr>
<tr>
<td>Instatnt minusxxx(long millisToSubtract)</td>
<td>减少时间系列的方法</td>
</tr>
<tr>
<td>Instant pulsxxx(long millisToSubstract)</td>
<td>增加时间系列的方法</td>
</tr>
</tbody>
</table>
<p># 其中xxx是Years/Days/Hours/Minutes/Nanos/Seconds/Weeks</p>
<ul>
<li>ZoneDateTime：带时区的时间</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static ZonedDateTime now()</td>
<td>获取当前时间的ZonedDateTime对象</td>
</tr>
<tr>
<td>static ZonedDateTime ofxxxx(……)</td>
<td>获取指定时间的ZonedDateTime对象</td>
</tr>
<tr>
<td>ZonedDateTime withxxx(时间)</td>
<td>修改时间系列的方法</td>
</tr>
<tr>
<td>ZonedDateTime minusxxx(时间)</td>
<td>减少时间系列的方法</td>
</tr>
<tr>
<td>ZonedDateTime plusxxx(时间)</td>
<td>增加时间系列的方法</td>
</tr>
</tbody>
</table>
<h5 id="2-SimpleDateFormat类-2">2.SimpleDateFormat类</h5>
<ul>
<li>DateTimeFoemat：用于时间的格式化和解析</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static DateTimeFormatter ofPattern(格式)</td>
<td>获取格式对象</td>
</tr>
<tr>
<td>String format(时间对象)</td>
<td>按照指定方式格式化</td>
</tr>
</tbody>
</table>
<h5 id="3-Calendar-2">3.Calendar</h5>
<ul>
<li>LocalDate：年月日</li>
<li>LocalTime：时分秒</li>
<li>LocalDateTime：年月日时分秒</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static xxx now()</td>
<td>获取当前时间的对象</td>
</tr>
<tr>
<td>static xxx of(……)</td>
<td>获取指定时间的对象</td>
</tr>
<tr>
<td>get开头的方法</td>
<td>获取日历中的年月日时分秒风信息</td>
</tr>
<tr>
<td>isBefore，isAfter</td>
<td>比较两个LocalDate</td>
</tr>
<tr>
<td>with开头的</td>
<td>修改时间系列的方法</td>
</tr>
<tr>
<td>minus开头的</td>
<td>减少时间系列的方法</td>
</tr>
<tr>
<td>plus开头的</td>
<td>增加时间系列的方法</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public LocalDate toLoacalDate()</td>
<td>LocalDateTime转换成一个LocalDate对象</td>
</tr>
<tr>
<td>public LocalTime toLocalTime()</td>
<td>LocalDateTime转换成一个LocalTime对象</td>
</tr>
</tbody>
</table>
<h5 id="4-工具类">4.工具类</h5>
<ul>
<li>Duration：时间间隔（秒，纳秒）</li>
<li>Period：时间间隔（年月日）</li>
<li>ChronnUnit：时间间隔（所有单位）</li>
</ul>
<h4 id="9-包装类">9.包装类</h4>
<ul>
<li>
<p>基本数据类型对应的引用类型</p>
</li>
<li>
<p>基本数据类型中int对应Integer，char对应Character，其余数据类型都将首字母大写</p>
</li>
<li>
<p>在JDK5提出一个机制：</p>
<ul>
<li>自动装箱
<ul>
<li>把基本数据类型自动的变成其对应的包装类</li>
</ul>
</li>
<li>自动拆箱
<ul>
<li>把包装类自动的变成其对应的基本数据类型</li>
</ul>
</li>
</ul>
</li>
<li>
<p>int和Integer可以看作一个东西，在内部会自动转换</p>
</li>
<li>
<p>Integer成员方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static String toBinaryString(int i)</td>
<td>得到二进制</td>
</tr>
<tr>
<td>public static String toOctalString(int i)</td>
<td>得到八进制</td>
</tr>
<tr>
<td>public static String toHexString(int i)</td>
<td>得到十六进制</td>
</tr>
<tr>
<td>public static int paresInt(String s)</td>
<td>把字符串类型的整数转换为int类型的整数</td>
</tr>
</tbody>
</table>
<p>​</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
</search>

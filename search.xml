<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CQB理论</title>
    <url>/2025/10/03/CQB%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="CQB理论">CQB理论</h2>
<h2 id="1-认识CQB">1.认识CQB</h2>
<h3 id="1-概述">1.概述</h3>
<ul>
<li>英文中<strong>close quarter battle</strong>的简写</li>
<li>即<strong>室内近距离</strong> 作战</li>
</ul>
<h3 id="2-特点">2.特点</h3>
<ul>
<li>由于和敌人是保持一个极近的距离，所以双方开火都能以很<strong>快</strong> ，很<strong>密集</strong> 的火力快速覆盖敌人
<ul>
<li>近距离</li>
<li>激烈性</li>
<li>短时性</li>
</ul>
</li>
<li>是特种作战</li>
<li>具有高度独立性</li>
</ul>
<p># 这里是CQB的特点，而不是CQB战术的特点</p>
<h3 id="3-驱动CQB的底层逻辑">3.驱动CQB的底层逻辑</h3>
<h4 id="1-具有十分明确的目的性">1.具有十分明确的目的性</h4>
<ul>
<li>
<p>其目的包括：</p>
<ul>
<li>
<p>解救人质</p>
</li>
<li>
<p>获取某些重要的情报</p>
</li>
<li>
<p>保证公共财产的安全</p>
</li>
</ul>
</li>
<li>
<p>这就解释了为什么CQB如此危险但仍然存在，没有被大规模的火力压制取代</p>
</li>
<li>
<p>所以CQB的本质上是一种<strong>限制性</strong> 战斗</p>
</li>
</ul>
<h4 id="2-严谨性">2.严谨性</h4>
<ul>
<li>在实际战斗中会面对各种各样的情况，对于各种威胁
<ul>
<li>要从实际的角度出发</li>
<li>站在客观的角度上分析问题和解决问题</li>
<li>因地制宜地去选择装备和战术</li>
<li>警惕教条主义和经验主义</li>
</ul>
</li>
</ul>
<h2 id="2-CQB战术">2.CQB战术</h2>
<ul>
<li>
<p>战术即战斗方法</p>
</li>
<li>
<p>CQB战术即是室内近距离战斗方法</p>
</li>
<li>
<p>CQB战术共有两个分类，即CQB战术的两大核心</p>
<ul>
<li><strong>迅猛</strong></li>
<li><strong>静默</strong></li>
</ul>
</li>
</ul>
<h3 id="1-特点">1.特点</h3>
<h4 id="1-隐蔽性">1.隐蔽性</h4>
<ul>
<li>例如：在敌人未知我方要进攻时
<ul>
<li>迅猛：
<ul>
<li>易引起敌方警觉</li>
</ul>
</li>
<li>静默：
<ul>
<li>不易被发现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-机动性（灵活性）">2.机动性（灵活性）</h4>
<ul>
<li>例如：在敌方已知我方要进攻时
<ul>
<li>静默：
<ul>
<li>移动缓慢，易被敌方集火</li>
</ul>
</li>
<li>迅猛：
<ul>
<li>可以使用火力压制，进行快速突入</li>
</ul>
</li>
</ul>
</li>
<li>但是这种情况的问题在于，敌人掌握我方行动。我方失去行动突然性。
<ul>
<li>突然性为<strong>硬性指标</strong></li>
<li>优秀的CQB战术是海浪式的进攻
<ul>
<li>在一波进攻结束后</li>
<li>队伍进入隐蔽状态，即重新获得突然性</li>
<li>再进行下一波的进攻</li>
</ul>
</li>
</ul>
</li>
<li>缺少了信息不对称的优势，属于巨大失误</li>
</ul>
<h4 id="3-时效性">3.时效性</h4>
<ul>
<li>例如：炸弹爆炸场景
<ul>
<li>迅猛：
<ul>
<li>易被敌方发现，导致炸弹提取爆炸</li>
</ul>
</li>
<li>静默：
<ul>
<li>不易被敌方发现，但行动缓慢，可能导致无法在爆炸前完成拆除任务</li>
</ul>
</li>
<li>两者相结合：
<ul>
<li>以静默靠近敌人，再以迅猛清除所有敌人</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-CQB流程">3.CQB流程</h2>
<h3 id="1-前期">1.前期</h3>
<ul>
<li>
<p>即获得任务并且已知任务目标</p>
</li>
<li>
<p>对任务有初步的了解</p>
</li>
<li>
<p>根据对目标的了解</p>
<ul>
<li>针对目标进行搜索信息
<ul>
<li>搜集到的信息在进一步的检索后，可能会获得潜在信息</li>
</ul>
</li>
</ul>
</li>
<li>
<p>例如：匪徒正在抢劫一个银行</p>
<ul>
<li>首先银行是一个公共场所</li>
<li>匪徒不可能对其长期占有，对其进行过非法改装的可能性较小</li>
<li>即银行建筑图可以被信任</li>
</ul>
</li>
</ul>
<h4 id="基础信息总汇">基础信息总汇</h4>
<ul>
<li>信息四要素</li>
</ul>
<h5 id="1-时间">1.时间</h5>
<ul>
<li>光照角度</li>
<li>照明情况</li>
<li>人流情况（早晚高峰）</li>
</ul>
<h5 id="2-地点">2.地点</h5>
<ul>
<li>改造情况</li>
<li>地图要求</li>
<li>战前规划</li>
</ul>
<h5 id="3-人物">3.人物</h5>
<ul>
<li>训练经验</li>
<li>武装情况</li>
</ul>
<h5 id="4-动机">4.动机</h5>
<ul>
<li>敌人的犯罪目标</li>
</ul>
<p># 可以有针对性的制定相应的交火规则以及开火规则限制</p>
<h3 id="2-中期">2.中期</h3>
<h4 id="1-瞄准">1.瞄准</h4>
<ul>
<li>在行动中严禁瞄准敌人头部（除非敌人挟持人质）</li>
<li>只能瞄准胸口
<ul>
<li>问题：
<ul>
<li>射击精度不够，无法一击毙命</li>
<li>瞄准头部会导致手臂下的部分视野缺失</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-死亡漏斗">2.死亡漏斗</h4>
<ul>
<li>
<p>在门前后150度左右的扇形区域</p>
</li>
<li>
<p>进攻方在漏斗里面会暴露自己的身体位置和信息的</p>
</li>
<li>
<p>因此会有三点要求</p>
<ul>
<li>在进门之前尽量减少身体在漏斗区域的暴露</li>
<li>进门的时候<strong>不可以在门口逗留</strong></li>
<li>不要随便越过漏斗，如果要越过漏斗，必须枪指着漏斗越过</li>
</ul>
<p># 在非必要情况下，一般不会经常越过漏斗</p>
</li>
</ul>
<h4 id="3-强弱原则">3.强弱原则</h4>
<h5 id="1-强弱手">1.强弱手</h5>
<ul>
<li>
<p>队员对于自己的控制</p>
</li>
<li>
<p>利手则为强手</p>
</li>
</ul>
<h5 id="2-强弱手位">2.强弱手位</h5>
<ul>
<li>
<p>整个队伍对于进攻的状态</p>
</li>
<li>
<p>利于进攻的位置即为强手位</p>
</li>
<li>
<p><strong>判断强弱手位原则</strong> ：</p>
<ul>
<li>
<p>第一原则：</p>
<ul>
<li>
<p>视野原则：</p>
<ul>
<li>具有<strong>更大视野</strong> 的为强手位</li>
</ul>
<p># 这个原则可以解决大部分的强弱手位判断，有极强的适用性</p>
</li>
</ul>
</li>
<li>
<p>第二原则：</p>
<ul>
<li>视角原则：
<ul>
<li>进攻动作让枪械在更小的范围内更精确的锁定敌人</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第三原则：</p>
<ul>
<li>
<p>外开原则：</p>
<ul>
<li>即门是向外开的，那么开门的人就是弱手位</li>
</ul>
<p># 但如果门可以打开至完全和墙贴合，那么可以视为没有门</p>
</li>
</ul>
</li>
</ul>
<p># 这些原则都是建立在没有使用任何战术道具的前提上，如果涉及到就要重新分配位置</p>
</li>
<li>
<p><strong>单开门双纵队交叉进门区分强弱手位及具体站位</strong></p>
</li>
<li>
<p>强手位先进门，弱手位后进门</p>
<ul>
<li>
<p>单开门：</p>
<ul>
<li>
<p>门轴处为<strong>强手位</strong></p>
<ul>
<li>在门外列队时，最外侧的脚不可以超过门轴，保证大部分身体有掩体</li>
<li>离墙半个身位的距离
<ul>
<li>防止敌人穿射</li>
<li>防止单片弹射</li>
</ul>
</li>
<li>斜45度架设门内区域</li>
<li>完成和门有关的一切动作</li>
<li>在开小门后
<ul>
<li>先观察门后是否安全</li>
<li>查看是否有绊线，选择强手位或弱手位拆除
<ul>
<li>弱手位拆绊线，可以保证身体大部分处于掩体，但需要强手位提示绊线位置</li>
<li>强手位拆绊线则需要，让队友架设强手位的前方</li>
</ul>
</li>
</ul>
</li>
<li>等待弱手位信号，再大开门</li>
<li>放弃45度架设位，回退至安全角</li>
<li>再从安全角慢切至90度</li>
<li>确认安全后，再回到45度架设，进行决策</li>
<li>准备进攻前先抬头示意队友并等待队友抬头回应同意</li>
<li>按照强手先出的顺序收枪移动进门</li>
</ul>
<p># 一定要先收枪再进门</p>
<ul>
<li>直线进门</li>
</ul>
</li>
<li>
<p>门把手位为<strong>弱手位</strong></p>
<ul>
<li>只负责架设，和拆除绊线</li>
<li>完成开小门和拆除绊线后
<ul>
<li>弱手位抬头给出信号，示意强手位打开门
<ul>
<li>即弱手位来协同开门时间</li>
</ul>
</li>
</ul>
</li>
<li>放弃45度架设位，回退至安全角</li>
<li>再从安全角慢切至90度</li>
<li>确认安全后，再回到45度架设，进行决策</li>
<li>准备进攻前先抬头示意队友并等待队友抬头回应同意</li>
<li>按照弱手后出的顺序收枪移动进门</li>
</ul>
<p># 一定要先收枪再进门</p>
<ul>
<li>直线进门</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p># 在开门后，如果弱手位获取到了任何不安全的信息，那么弱手位就变成强手位</p>
<p><strong>单开门单纵队交替进入</strong></p>
<ul>
<li>
<p>适用于两侧队员都在门的一侧就位</p>
</li>
<li>
<p>或门的两侧任意一侧没有位置站</p>
</li>
<li>
<p>在第一个的尖兵：</p>
<ul>
<li>先开小门确认门后安全</li>
<li>检察绊线</li>
<li>大开门</li>
<li>观察45度后立马再观察90</li>
<li>全都安全后收枪</li>
<li>然后往左侧或右侧钩进门，向观察过的位置的另一侧（即危险区域）</li>
</ul>
</li>
<li>
<p>二号位：</p>
<ul>
<li>在尖兵钩进门之后，立马跟进</li>
<li>观察门后以及尖兵后</li>
</ul>
</li>
</ul>
<p><strong>双开门双纵队双勾进入</strong></p>
<ul>
<li>适用于能够容纳两个人同时进入的门的区域</li>
<li>这种情况就不区分强弱手位</li>
<li>门大开后左侧队员钩左，右侧队员钩右</li>
<li>两侧先45度架设门内</li>
<li>由左侧队员控门
<ul>
<li>先开自己一侧的门</li>
<li>观察是否有敌人</li>
<li>再将门切换到对侧
<ul>
<li>由右侧观察是否有敌人</li>
</ul>
</li>
<li>等待队员抬头示意</li>
<li>大开门</li>
<li>由45度顺着门大开的方向转到90度观察</li>
<li>做决策进门</li>
</ul>
</li>
<li>右侧队员等待左侧队员开门
<ul>
<li>门切换至右侧时观察门后情况</li>
<li>抬头示意</li>
<li>等待门大开后由45度顺着门大开的方向转到90度观察</li>
<li>做决策进门</li>
</ul>
</li>
</ul>
<h4 id="4-责任区间">4.责任区间</h4>
<ul>
<li>
<p>为了以最快的速度全面控制和警戒</p>
</li>
<li>
<p>责任区间不能重叠</p>
</li>
<li>
<p>如果在移动后可能会导致越过队友枪线</p>
</li>
<li>
<p>则需要更改责任区间</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CQB</category>
      </categories>
      <tags>
        <tag>CQB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2025/08/27/MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>MySQL基础</h1>
<h2 id="1-启动和关闭">1. 启动和关闭</h2>
<h3 id="1-cmd">1.cmd</h3>
<ul>
<li>
<p>win加r进入运行输入cmd，ctrl加shift加enter以管理员模式运行</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> mysql80</span><br></pre></td></tr></table></figure>
<p>其中<strong>mysql80</strong> 为服务名，同样以</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> stop mysql80</span><br></pre></td></tr></table></figure>
<p>结束运行。</p>
</li>
</ul>
<h3 id="2-服务">2.服务</h3>
<ul>
<li>win加r进入运行输入<strong>services.msc</strong> ，进入后找到<strong>MySQL80</strong> 右键运行或停止。</li>
</ul>
<h2 id="2-客户端连接">2. 客户端连接</h2>
<h3 id="1-MySQL提供的工具">1.MySQL提供的工具</h3>
<ul>
<li>进入后直接输入密码连接。</li>
</ul>
<h3 id="2-cmd">2.cmd</h3>
<ul>
<li>
<p>win加r进入运行输入cmd，ctrl加shift加enter以管理员模式运行，（这里已经将mysql添加到环境变量，可以在任意路径下运行）输入</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysql -h <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> -P <span class="number">3306</span> -u root -p</span><br></pre></td></tr></table></figure>
<p>，其中-h后面跟指定地址，-<strong>P</strong> （大写）后跟指定端口，（这两个可以省略），-u后跟指定用户，以root用户进行连接，-p指定密码。</p>
</li>
</ul>
<h2 id="3-数据库概念及模型">3. 数据库概念及模型</h2>
<h3 id="1-概念">1.概念</h3>
<ul>
<li>关系型数据库（RDBMS)
<ul>
<li>由二维表组成，以关系型模型为基础</li>
</ul>
</li>
<li>使用表存储数据，格式统一，便于维护</li>
<li>使用SQL语句进行操作</li>
</ul>
<h3 id="2-数据模型">2.数据模型</h3>
<ol>
<li>
<p>客户端连接MySQL的数据库管理系统DBMS</p>
</li>
<li>
<p>使用SQL语句通过数据库管理系统来创建数据库</p>
</li>
<li>
<p>使用SQL语句在指定的数据库中创建多张表</p>
</li>
<li>
<p>单个数据库服务可以创建多个数据库</p>
</li>
<li>
<p>在表中存储数据</p>
</li>
</ol>
<h2 id="4-SQL语句">4.SQL语句</h2>
<h3 id="1-通用语法">1.通用语法</h3>
<ul>
<li>可以单行或多行书写，和c一样以分号结束</li>
<li>语句中可以用空格和缩进使其美观且不影响</li>
<li>SQL语句不区分大小写，关键字建议用大写</li>
<li>注释
<ul>
<li>单行：-- 或  #</li>
<li>多行：/*     */（同c）</li>
</ul>
</li>
</ul>
<h3 id="2-SQL分类">2.SQL分类</h3>
<h4 id="1-DDL-数据定义语言，用来定义数据库对象（数据库，表，字段）">1.DDL 数据定义语言，用来定义数据库对象（数据库，表，字段）</h4>
<h5 id="1-数据库操作">1.数据库操作</h5>
<p>1.查询</p>
<ul>
<li>
<p>查询所有数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases；</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询当前所处数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database (if <span class="keyword">not</span> <span class="keyword">exists</span> #数据库不存在时则创建，存在时无报错) 数据库名称 （<span class="keyword">default</span> charset 字符集 #例如utf8)  (<span class="keyword">collate</span> 排序规则) ；</span><br></pre></td></tr></table></figure>
<p>3.删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database（if <span class="keyword">exists</span>）数据库名；</span><br></pre></td></tr></table></figure>
<p>4.使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use 数据库名；</span><br></pre></td></tr></table></figure>
<p>#进入一个数据库</p>
<h5 id="2-表操作">2.表操作</h5>
<h6 id="1-查询">1.查询</h6>
<p>1.查询<strong>当前</strong> 数据库中所有表（需要先进入一个数据库）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables；</span><br></pre></td></tr></table></figure>
<p>2.查询表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名；</span><br></pre></td></tr></table></figure>
<p>3.查询指定表的建表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create table</span> 表名；</span><br></pre></td></tr></table></figure>
<h6 id="2-创建">2. 创建</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> tables 表名(</span><br><span class="line"></span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>的类型（comment 字段<span class="number">1</span>的注释）,      #注意逗号</span><br><span class="line"></span><br><span class="line">	字段<span class="number">2</span> 字段<span class="number">2</span>的类型（comment 字段<span class="number">2</span>的注释）,</span><br><span class="line"></span><br><span class="line">	........</span><br><span class="line"></span><br><span class="line">)（comment 表注释）；</span><br></pre></td></tr></table></figure>
<h6 id="3-修改">3.修改</h6>
<p>1.添加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add</span> 字段名 类型（长度） （comment 注释）（约束）;</span><br></pre></td></tr></table></figure>
<p>2.修改数据类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 modify 字段名 新数据类型（长度）;</span><br></pre></td></tr></table></figure>
<p>3.修改字段名和字段类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 change 旧字段名 新字段名 类型(长度) （comment 注释）（约束）;</span><br></pre></td></tr></table></figure>
<p>4.删除字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> 字段名;</span><br></pre></td></tr></table></figure>
<p>5.修改表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 remane <span class="keyword">to</span> 新表名；</span><br></pre></td></tr></table></figure>
<h6 id="4-删除">4.删除</h6>
<p>1.删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> （if <span class="keyword">exists</span>） 表名；</span><br></pre></td></tr></table></figure>
<p>2.删除指定表，并重新创建该表 （保留表结构，但是其中数据删除）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名；</span><br></pre></td></tr></table></figure>
<h5 id="3-数据类型">3.数据类型</h5>
<h6 id="1-数值类型">1.数值类型</h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>有符号（signed）范围</th>
<th>无符号（unsigned）范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>tinyint</strong></td>
<td>1byte</td>
<td>(-128,127)</td>
<td>(0,255)</td>
</tr>
<tr>
<td># <strong>适用例如年龄 age TINYINT UNSIGNED (因为年龄只为正整数，所以用无符号的TINYINT型)</strong></td>
<td># ** 如果储存的是01，那么最终查询出来的也是1，只有用字符串‘01’，最后查询出来的才是01**</td>
<td></td>
<td></td>
</tr>
<tr>
<td>smallint</td>
<td>2bytes</td>
<td>(-32768,32767)</td>
<td>(0,65535)</td>
</tr>
<tr>
<td>mediumint</td>
<td>3bytes</td>
<td>(-8388608,8388607)</td>
<td>(0,16777215)</td>
</tr>
<tr>
<td>int或integer</td>
<td>4bytes</td>
<td>(-2147483648,2147483647)</td>
<td>(0,4294967295)</td>
</tr>
<tr>
<td>bigint</td>
<td>8bytes</td>
<td>(-2^63,(2^63)-1)</td>
<td>(0,(2^64)-1)</td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>4bytes</td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>与double相比较内存小运算快</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>double</strong></td>
<td>8bytes</td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>适用例如分数(一百分制)   score double(4,1) 但是更适合用float</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>decimal</td>
<td>依赖于M(精度)和D(标度)的值</td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>精度即为整个数的位数，标度为小数点位数，例如256.13精度为5，标度为2</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>float是单精度浮点数  double是双精度浮点数 decimal是以字符串形式储存的精确小数</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>#<strong>float 和 double都是二进制近似计算，计算可能有舍入误差，且有精度范围，但decimal可自定义精度精确小数，且为十进制计算完全精准，适用于财务货币等精确计算</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="2-字符串类型">2.字符串类型</h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>char</strong></td>
<td>0-255 bytes</td>
<td>定长** 字符串</td>
</tr>
<tr>
<td># <strong>char(10)数字为储存的最大字符数，存储十以内的字符都占用十个字符，未占用的用空格补位，如果删除所有字符串即用update修改值为‘ ’空字符串，显示会是空字符串，而不是null</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>varchar(10)会根据存储内容计算所要空间，因为要计算所以性能要比char差，但是存储空间利用率就高</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>varchar</strong></td>
<td>0-65536 bytes</td>
<td>** 变长**字符串</td>
</tr>
<tr>
<td>tinyblob</td>
<td>0-255 bytes</td>
<td>二进制数据</td>
</tr>
<tr>
<td>tinytext</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>blob</td>
<td>0-65535 bytes</td>
<td>二进制长文本</td>
</tr>
<tr>
<td>text</td>
<td>0-65535 bytes</td>
<td>长文本</td>
</tr>
<tr>
<td>mediumblob</td>
<td></td>
<td>二进制中等长度文本</td>
</tr>
<tr>
<td>mediumtext</td>
<td></td>
<td>中等长度文本</td>
</tr>
<tr>
<td>longblob</td>
<td></td>
<td>二进制极大文本</td>
</tr>
<tr>
<td>longtext</td>
<td></td>
<td>极大文本</td>
</tr>
</tbody>
</table>
<h6 id="6-日期类型">6.日期类型</h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>date</strong></td>
<td>3</td>
<td>1000-01-01至9999-12-31</td>
<td>YYYY-MM-DD</td>
</tr>
<tr>
<td># <strong>日期值</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>time</td>
<td>3</td>
<td>-838:59:59至838:59:59</td>
<td>HH:MM:SS</td>
</tr>
<tr>
<td># <strong>时间值或持续时间</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>year</td>
<td>1</td>
<td>1901至2155</td>
<td>YYYY</td>
</tr>
<tr>
<td># <strong>年份值</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>datetime</td>
<td>8</td>
<td>1000-01-01 00:00:00至9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
</tr>
<tr>
<td># <strong>混合日期和时间值</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-01-01 00:00:01至2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
</tr>
<tr>
<td># <strong>混合日期和时间值，时间戳</strong></td>
<td></td>
<td># ** 这个2038问题是时间戳导致的问题**</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="2-DML-数据操作语言，用来对数据库中的数据进行增删改">2.DML 数据操作语言，用来对数据库中的数据进行增删改</h4>
<h5 id="1-添加数据">1.添加数据</h5>
<h6 id="1-给指定字段添加数据">1.给指定字段添加数据</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 字段<span class="number">1</span>，字段<span class="number">2</span>，....... <span class="keyword">values</span> 值<span class="number">1</span>，值<span class="number">2</span>，........;</span><br></pre></td></tr></table></figure>
<p># 如果值是字符串或日期数据类型，则要加引号</p>
<h6 id="2-给全部字段添加数据">2.给全部字段添加数据</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 <span class="keyword">values</span> 值<span class="number">1</span>，值<span class="number">2</span>，........;</span><br></pre></td></tr></table></figure>
<p>#即值1对应字段1，值2对应字段2，…</p>
<h6 id="3-批量添加数据">3.批量添加数据</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 字段<span class="number">1</span>，字段<span class="number">2</span>，....... <span class="keyword">values</span> 值<span class="number">1</span>，值<span class="number">2</span>，........，值<span class="number">1</span>，值<span class="number">2</span>，........，值<span class="number">1</span>，值<span class="number">2</span>，........;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 <span class="keyword">values</span>  值<span class="number">1</span>，值<span class="number">2</span>，........，值<span class="number">1</span>，值<span class="number">2</span>，........，值<span class="number">1</span>，值<span class="number">2</span>，........;</span><br></pre></td></tr></table></figure>
<h6 id="2-修改数据">2.修改数据</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,字段名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,.........（<span class="keyword">where</span> 条件）;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这里的条件就是把某几个符合这个条件的数据修改，例如修改id为1的这一条数据的name，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> name<span class="operator">=</span>值<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>那么所有id为1的数据中的name都变为值1</p>
</li>
<li>
<p>如果不加where 条件则修改所有的name都变为值1，会警告</p>
</li>
<li>
<p>同样如果值是字符串或日期数据类型，则要加引号</p>
</li>
</ul>
<h6 id="3-删除数据">3.删除数据</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 （<span class="keyword">where</span> 条件）；</span><br></pre></td></tr></table></figure>
<ul>
<li>同样如果不加条件则删除所有数据</li>
<li>删除的不是某个字段而是整条数据</li>
<li>如果要删除某个字段的值则是要用<strong>update</strong> 来修改，字段=null</li>
</ul>
<h4 id="3-DQL-数据查询语言，用来查询数据库中表的记录">3.DQL 数据查询语言，用来查询数据库中表的记录</h4>
<h5 id="1-语法">1.语法</h5>
<ul>
<li><strong>select</strong> 字段列表</li>
<li><strong>from</strong> 表名列表</li>
<li><strong>where</strong> 条件列表</li>
<li><strong>group by</strong> 分组字段列表</li>
<li><strong>having</strong> 分组后条件列表</li>
<li><strong>order by</strong> 排序字段列表</li>
<li><strong>limit</strong> 分页参数</li>
</ul>
<h5 id="2-基本查询">2.基本查询</h5>
<h6 id="1-查询多个字段">1.查询多个字段</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> ，字段<span class="number">2</span>，字段<span class="number">3</span>,........<span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p>#记得加逗号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p>#  *指查询返回所有字段，尽量直接写出所有字段，提高可读性</p>
<h6 id="2-设置别名">2.设置别名</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> <span class="keyword">as</span> 别名<span class="number">1</span>，字段<span class="number">2</span> <span class="keyword">as</span> 别名<span class="number">2</span>，........<span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p># 这里as可以省略</p>
<ul>
<li>表名后面也可以设置别名</li>
</ul>
<h6 id="3-去除重复记录">3.去除重复记录</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段列表 <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p># 这里字段后面也可以加as来设置别名，同样可以省略</p>
<ul>
<li>纯数字别名必须加引号（单双都可以）但是最终查询出来的别名还是‘数字’</li>
</ul>
<h5 id="3-条件查询">3.条件查询</h5>
<h6 id="1-语法-2">1.语法</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件列表；</span><br></pre></td></tr></table></figure>
<ul>
<li>查询出来的符合条件的字段列表，如果用*来代替则查询出来的是符合条件的一整条数据</li>
</ul>
<h6 id="2-条件">2.条件</h6>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>and 或 &amp;&amp;</td>
<td>并且（多个条件同时成立）</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>or 或 ||</td>
<td>或者（任一条件成立）</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>not 或 !</td>
<td>非</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td></td>
<td></td>
</tr>
<tr>
<td>=</td>
<td>等于</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;&gt;或!=</td>
<td>不等于</td>
<td></td>
<td></td>
</tr>
<tr>
<td>between…and…</td>
<td>在某个范围内（包含最大和最小值）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>in(…)</td>
<td>在in后跟的列表中的数值满足其一即可</td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>例如select * from  newwork where age in (12,18,20) ;即查询年龄为12，18，20的整条数据</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>like 占位符</td>
<td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>例如select * from  newwork where name like ’</strong> __<strong>'；即查询名字为两个字符的整条数据，这里是两个下划线</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>例如select * from  newwork where card_id like ‘%9’;即查询身份证最后一位是9的整条数据</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td># <strong>也可以select * from  newwork where card_id like ‘%8_’;即查询倒数第二位是8的整条数据</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>is null</td>
<td>字段为null</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="4-分组查询">4.分组查询</h5>
<h6 id="1-语法-3">1.语法</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表<span class="number">1</span>，字段列表<span class="number">2</span>，... <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件 <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名<span class="number">1</span>，字段名<span class="number">2</span>,... <span class="keyword">having</span> 分组后过滤条件</span><br></pre></td></tr></table></figure>
<h6 id="2-where和having的区别">2.where和having的区别</h6>
<ul>
<li>执行时间：where在分组前使用，having在分组后使用对结果过滤</li>
<li>判断条件：where的条件不允许使用聚合函数，having可以</li>
</ul>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> gender,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> newwork <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br></pre></td></tr></table></figure>
<p>即统计所有数据中每种性别的个数，同时会显示性别</p>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> age <span class="keyword">from</span> newwork <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;___&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>
<p>即先筛选名字为三个字符串的，再按年龄分组</p>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> age,<span class="built_in">count</span>(age) <span class="keyword">from</span> newwork <span class="keyword">where</span> card_id <span class="keyword">like</span> <span class="string">&#x27;%9&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">having</span> <span class="built_in">count</span>(age)<span class="operator">&lt;</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>即分组前先查询身份证最后一位是9的，然后按年龄分组，最后having统计出所有年龄中相同年龄个数小于5个的个数</p>
<p># 一般查询的字段列表是聚合函数或者分组字段，查询其他会报错，禁用报错后也只会显示该类数据的第一个</p>
<p>#这里同样可以设置别名</p>
<h5 id="5-排序查询">5.排序查询</h5>
<h6 id="1-语法-4">1.语法</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式，字段<span class="number">2</span> 排序方式；</span><br></pre></td></tr></table></figure>
<h6 id="2-排序方式">2.排序方式</h6>
<ul>
<li>asc：升序（可省略）</li>
<li>desc：降序</li>
</ul>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> newwork <span class="keyword">order</span> <span class="keyword">by</span>  age <span class="keyword">asc</span>,id <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure>
<p>即所有数据先按年龄升序排序，有相同年龄的则按id数字降序排序</p>
<h6 id="3-注意">3.注意</h6>
<ul>
<li>多字段排序时，，当第一个字段值相同时，才会根据第二个字段进行排序</li>
</ul>
<h5 id="6-分页查询">6.分页查询</h5>
<h6 id="1-语法-5">1.语法</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 limit 起始索引，查询记录数；</span><br></pre></td></tr></table></figure>
<h6 id="2-注意">2.注意</h6>
<ul>
<li>起始索引从0开始，和数组一样，所以起始索引=（查询页码-1）* 每页记录数</li>
<li>不同数据库的分页查询不同，MySQL中是limit</li>
<li>起始索引为0，即查询第一页时可以省略起始索引</li>
<li>前面可以加where，order by，group by 。limit是再整个语句的最后使用</li>
</ul>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> newwork limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>即从第一页查询所有数据，每页3条数据</p>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> newwork limit <span class="number">5</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>即每页5条数据，从第二页开始查询</p>
<h5 id="7-执行顺序">7.执行顺序</h5>
<ul>
<li>1.from</li>
<li>2.where</li>
<li>3.group by</li>
<li>4.having</li>
<li>5.select</li>
<li>6.order by</li>
<li>7.limit</li>
</ul>
<p># 需要注意执行顺序，再设置别名，才能正常使用别名</p>
<h4 id="4-DCL-数据控制语言，用来创建数据库用户，控制访问权限">4.DCL 数据控制语言，用来创建数据库用户，控制访问权限</h4>
<h5 id="1-管理用户">1.管理用户</h5>
<h6 id="1-查询用户">1.查询用户</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mysql； #用户表存放在MySQL的mysql数据库中，所以要先进入这个数据库 </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>
<h6 id="2-创建用户">2.创建用户</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> ‘用户名’@‘主机名’ identified <span class="keyword">by</span> ‘密码’；</span><br></pre></td></tr></table></figure>
<h6 id="3-修改用户密码">3.修改用户密码</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> ‘用户名’@‘主机名’ identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> ‘新密码’；</span><br></pre></td></tr></table></figure>
<h6 id="4-删除用户">4.删除用户</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> ‘用户名’@‘主机名’；</span><br></pre></td></tr></table></figure>
<p># 主机名有localhost即本机，%即任意主机都可以访问此数据库</p>
<h5 id="2-权限控制">2.权限控制</h5>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>all，all privileges</td>
<td>所有权限</td>
</tr>
<tr>
<td>select</td>
<td>查询数据</td>
</tr>
<tr>
<td>insert</td>
<td>插入数据</td>
</tr>
<tr>
<td>update</td>
<td>修改数据</td>
</tr>
<tr>
<td>delete</td>
<td>删除数据</td>
</tr>
<tr>
<td>alter</td>
<td>修改表</td>
</tr>
<tr>
<td>drop</td>
<td>删除数据库/表/视图</td>
</tr>
<tr>
<td>create</td>
<td>创建数据库/表</td>
</tr>
</tbody>
</table>
<h6 id="1-查询权限">1.查询权限</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> ‘用户名’@‘主机名’；</span><br></pre></td></tr></table></figure>
<h6 id="2-授予权限">2.授予权限</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> ‘用户名’@‘主机名’；</span><br></pre></td></tr></table></figure>
<h6 id="3-撤销权限">3.撤销权限</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库.表名 <span class="keyword">from</span> ‘用户名’@‘主机名’；</span><br></pre></td></tr></table></figure>
<h6 id="4-注意">4.注意</h6>
<ul>
<li>数据库和表名可以为*</li>
<li>权限列表可以为多个权限，之间要加，隔开</li>
</ul>
<h2 id="5-函数">5.函数</h2>
<h3 id="1-聚合函数">1.聚合函数</h3>
<ul>
<li>将一列数据作为一个整体，进行纵向计算</li>
</ul>
<h4 id="1-常见聚合函数">1.常见聚合函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
<tr>
<td># null值不参与计算</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="2-语法">2.语法</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数(字段列表)  <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件；</span><br></pre></td></tr></table></figure>
<p># 这里的括号和前面的聚合函数间不能有空格</p>
<h3 id="2-字符串函数">2.字符串函数</h3>
<h4 id="1-常见字符串函数">1.常见字符串函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>concat(S1,S2,…Sn)</td>
<td>字符串拼接，将括号里的拼接成一个字符串</td>
</tr>
<tr>
<td>lower(str)</td>
<td>将字符串str全部转为小写</td>
</tr>
<tr>
<td>upper(str)</td>
<td>将字符串str全部转为大写</td>
</tr>
<tr>
<td>lpad(str,n,pad)</td>
<td>左填充，将字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>rpad(str,n,pad)</td>
<td>右填充，将字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td># n是指填充完的整个字符串为n个，当pad的长度大于n-原字符串长度时，只会填充pad的前n-原字符串长度个</td>
<td></td>
</tr>
<tr>
<td>trim(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>substring(str,start,len)</td>
<td>返回字符串str中从start位置起的len个长度的字符串</td>
</tr>
<tr>
<td># start是数字索引，但是这里的索引是从1开始的</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="3-数值函数">3.数值函数</h3>
<h4 id="1-常见数值函数">1.常见数值函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ceil(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>mod(x,y)</td>
<td>返回x/y的模（余数）</td>
</tr>
<tr>
<td>rand()</td>
<td>返回0-1内的随机数</td>
</tr>
<tr>
<td># 例如<strong>select lpad(round(rand()*1000000,0),6,0);</strong> 可以用作生成随机六位数验证码，即先用rand随机出数字再乘1000000，再用round去掉小数，lpad在左边补0</td>
<td></td>
</tr>
<tr>
<td>round(x,y)</td>
<td>求参数x的四舍五入值，保留y位小数</td>
</tr>
<tr>
<td># 例如<strong>select round(206.2658,2);</strong> 返回的值就是206.27</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="4-日期函数">4.日期函数</h3>
<h4 id="1-常见日期函数">1.常见日期函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>curdate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>curtime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>year(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td># 例如<strong>select  year(now());</strong></td>
<td></td>
</tr>
<tr>
<td>month(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>day(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>date_add(date,interval expr type)</td>
<td>返回一个日期或时间值加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td># 例如<strong>select date_add(now(),interval 70 day );</strong> 即当前时间向后推70天的日期和时间，这里interval是固定的，expr是间隔，type是时间类型</td>
<td></td>
</tr>
<tr>
<td>datediff(date1,date2)</td>
<td>返回起始时间date1和结束时间date2之间的天数</td>
</tr>
<tr>
<td># 返回的时间=date1-date2，所以可能会是负数</td>
<td></td>
</tr>
<tr>
<td># 例如<strong>select name,datediff(curdate(),enterdate) as ‘enterdate’ from newwork order by  enterdate desc;</strong> 即计算入职天数并设置其别名为enterdate，再按降序排序</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="5-流程函数">5.流程函数</h3>
<h4 id="1-常见的流程函数">1.常见的流程函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>if(value,t,f)</td>
<td>如果value为true则返回t，否则返回f</td>
</tr>
<tr>
<td>ifnull(value1,value2)</td>
<td>如果value1不为空，返回value1，否则value2</td>
</tr>
<tr>
<td>case when val1 then res1 else default end</td>
<td>如果val1为true，返回res1，…否则返回default</td>
</tr>
<tr>
<td># 例如<strong>select age,name,case when age &lt;18 then ‘y’ when age&gt;18 then ‘a’ else ‘e’ end from newwork;</strong> 即查询年龄在十八以下的为y，十八以上为a，其他为e 。同理可以用于判断成绩优良</td>
<td></td>
</tr>
<tr>
<td>case expr when val1 then res1 else default end</td>
<td>如果expr的值=val1，返回res1，否则default</td>
</tr>
<tr>
<td># 例如<strong>select name, age，case age when 20 then ‘t’ when 19 then ‘n’ end from newwork;</strong> 即查询年龄为20和19的分别返回t和n</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="6-约束">6.约束</h2>
<h3 id="1-概述">1.概述</h3>
<h4 id="1-概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据">1.概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据</h4>
<h4 id="2-目的：保证数据库中的数据的正确有效和完整性">2.目的：保证数据库中的数据的正确有效和完整性</h4>
<h4 id="3-分类：">3.分类：</h4>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>非空约束</td>
<td>限制改字段的数据不能为null</td>
<td>not null</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一，不重复的</td>
<td>unique</td>
</tr>
<tr>
<td>主约束条件</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>primary key</td>
</tr>
<tr>
<td>默认约束条件</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>default</td>
</tr>
<tr>
<td>检查约束</td>
<td>保证字段值满足某一个条件</td>
<td>check</td>
</tr>
<tr>
<td># 8.0.16后才支持检查约束</td>
<td></td>
<td></td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>
<td>foreign key</td>
</tr>
</tbody>
</table>
<h3 id="2-示例">2.示例</h3>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段类型</th>
<th>约束条件</th>
<th>约束关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>int</td>
<td>主键，并且主动增长</td>
<td>primary key，auto_increment</td>
</tr>
<tr>
<td>name</td>
<td>varchar（10）</td>
<td>不为空，并且唯一</td>
<td>not null，unique</td>
</tr>
<tr>
<td>age</td>
<td>int</td>
<td>大于0，并且小于等于120</td>
<td>check</td>
</tr>
<tr>
<td>status</td>
<td>char（1）</td>
<td>如果没有指定该值，默认为1</td>
<td>default</td>
</tr>
<tr>
<td>gender</td>
<td>char（1）</td>
<td>无</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> user1(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not null</span> <span class="keyword">unique</span> ,</span><br><span class="line">        age <span class="type">int</span> <span class="keyword">check</span> ( age<span class="operator">&gt;</span><span class="number">0</span> <span class="operator">&amp;&amp;</span> age<span class="operator">&lt;=</span><span class="number">120</span> ),</span><br><span class="line">        status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line">        gender <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">)comment <span class="string">&#x27;用于学习约束的用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>然后用 <strong>insert</strong> 向表中插入数据</p>
</li>
<li>
<p>注意：如果某一条插入的数据违反了约束那么是不会创建该数据的，但是会向数据库申请一个主键，所以会导致下一次创建数据的时候即使没有违反约束，也会跳过之前没有创建的数据的主键，产生跳号的现象</p>
</li>
<li>
<p>但是主键最核心的是其唯一性，而不是连续性，部分数据库中可以手动填空</p>
</li>
</ul>
<h3 id="3-外键约束">3.外键约束</h3>
<ul>
<li>概念：外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性</li>
</ul>
<h4 id="1-添加外键">1.添加外键</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line"></span><br><span class="line">	字段名 数据类型，</span><br><span class="line"></span><br><span class="line">	.......	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constraint</span> 外键名 <span class="keyword">foreign key</span> （外键字段名） <span class="keyword">references</span> 主表（主表列名）</span><br><span class="line"></span><br><span class="line">	);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名 <span class="keyword">foreign key</span> （外键字段名） <span class="keyword">references</span> 主表（主表列名）</span><br></pre></td></tr></table></figure>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> user1 <span class="keyword">add constraint</span> fk_user1_dept_id <span class="keyword">foreign key</span> (id_for_connent) <span class="keyword">references</span> dept (id);</span><br></pre></td></tr></table></figure>
<p>即将表user1中的id_for_connent与表dept中的id关联并把外键名设置为fk_user1_dept_id</p>
<ul>
<li>如果删除dept中的数据则会报错，以此来保证数据的完整性</li>
</ul>
<h4 id="2-删除外键">2.删除外键</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign key</span> 外键名；</span><br></pre></td></tr></table></figure>
<h4 id="3-删除-更新行为">3.删除/更新行为</h4>
<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no action</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，有则不允许删除/更新</td>
</tr>
<tr>
<td>restrict</td>
<td>同上（默认的）</td>
</tr>
<tr>
<td>cascade</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，有则删除/更新子表中的记录</td>
</tr>
<tr>
<td>set null</td>
<td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，有则设置子表中该外键为null</td>
</tr>
<tr>
<td># 前提是该外键允许取null</td>
<td></td>
</tr>
<tr>
<td>set default</td>
<td>父表有变更时，子表将外键列设置成一个默认的值（MySQL的lnnodb引擎不支持）</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名 <span class="keyword">foreign key</span> （外键字段） <span class="keyword">references</span> 主表名（主表字段名） <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade；</span><br></pre></td></tr></table></figure>
<p>#例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> user1 <span class="keyword">add constraint</span> fk_user1_name_dept_id <span class="keyword">foreign key</span> (id_for_connent) <span class="keyword">references</span> dept (id) <span class="keyword">on</span> <span class="keyword">UPDATE</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade ;</span><br></pre></td></tr></table></figure>
<p>即添加一个外键，并且设置为更新/删除时cascade级联，即对应的更新/删除。其中的cascade可以更换成其他行为</p>
<ul>
<li>这个语法不是直接修改而是创建外键并设定了属性</li>
</ul>
<h2 id="7-多表查询">7.多表查询</h2>
<h3 id="1-多表关系">1.多表关系</h3>
<h4 id="1-一对多（多对一）">1.一对多（多对一）</h4>
<ul>
<li>例如：一个部门可以有多个员工，但是一个员工只能对应一个部门、</li>
<li>实现：在多的一方建立外键，指向少的一方的主键</li>
</ul>
<h4 id="2-多对多">2.多对多</h4>
<ul>
<li>例如：一个学生可以选择多个课程，一门课程可以被多个学生选择</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name,s.no,c.name <span class="keyword">from</span> student.s,student_course sc,course c <span class="keyword">where</span> s.id<span class="operator">=</span>sc.studentid <span class="keyword">and</span> sc.courseid<span class="operator">=</span>c.id;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现：建立第三张中间表，中间表中要有两个外键，分别连接另外两张表的主键</li>
</ul>
<h4 id="3-一对一">3.一对一</h4>
<ul>
<li>例如：每个用户对应其用户信息</li>
<li>实现：<strong>在任意一表中加入外键，再关联到另一个表的主键</strong> ，但是外键要设置约束条件为唯一unique</li>
</ul>
<h3 id="2-多表查询概述">2.多表查询概述</h3>
<ul>
<li>
<p>概述：指从多张表中查询数据</p>
</li>
<li>
<p><strong>笛卡尔积</strong> ：笛卡尔乘积指的是，两个集合的所有组合情况，如果直接用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1,dept;</span><br></pre></td></tr></table></figure>
<p>来查询两张表就会出现笛卡尔积的情况，所以正常查询时可以使用where语句根据具体情况来消除无效的笛卡尔积</p>
</li>
<li>
<h4 id="分类">分类</h4>
</li>
<li>
<p>连接查询</p>
<ul>
<li>
<p>内连接：相当于查询A,B交集部分的数据</p>
</li>
<li>
<p>外连接：</p>
<ul>
<li>左外连接：查询<strong>左表</strong> 所有数据，以及两张表交集部分数据</li>
<li>右外连接：查询<strong>右表</strong> 所有数据，以及两张表交集部分数据</li>
</ul>
</li>
<li>
<p>自连接：当前表与自身的连接查询，自连接必须使用表的别名</p>
</li>
</ul>
</li>
<li>
<p>子查询</p>
</li>
</ul>
<h3 id="3-内连接">3.内连接</h3>
<h4 id="1-隐式内连接">1.隐式内连接</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">where</span> 条件...;</span><br></pre></td></tr></table></figure>
<p>#例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name,d.name <span class="keyword">from</span> user1 u，dept d <span class="keyword">where</span> u.id_for_connent<span class="operator">=</span>d.id;</span><br></pre></td></tr></table></figure>
<p>#注意字段名前面要用表名来限定是哪个表的字段</p>
<p>#可以设置别名，但是设置别名后就不能再使用表名</p>
<h4 id="2-显式内连接">2.显式内连接</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">inner</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 连接条件....;</span><br></pre></td></tr></table></figure>
<p># inner可以省略</p>
<p># 相当于where换成on</p>
<p># 连接条件后面可以再加where条件</p>
<h3 id="4-外连接">4.外连接</h3>
<h4 id="1-左外连接">1.左外连接</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure>
<p># outer可以省略</p>
<p># 查询的是左表即表1的所有数据，包含两个表的交集部分</p>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.<span class="operator">*</span>,d.name <span class="keyword">from</span> user1 u <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> u.id_for_connent<span class="operator">=</span>d.id;</span><br></pre></td></tr></table></figure>
<p>这样即使user1中有部分数据没有与dept中的关联也可以被查询出来</p>
<h4 id="2-右外连接">2.右外连接</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure>
<p># outer可以省略</p>
<p># 查询的是右表即表2的所有数据，包含两个表的交集部分</p>
<p># 可以通过交换两个表名来实现右外连接和左外连接的转换，通常使用左外连接</p>
<h3 id="5-自连接">5.自连接</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> 别名<span class="number">1</span> <span class="keyword">join</span> 表<span class="number">1</span> 别名<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure>
<ul>
<li>自连接可以是内连接，也可以是外连接</li>
</ul>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name,u1.name <span class="keyword">from</span> user1 u ，<span class="keyword">user</span> u1 <span class="keyword">where</span> u.manager_id<span class="operator">=</span>u1.id;</span><br></pre></td></tr></table></figure>
<p># 在一张公司员工表中manager_id表示某一员工的领导的id，这样可以查询出员工的领导是谁</p>
<p># 这里用的是内连接，这样就不会在员工那一栏显示领导，因为领导没有领导，可以用外连接，就能在员工栏显示出领导，领导栏就会显示null</p>
<p># 将一张表视为两张</p>
<h3 id="6-联合查询">6.联合查询</h3>
<ul>
<li>就是把多次查询的结果合并，形成一个新的查询结果集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1.</span>..      #省略号中可以用<span class="keyword">where</span>条件</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span>      				   #<span class="keyword">all</span>可以省略，省略后会去除重复的数据</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">2.</span>..；    #省略号中可以用<span class="keyword">where</span>条件</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>这是一个完整的语句可以将上下两个结果直接合并</strong></li>
</ul>
<p># 注意：上下两个字段的列数和字段类型必须一致，否则会报错</p>
<h3 id="7-子查询">7.子查询</h3>
<ul>
<li>
<p>概念：SQL语句中嵌套select语句，称为子查询（嵌套查询）</p>
</li>
<li>
<p>例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> column1<span class="operator">=</span>（<span class="keyword">select</span> column1 <span class="keyword">from</span> 表<span class="number">2</span>）；</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其中<strong>select column1 from 表2</strong> 就是子查询，其他的外部语句可以是insert/delete/select中任一</p>
</li>
<li>
<p>根据子查询结果不同，可以分为</p>
<ul>
<li>
<p>标量子查询（子查询结果为单个值）</p>
</li>
<li>
<p>列子查询（查询结果为一列）</p>
</li>
<li>
<p>行子查询（查询结果为一行）</p>
</li>
<li>
<p>表子查询（子查询结果为多行多列）</p>
</li>
</ul>
</li>
<li>
<p>根据子查询位置不同，又分为</p>
<ul>
<li>where之后</li>
<li>from之后</li>
<li>select之后</li>
</ul>
</li>
</ul>
<h4 id="1-标量子查询">1.标量子查询</h4>
<ul>
<li>返回结果是单个值（数字，字符串，日期等）</li>
<li>常用操作符：=,&lt;&gt;,&gt;,&gt;=,&lt;，&lt;=</li>
</ul>
<p># 例如：需要查询销售部的员工信息</p>
<ul>
<li>
<p>第一步：查询销售部的id序号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span>‘销售部’；</span><br></pre></td></tr></table></figure>
<p>假设查询出来id=4</p>
</li>
<li>
<p>第二步由id作为查询条件在另一张表查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> id_for_connent<span class="operator">=</span><span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>可得结果</p>
</li>
</ul>
<p># 而标量子查询只需要一步</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> id_for_connent<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span>‘销售部’);</span><br></pre></td></tr></table></figure>
<ul>
<li>因为括号里查询出来的是单个值所以可以用标量子查询</li>
</ul>
<p># 同样字符串和日期也可以用此方法来做</p>
<h4 id="2-列子查询">2.列子查询</h4>
<ul>
<li>返回结果是一列（可以多行）</li>
<li>常用操作符：</li>
</ul>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>在指定的集合范围内，多选一</td>
</tr>
<tr>
<td>not in</td>
<td>不在指定的聚合范围内</td>
</tr>
<tr>
<td>any</td>
<td>子查询返回列表中有任意一个满足即可</td>
</tr>
<tr>
<td>some</td>
<td>与any等同</td>
</tr>
<tr>
<td>all</td>
<td>子查询返回值的所有值都必须满足</td>
</tr>
</tbody>
</table>
<p># 例如查询销售部和研发部的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> id_for_connent <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span>‘销售部’ <span class="keyword">or</span> ‘研发部’);</span><br></pre></td></tr></table></figure>
<p># 例如要获取所有部门中工资大于研发部所有员工工资的员工信息</p>
<ul>
<li>
<p>第一步：先获取研发部的员工工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> user1 <span class="keyword">where</span> id_for_connent<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span> ‘研发部);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第二步：在所有表中查询工资数值大于所有查询到的这些数值的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> salary<span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> user1 <span class="keyword">where</span> id_for_connent<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span> ‘研发部));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-行子查询">3.行子查询</h4>
<ul>
<li>返回结果是一行（可以多列）</li>
<li>常用操作符：=，&lt;&gt;,in,not in</li>
</ul>
<p># 例如：要查询和某个员工的工资和领导完全相同的其他员工的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> (salary,manager)<span class="operator">=</span>(<span class="keyword">select</span> salary，manager <span class="keyword">from</span> user1 <span class="keyword">where</span> name<span class="operator">=</span>‘员工<span class="number">1</span>’）;</span><br></pre></td></tr></table></figure>
<h4 id="4-表子查询">4.表子查询</h4>
<ul>
<li>返回结果是多行多列</li>
<li>常用操作符：in</li>
</ul>
<p># 例如：要查询和某两个员工的工资和领导完全相同的其他员工的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> (salary,manager) <span class="keyword">in</span> (<span class="keyword">select</span> salary，manager <span class="keyword">from</span> user1 <span class="keyword">where</span> name<span class="operator">=</span>‘员工<span class="number">1</span>’ <span class="keyword">or</span> name<span class="operator">=</span>‘员工<span class="number">2</span>’）;</span><br></pre></td></tr></table></figure>
<p># 例如：要查询在2005-01-01后入职的员工的信息和其部门</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.<span class="operator">*</span>,d.<span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user1 <span class="keyword">where</span> enterdate<span class="operator">&gt;</span><span class="string">&#x27;2005-01-01&#x27;</span>) u <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> u.id_for_connet<span class="operator">=</span>d.id;</span><br></pre></td></tr></table></figure>
<p># 这里将第一次查询出来的内容作为一张表放在from后面，再将这张表与部门表左外连接</p>
<h2 id="8-事务">8.事务</h2>
<h3 id="1-事务简介">1.事务简介</h3>
<ul>
<li>事务是一组操作的合集，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即操作同时成功或同时失败</li>
<li>默认每一条语句都是一个事务，且自动提交</li>
</ul>
<h3 id="2-事务操作">2.事务操作</h3>
<h4 id="1-查看-设置事务提交方式">1.查看/设置事务提交方式</h4>
<h5 id="方法一：">方法一：</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>；</span><br></pre></td></tr></table></figure>
<p># 查询出来为1则是自动提交，为0则是手动提交</p>
<ul>
<li><strong>set @@autocommit=0；</strong></li>
</ul>
<h5 id="方法二：">方法二：</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction 或 <span class="keyword">begin</span> </span><br></pre></td></tr></table></figure>
<p># 自动提交的情况下可以用这种方式，这条语句和下面要执行的语句一起运行</p>
<h4 id="2-提交事务">2.提交事务</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>；</span><br></pre></td></tr></table></figure>
<p># 先运行需要执行的语句然后再运行commit</p>
<h4 id="3-回滚事务">3.回滚事务</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rollback</span>；</span><br></pre></td></tr></table></figure>
<p># 运行报错后不要提交，直接回滚</p>
<h3 id="3-事务四大特性">3.事务四大特性</h3>
<ul>
<li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li>
<li>一致性：事务完成时，必须使所有数据都保持一致状态</li>
<li>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>
</ul>
<p># 即多个事务间互不干扰</p>
<ul>
<li>持续性：事务一旦提交或回滚，它对数据库中的数据的改变是永久的</li>
</ul>
<h3 id="4-并发事务问题">4.并发事务问题</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>脏读</td>
<td>一个事务读到另一个事务还没有提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取到同一条记录，但两次读取的数据不同，称之为不可重复读</td>
</tr>
<tr>
<td># 即在另一个事务提交的前后分别查询了这一条数据，<strong>不可重复读的重点在于数据的修改</strong></td>
<td></td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但在插入数据时，又发现这行数据已经存在</td>
</tr>
<tr>
<td>#即在另一个事务提交的前后分别查询和插入了数据，但是反复查询都显示没有数据，<strong>幻读的重点在于数据的新增和删除</strong></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="5-事务隔离级别">5.事务隔离级别</h3>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>会出现的问题</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>read uncommitted</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>read committed</td>
<td></td>
<td>⨉</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>repeatable read（默认）</td>
<td></td>
<td>⨉</td>
<td>⨉</td>
<td>√</td>
</tr>
<tr>
<td># 不可重复读的问题被解决，变为可重复读，正在执行的事务不会被其他正在执行的事务影响</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>serializable（串行化）</td>
<td></td>
<td>⨉</td>
<td>⨉</td>
<td>⨉</td>
</tr>
<tr>
<td># 用了serializable后当第一个事务先执行时，第二个事务会被阻塞，cmd中回车后光标会一直闪烁直到第一个事务提交，才会执行第二个事务。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td># 从上往下级别越高则数据安全性越高，性能越差</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>查看事务隔离级别</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction_isolation</span>；</span><br></pre></td></tr></table></figure>
<ul>
<li>设置事务隔离级别</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session<span class="operator">/</span><span class="keyword">global</span> transaction isolation level read uncommitted<span class="operator">/</span>read committed<span class="operator">/</span>repeatable read<span class="operator">/</span>serializable；</span><br></pre></td></tr></table></figure>
<p># 其中session是会话级别即进当前客户端窗口，global则针对所有客户端窗口</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2025/10/07/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>Java基础</h1>
<h2 id="1-基础概念">1.基础概念</h2>
<h3 id="1-注释">1.注释</h3>
<h4 id="1-单行注释">1.单行注释</h4>
<ul>
<li>//注释</li>
</ul>
<h4 id="2-多行注释">2.多行注释</h4>
<ul>
<li>/*注释*/</li>
</ul>
<h4 id="3-文档注释">3.文档注释</h4>
<ul>
<li>/**注释*/</li>
</ul>
<h3 id="2-关键字">2.关键字</h3>
<h4 id="1-关键字特点">1.关键字特点</h4>
<ul>
<li>关键字的字母全部<strong>小写</strong></li>
</ul>
<h4 id="2-class">2.class</h4>
<ul>
<li>用于<strong>创建/定义</strong> 一个类
<ul>
<li>类是Java最基本的<strong>组成单元</strong></li>
</ul>
</li>
</ul>
<h3 id="3-字面量">3.字面量</h3>
<table>
<thead>
<tr>
<th>字面量类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数类型</td>
<td>不带小数点的数字</td>
</tr>
<tr>
<td>小数类型</td>
<td>带小数点的数字</td>
</tr>
<tr>
<td>字符串类型</td>
<td>用双引号括起来的内容（即使没有内容）</td>
</tr>
<tr>
<td>字符类型</td>
<td>用单引号括起来的，且内容只能有一个</td>
</tr>
<tr>
<td>布尔类型</td>
<td>布尔值：true/false，表示真假</td>
</tr>
<tr>
<td>空类型</td>
<td>一个特殊的值：null，空值，需要用字符串的形式打印出来，不能直接打印</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>特殊字面量</p>
</li>
<li>
<p>\t 制表符</p>
<ul>
<li>打印的时候，会把前面的字符串的长度去补齐到8，或者是8的整数倍，最少补一个空格，最多补8个空格</li>
<li>在两个字符串中间**+‘\t’+**，可以使中间补齐</li>
</ul>
</li>
</ul>
<h3 id="4-变量">4.变量</h3>
<ul>
<li>在程序执行过程中，其值有可能发生<strong>改变</strong> 的量（数据）</li>
</ul>
<h4 id="基本用法">基本用法</h4>
<h5 id="1-使用场景">1.使用场景</h5>
<ul>
<li>当某个数据经常发生改变时，可以用变量存储，当数据变化时，只要修改变量里面记录的值即可</li>
</ul>
<h5 id="2-定义格式">2.定义格式</h5>
<ul>
<li><strong>数据类型 变量名=数据值；</strong></li>
</ul>
<h5 id="3-使用方式">3.使用方式</h5>
<ul>
<li>
<p>输出打印</p>
</li>
<li>
<p>参与计算</p>
</li>
<li>
<p>修改记录的值</p>
</li>
</ul>
<h5 id="4-注意事项">4.注意事项</h5>
<ul>
<li>只能存一个值</li>
<li>变量名不允许重复定义</li>
<li>一条语句可以定义多个变量</li>
<li>变量在使用之前一定要进行赋值</li>
<li>变量的作用域范围</li>
<li>使用前必须赋值</li>
</ul>
<h3 id="5-计算机中的数据存储">5.计算机中的数据存储</h3>
<ul>
<li>任意数据都是以二进制的形式来存储的</li>
</ul>
<h4 id="1-文本数据">1.文本数据</h4>
<h5 id="1-常见进制">1.常见进制</h5>
<ul>
<li>二进制（bin）：由0和1组成，Java中以0b开头，如果用了0b开头，后面的数字中又有0和以外的数字则报错</li>
<li>十进制（oct）：由0-9组成，不加前缀</li>
<li>八进制（dec）：由0-7组成，以0开头</li>
<li>十六进制（hex）：由0-9和a-f组成，以0x开头</li>
</ul>
<p># 在jdk7后加前缀</p>
<h5 id="2-任意进制转为十进制">2.任意进制转为十进制</h5>
<ul>
<li><strong>每个系数*基数的权次幂 相加</strong>
<ul>
<li>系数：每一位上的数</li>
<li>基数：当前进制数</li>
<li>权：从右向左，依次为0，1，2，3，……</li>
</ul>
</li>
</ul>
<h5 id="3-十进制转为其他进制">3.十进制转为其他进制</h5>
<ul>
<li><strong>除基取余法</strong>：不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来</li>
</ul>
<h5 id="4-ASCII表">4.ASCII表</h5>
<ul>
<li>用7位二进制数字对应字母和符号</li>
<li>可以将字母转化为二进制存储</li>
</ul>
<h5 id="5-编码">5.编码</h5>
<h6 id="1-GB2312编码">1.GB2312编码</h6>
<ul>
<li>简体中文</li>
</ul>
<h6 id="2-BIG5编码">2.BIG5编码</h6>
<ul>
<li>繁体中文</li>
</ul>
<h6 id="3-GBK编码">3.GBK编码</h6>
<ul>
<li>收录汉字，包含国家标准GB13000-1中的全部中日韩汉字，和BIG5编码中的所有汉字</li>
<li>计算机默认编码</li>
</ul>
<h6 id="4-Unicode编码">4.Unicode编码</h6>
<ul>
<li>国际标准字符集，将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言，跨平台的文本信息转化</li>
</ul>
<h4 id="2-图片数据">2.图片数据</h4>
<h5 id="1-黑白图">1.黑白图</h5>
<ul>
<li>每个像素点，0为黑，1为白</li>
</ul>
<h5 id="2-灰度图">2.灰度图</h5>
<ul>
<li>每个像素点，0为黑，255为白，中间数字为不同程度的灰</li>
</ul>
<h5 id="3-彩色图">3.彩色图</h5>
<ul>
<li>
<p>由光学三原色（红绿蓝，rgb）作为一个整体来作为一个像素点，可以通过设置一个像素点中的三原色的深浅来调整颜色</p>
</li>
<li>
<p>每个原色的取值范围都是0-255</p>
</li>
<li>
<p>可以写成十进制（255，120，156）</p>
</li>
<li>
<p>也可以写成十六进制</p>
</li>
</ul>
<h4 id="3-声音数据">3.声音数据</h4>
<ul>
<li>对声波采样，形成波形图，波形图中的每个点会数字对应，采样的点多则还原度高（无损），采样点少则还原度低（全损）</li>
</ul>
<h3 id="6-数据类型">6.数据类型</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>byte</td>
<td>-128~127</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>-32768~32767</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>int</td>
<td>十位数</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>十九位数</td>
<td>8</td>
</tr>
<tr>
<td>浮点数</td>
<td>float</td>
<td>-3.401298e-38~3.402823e+38</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>-4.9000000e-324~1.797693e+308</td>
<td>8</td>
</tr>
<tr>
<td>字符</td>
<td>char</td>
<td>0~65535</td>
<td>2</td>
</tr>
<tr>
<td>布尔</td>
<td>boolean</td>
<td>true,false</td>
<td>1</td>
</tr>
</tbody>
</table>
<p># 定义<strong>long类型</strong> 的变量，在数字的后面要<strong>加一个L作为后缀</strong></p>
<p># 同理<strong>float类型</strong> 的变量。数字后<strong>加F作为后缀</strong></p>
<h3 id="7-标识符">7.标识符</h3>
<ul>
<li>标识符：给类，方法，变量等起的名字</li>
</ul>
<h4 id="标识符命名规则">标识符命名规则</h4>
<h5 id="1-硬性要求">1.硬性要求</h5>
<ul>
<li>由数字，字母，下划线，美元符号组成</li>
<li>不能以数字开头</li>
<li>不能是关键字</li>
<li>区分大小写</li>
</ul>
<h5 id="2-软性建议">2.软性建议</h5>
<ul>
<li>
<p>小驼峰命名法（适合方法和变量）</p>
<ul>
<li>
<p>标识符是<strong>一个单词</strong> 的时候，<strong>全部小写</strong>：name</p>
</li>
<li>
<p>标识符由<strong>多个单词</strong> 组成时，<strong>第一个单词的首字母小写</strong>，<strong>其他单词首字母大写</strong>：firstName</p>
</li>
</ul>
</li>
<li>
<p>大驼峰命名法（适合类名）</p>
<ul>
<li>标识符是<strong>一个单词</strong> 的时候，<strong>首字母大写</strong>：Student</li>
<li>标识符由<strong>多个单词</strong> 组成的时候，<strong>每个单词的首字母大写</strong>：GoodStudent</li>
</ul>
</li>
</ul>
<h3 id="8-键盘录入">8.键盘录入</h3>
<h4 id="1-概述">1.概述</h4>
<ul>
<li>java中有一个写好的类叫Scanner，可以接收键盘输入的数据</li>
<li>步骤：
<ul>
<li>导包：在java.util.Scanner这个包</li>
<li>创建对象</li>
<li>接收数据</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">//导包要写在类定义的上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//创建对象，这里只有变量名可以改变</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>sc.nextInt(); <span class="comment">//接收整数类型的数据</span></span><br><span class="line">        System.out.println(i); <span class="comment">//输出数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 两个变量都要接收数据，就要写两遍接收数据的一行，不能在同一行两个变量接收数据</p>
<p># Java中没有提供直接接收字符数据的方法，要先接收字符串数据，再进行转化，用charAct()来获取输入的字符串中的某个字符</p>
<h3 id="9-IDEA">9.IDEA</h3>
<h4 id="1-概述-2">1.概述</h4>
<ul>
<li>结构
<ul>
<li>项目
<ul>
<li>模块
<ul>
<li>包
<ul>
<li>类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-快捷键">2.快捷键</h4>
<ul>
<li>ctrl+alt+L，自动格式代码</li>
<li>ctrl+alt+M，自动抽取方法</li>
<li>alt+insert/alt+Fn+insert，生成构造方法，可以用shift多选</li>
</ul>
<p># PTG插件也可以更快速的实现</p>
<ul>
<li>ctrl+alt+v，快速在调用的方法前生成一个对应数据类型以及变量来接收</li>
</ul>
<p># 例如：sc.nextDouble()，ctrl+alt+v，则生成double v = sc.nextDouble();</p>
<ul>
<li>
<p>ctrl+b，查看源码</p>
</li>
<li>
<p>选中一段代码后ctrl+alt+t，选择被哪种代码包裹，如for，if，while等</p>
</li>
<li>
<p>shift+alt+方向键，将代码移动</p>
</li>
<li>
<p>对报错的地方alt+enter会给出解决方法</p>
</li>
<li>
<p>选中后ctrl+shift+u，全部大写/小写</p>
</li>
</ul>
<h4 id="3-快捷功能">3.快捷功能</h4>
<ul>
<li>
<p>psvm</p>
<ul>
<li>快速生成main方法</li>
</ul>
</li>
<li>
<p>鼠标滚轮/alt</p>
<ul>
<li>竖列选中</li>
</ul>
</li>
<li>
<p>fori</p>
<ul>
<li>快速生成一个for循环其中变量为i</li>
<li>如果在fori前加上数字.则会生成i&lt;这个数字的循环</li>
</ul>
</li>
<li>
<p>数组名.fori</p>
<ul>
<li>快速生成数组的遍历</li>
</ul>
</li>
<li>
<p>集合名.fori</p>
<ul>
<li>快速生成集合的遍历</li>
</ul>
</li>
</ul>
<h2 id="2-运算符">2.运算符</h2>
<ul>
<li>运算符：对字面量或者变量进行操作的符号</li>
<li>表达式：用运算符把字面量或者变量连接起来，<strong>符合java语法</strong> 的句子</li>
</ul>
<h3 id="1-算术运算符">1.算术运算符</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
</tr>
<tr>
<td>%</td>
<td>取模：取余数</td>
</tr>
</tbody>
</table>
<p># 如果有小数参与运算，则结果不一定准确</p>
<p># 如果都是整数参与运算，结果为整数</p>
<h4 id="1-数字相加">1.数字相加</h4>
<h5 id="类型转换">类型转换</h5>
<h6 id="1-隐式转换（自动类型提升）（默认）">1.隐式转换（自动类型提升）（默认）</h6>
<ul>
<li>
<p>把一个取值范围小的数值，转成取值范围大的数据，再进行计算</p>
</li>
<li>
<p>byte，short，char三种类型，在运算时，都会先提升为int再进行运算</p>
</li>
</ul>
<h6 id="2-强制转换">2.强制转换</h6>
<ul>
<li>把一个取值范围大的数值，赋值给取值范围小的变量</li>
<li><strong>目标数据类型 变量名=（目标数据类型）被强转的数据</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> a=<span class="number">12.3</span>;</span><br><span class="line"><span class="type">int</span> b=(<span class="type">int</span>)a;</span><br></pre></td></tr></table></figure>
<p># 可能会发生数据错误，可以用<strong>补码</strong> 来解释为什么会出错，以及会转为什么数据</p>
<p># 如果要强转的是变量相加，需要把变量相加<strong>加括号</strong></p>
<h4 id="2-字符串相加">2.字符串相加</h4>
<ul>
<li>当相加操作中出现字符串时，+就是字符串连接符，会将前后的数据进行拼接，产生一个新的字符串</li>
<li><strong>连续进行相加操作时</strong>，<strong>从左到右逐个执行</strong></li>
<li>例如1+2+“人”，从左到右，先1+2没有字符串出现，则进行计算=3，3再余后面的&quot;人&quot;进行拼接，得到3人</li>
</ul>
<h4 id="3-字符相加">3.字符相加</h4>
<ul>
<li>字符加字符/数字时，会先从ASCII中查询相应字符对应的数字，再进行计算</li>
</ul>
<h3 id="2-自增自减运算符">2.自增自减运算符</h3>
<h4 id="1-自增">1.自增</h4>
<ul>
<li>++，变量的值加1</li>
</ul>
<p># 既可以写在变量前，也可以写在变量后</p>
<h4 id="2-自减">2.自减</h4>
<ul>
<li>–，变量的值减1</li>
</ul>
<p># 既可以写在变量前，也可以写在变量后</p>
<h4 id="3-参与计算">3.参与计算</h4>
<ul>
<li>写在变量后，则先用后增/减</li>
<li>写在变量后，则先增/减后用</li>
</ul>
<h3 id="3-赋值运算符">3.赋值运算符</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值</td>
</tr>
<tr>
<td>+=</td>
<td>加后赋值</td>
</tr>
<tr>
<td>-=</td>
<td>减后赋值</td>
</tr>
<tr>
<td>*=</td>
<td>乘后赋值</td>
</tr>
<tr>
<td>/=</td>
<td>除后赋值</td>
</tr>
<tr>
<td>%=</td>
<td>取余后赋值（是两个整数相除的余数）</td>
</tr>
</tbody>
</table>
<p># 除了=，其他都会进行强制转换，转换为前面的变量的类型</p>
<h3 id="4-关系运算符（比较运算符）">4.关系运算符（比较运算符）</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>判断两个变量是否相等，成立为true，否则false</td>
</tr>
<tr>
<td>!=</td>
<td>判断是否不等</td>
</tr>
<tr>
<td>&gt;</td>
<td>判断是否大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>判断是否大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>判断是否小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>判断是否小于等于</td>
</tr>
</tbody>
</table>
<p># 结果都是boolean类型，只有true和false</p>
<h3 id="5-逻辑运算符">5.逻辑运算符</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>逻辑与（且）</td>
<td>并且，两边都为真，结果才为真，1为true，0为false</td>
</tr>
<tr>
<td>|</td>
<td>逻辑或</td>
<td>或者，两边都为假，结果才是假，1为true，0为false</td>
</tr>
<tr>
<td>^</td>
<td>逻辑异或</td>
<td>相同为false，不同为true</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非</td>
<td>取反，真值取反就是假值</td>
</tr>
</tbody>
</table>
<p># &amp;和|可以用<strong>补码</strong> 来解释</p>
<ul>
<li>短路逻辑运算符</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>短路与</td>
<td>结果和&amp;相同，但是有短路效果</td>
</tr>
<tr>
<td>||</td>
<td>短路或</td>
<td>结果和|相同，但是有短路效果</td>
</tr>
</tbody>
</table>
<p># 如果<strong>左边能确定整个表达式的结果</strong>，则右边不执行</p>
<h3 id="6-三元运算符">6.三元运算符</h3>
<ul>
<li>
<p><strong>关系表达式?表达式1:表达式2;</strong></p>
</li>
<li>
<p>先计算关系表达式，如果结果为真，则执行表达式1，为假则执行表达式2</p>
</li>
</ul>
<p># 三元运算符的结果<strong>必须要被使用</strong></p>
<h3 id="7-运算符优先级">7.运算符优先级</h3>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>. () {}</td>
</tr>
<tr>
<td>2</td>
<td>!、~、++、–</td>
</tr>
<tr>
<td>3</td>
<td>*、/、%</td>
</tr>
<tr>
<td>4</td>
<td>+、-</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td>
</tr>
<tr>
<td>6</td>
<td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
</tr>
<tr>
<td>7</td>
<td>==、!=</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
</tr>
<tr>
<td>13</td>
<td>?  :</td>
</tr>
<tr>
<td>14</td>
<td>=、+=、-=、*=、/=、%=、&amp;=</td>
</tr>
</tbody>
</table>
<p># &lt;&lt;左移，补码向左移动，右边就会空出，在这个低位补0，同理右移高位正数补0负数1</p>
<p># &gt;&gt;&gt;无符号右移，向右移动，高位补0</p>
<h3 id="8-原码，反码，补码">8.原码，反码，补码</h3>
<h4 id="1-原码">1.原码</h4>
<ul>
<li>十进制数据的二进制表现形式，最左边是符号位，0为正，1为负</li>
<li>八个bit为一个字节</li>
<li>最大值：01111111=127</li>
<li>最小值：11111111=-127</li>
</ul>
<h5 id="1-原码的计算">1.原码的计算</h5>
<ul>
<li>二进制的计算方式，加1，则直接在末位加1，满二进一</li>
</ul>
<h5 id="2-原码的弊端">2.原码的弊端</h5>
<ul>
<li>用原码对正数进行计算是不会有问题的</li>
<li>但如果是负数计算，结果就出错，实际运算的结果与预期的结果是相反的</li>
</ul>
<h4 id="2-反码">2.反码</h4>
<ul>
<li>为了解决<strong>原码不能计算负数</strong> 的问题而出现的</li>
</ul>
<h5 id="1-反码的计算">1.反码的计算</h5>
<ul>
<li>
<p>正数的反码不变，负数的反码在原码的基础上，符号位不变，数字取反，0变1，1变0</p>
</li>
<li>
<p>如果加1，则在末位加1，满二进一，得到的就是加1后的反码</p>
</li>
</ul>
<h5 id="2-反码的弊端">2.反码的弊端</h5>
<ul>
<li>反码的11111111表示-0，如果再加1，则变为00000000=0</li>
<li>同样类似于-4的反码+7，跨0，会比正确结果小1</li>
</ul>
<p># 因为反码中的0有11111111和00000000两种表示方式</p>
<h4 id="3-补码">3.补码</h4>
<ul>
<li>
<p>在负数的反码的基础上加1，这样-0就是00000000，-1就是11111111，反码再依次向后，形成补码</p>
</li>
<li>
<p>-127就是10000001，-128就是10000000，-128只有补码，没有原码</p>
</li>
<li>
<p><strong>计算机中数字的存储计算都是以补码的形式来操作的</strong></p>
</li>
<li>
<p>所以<strong>一个字节</strong> 的范围就是**-128~127**</p>
</li>
</ul>
<h2 id="3-判断与循环">3.判断与循环</h2>
<h3 id="1-顺序结构">1.顺序结构</h3>
<ul>
<li>java程序默认的执行流程，按照代码的先后顺序，从上到下依次执行</li>
</ul>
<h3 id="2-分支结构">2.分支结构</h3>
<h4 id="1-if语句">1.if语句</h4>
<h5 id="1-第一种格式">1.第一种格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算关系表达式的值</li>
<li>如果关系表达式的值为true就执行语句体</li>
<li>如果关系式的值为false就不执行语句体</li>
<li>继续执行后面的其他语句</li>
</ul>
</li>
</ul>
<p># 只有一条语句的时候可以省略，但是尽量不要省略，如定义并初始化一个变量的语句，写成一句，但是是两句，不加{}会报错</p>
<h5 id="2-第二种格式">2.第二种格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算关系表达式的值</li>
<li>如果关系表达式的值为true就执行语句1</li>
<li>如果关系表达式的值为false就执行语句2</li>
<li>继续执行后面的语句</li>
</ul>
</li>
</ul>
<h5 id="3-第三种格式">3.第三种格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式<span class="number">1</span>)&#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(关系表达式<span class="number">2</span>)&#123;</span><br><span class="line">	语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算关系表达式1的值</li>
<li>如果为true就执行语句体1；如果为false就计算关系表达式2的值</li>
<li>如果为true就执行语句体2；如果为false就计算关系表达式3的值</li>
<li>……</li>
<li>如果所有关系表达式结果都为false，就执行else后的语句</li>
</ul>
</li>
</ul>
<h4 id="2-switch语句">2.switch语句</h4>
<h5 id="1-格式">1.格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>;</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span>;</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句体;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算表达式的值</li>
<li>依次和case后面的值进行比较，如果有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束</li>
<li>如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后结束整个switch语句</li>
</ul>
</li>
</ul>
<p># case后面的值只能是字面量，<strong>不能写变量</strong></p>
<h5 id="2-case穿透">2.case穿透</h5>
<ul>
<li><strong>没有加break</strong>，正常有break就会结束整个switch，如果没有就会一直向下执行，直到有break或者}</li>
</ul>
<p># default也是特殊的case</p>
<ul>
<li>可以在case后面的多个语句重复的时候，利用case穿透</li>
</ul>
<p># 将前面case后面的语句删除，只保留最后一个重复的语句，这样就会一直穿透到最后一个重复语句，然后break</p>
<p># 同时可以将重复的语句的几个值都写在一个，case1，2，3，4，5</p>
<p># 同样也可以用下面的写法优化</p>
<h5 id="3-写法优化">3.写法优化</h5>
<ul>
<li>在jdk12以后</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span> -&gt;&#123;</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span> -&gt;&#123;</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">default</span> -&gt;&#123;</span><br><span class="line">		语句体;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 如果{}中只有一个语句，还能把{}省略，把case/default和语句体写在同一行</p>
<h3 id="3-循环结构">3.循环结构</h3>
<h4 id="1-for循环">1.for循环</h4>
<h5 id="1-格式-2">1.格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句;条件判断语句;条件控制语句)&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>执行初始化语句</li>
<li>执行条件判断语句，看其结果是true还是false
<ul>
<li>如果是false，循环结束</li>
<li>如果是true，执行循环体语句</li>
</ul>
</li>
<li>执行条件控制语句</li>
<li>回到第二步继续执行条件判断语句</li>
</ul>
</li>
</ul>
<h5 id="2-注意">2.注意</h5>
<ul>
<li>不要在循环语句中写定义赋值语句，然后在语句外使用，变量只在循环中有效</li>
<li>变量定义在循环中，变量只能在本次循环中有效</li>
</ul>
<h4 id="2-while循环">2.while循环</h4>
<h5 id="1-格式-3">1.格式</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line">while(条件判断语句)&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-和for循环的对比">2.和for循环的对比</h5>
<h6 id="1-相同点">1.相同点</h6>
<ul>
<li>运行规则是一样的</li>
</ul>
<h6 id="2-区别">2.区别</h6>
<ul>
<li>for循环中，控制循环的变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了
<ul>
<li>知道循环次数或者循环的范围</li>
</ul>
</li>
<li>while循环中，控制循环的变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用
<ul>
<li>不知道循环的次数和范围，只知道循环的结束条件</li>
</ul>
</li>
</ul>
<h4 id="3-do……while循环"><a href="http://3.do">3.do</a>……while循环</h4>
<h5 id="格式">格式</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句);</span><br></pre></td></tr></table></figure>
<ul>
<li>先执行后判断</li>
</ul>
<h4 id="4-无限循环">4.无限循环</h4>
<ul>
<li>for循环中不写条件</li>
<li>while/do……while循环中条件写true</li>
</ul>
<p># 无限循环下面就不能再写代码了，会报错无法达到的代码</p>
<h4 id="5-跳转控制语句">5.跳转控制语句</h4>
<ul>
<li>
<p>continue，用于结束<strong>本次循环</strong>，开始下一次循环</p>
</li>
<li>
<p>break，结束<strong>整个循环</strong></p>
</li>
</ul>
<h2 id="4-数组">4.数组</h2>
<h3 id="1-数组介绍">1.数组介绍</h3>
<ul>
<li>数组指的是一种容器，可以用来存储<strong>同种数据类型</strong> 的多个值</li>
</ul>
<p># 并不一定是完全一样的数组类型，要结合隐式转化</p>
<h3 id="2-数组的定义与静态初始化">2.数组的定义与静态初始化</h3>
<h4 id="1-定义">1.定义</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 数组名[];</span><br></pre></td></tr></table></figure>
<h4 id="2-静态初始化">2.静态初始化</h4>
<ul>
<li>
<p>初始化：在内存中，为数组开辟空间，并将数据存入容器中的过程</p>
</li>
<li>
<p>完整格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>简写格式</p>
</li>
<li>
<pre><code>数据类型[] 数组名 = &#123;元素&#125;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\# 初始化后长度不可变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.数组元素访问</span><br><span class="line"></span><br><span class="line">#### 1.数组的地址值</span><br><span class="line"></span><br><span class="line">* 直接打印数组名，会显示数组的地址值，而不是数组里面的元素</span><br><span class="line">* 地址值的格式</span><br><span class="line">  * [：表示当前是一个数组</span><br><span class="line">  * D，I：表示数组里面元素的类型</span><br><span class="line">  * @：间隔符号，固定格式</span><br><span class="line">  * 数字加字母：十六进制，真正的地址值</span><br><span class="line">  * 一般将这些统称为地址值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.索引</span><br><span class="line"></span><br><span class="line">* 索引：也称下标，角标</span><br><span class="line">* **从0开始**，逐个+1，连续不间断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4.数组遍历</span><br><span class="line"></span><br><span class="line">* 数组遍历：将数组中所有的内容取出</span><br><span class="line">* **遍历是指取出数据的过程**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 可以使用循环来遍历数组</span><br><span class="line"></span><br><span class="line">* 数组过长时为了获取数组的长度可以使用**length**</span><br><span class="line"></span><br><span class="line">* 调用方法：</span><br><span class="line"></span><br><span class="line">  * 数组名.length</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 5.数组动态初始化</span><br><span class="line"></span><br><span class="line">* 动态初始化：初始化时只指定数组的长度，由系统分配初始值</span><br><span class="line"></span><br><span class="line">* 格式</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">数据类型[] 数组名 = new 数据类型[数组长度]</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
<li>
<p>默认初始化值</p>
<ul>
<li>整数：0</li>
<li>小数：0.0</li>
<li>字符：/u0000，即空格</li>
<li>布尔：false</li>
<li>引用：null</li>
</ul>
</li>
</ul>
<h4 id="动态与静态的区别">动态与静态的区别</h4>
<ul>
<li>动态：手动指定数组长度，系统给出默认初始化值
<ul>
<li>只明确元素个数，不明确具体数组</li>
</ul>
</li>
<li>静态：手动指定数组元素，系统根据元素个数，计算出数组的长度
<ul>
<li>已经明确了要操作的具体数据，直接静态初始化</li>
</ul>
</li>
</ul>
<h3 id="6-数组内存图">6.数组内存图</h3>
<h4 id="1-内存分配">1.内存分配</h4>
<ul>
<li>
<p>JVM虚拟机，将其内存空间分为五个部分</p>
<ul>
<li>栈：方法运行时使用的空间，如main方法运行，进入方法栈中执行</li>
<li>堆：存储对象或者数组，new来创建的，都存储在堆内存</li>
<li>方法区：存储可以运行的class文件</li>
<li>本地方法栈：JVM在使用操作系统功能的时候使用</li>
<li>寄存器：给cpu使用</li>
</ul>
<p># jdk8后将方法区取消，改为元空间，原方法区的功能放在了堆和元空间中</p>
</li>
</ul>
<h4 id="2-数组的内存">2.数组的内存</h4>
<ul>
<li>main方法进入栈内存
<ul>
<li>定义数组进入栈内存</li>
<li>定义的同时new在堆内存中开辟空间</li>
<li>堆中的空间地址值赋值给栈内存中的数组
<ul>
<li>调用时，先通过栈内存中的数组变量的地址值，找到堆内存中的数据，再通过索引找到对应数据</li>
<li>赋值也同理，覆盖原来索引上的元素
<ul>
<li>创建第二个数组也同理，在堆内存中开辟一个新的独立空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-两个数组指向同一个空间">3.两个数组指向同一个空间</h4>
<ul>
<li>定义完第一个数组后，第二个数组定义并直接将第一个数组赋值给第二个数组，这时候就没有new</li>
<li>堆内存中是同一个空间，两个数组变量的地址值也是相同</li>
<li>修改任意一个数组中的数据，另一个数组也会被修改</li>
</ul>
<h3 id="7-数组常见问题">7.数组常见问题</h3>
<ul>
<li>索引越界异常：访问了数组中不存在的索引</li>
</ul>
<h3 id="8-数组常见操作">8.数组常见操作</h3>
<h4 id="1-求最值">1.求最值</h4>
<ul>
<li>先定义一个变量记录最值（变量初始化的值必须是数组中的一个值）
<ul>
<li>遍历数组获取每一个元素
<ul>
<li>让每一个元素和最值比较，比最值更大/更小，就让变量记录新的元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<p># 遍历输出可以使用print使其输出在同一行</p>
<h4 id="2-求和">2.求和</h4>
<ul>
<li>先定义一个求和变量
<ul>
<li>再循环得到每一个元素
<ul>
<li>加到变量中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-交换数据">3.交换数据</h4>
<ul>
<li>和两个变量交换数据一样
<ul>
<li>将两个索引的数据交换，需要一个空的变量</li>
</ul>
</li>
</ul>
<p># 可以使用循环实现数组首尾交换</p>
<h4 id="4-打乱数据">4.打乱数据</h4>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br></pre></td></tr></table></figure>
<p># 需要先导入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random 变量 = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>构造函数使用当前时间作为种子值</p>
<ul>
<li>
<pre><code class="language-java">变量.nextInt(整数)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    \# 这是Random类中的一个方法，可以返回一个0~整数（不包含）的一个随机数</span><br><span class="line"></span><br><span class="line">  * 再赋值给一个新的变量</span><br><span class="line"></span><br><span class="line">    * 循环遍历数组</span><br><span class="line">      * 从第一个元素开始，和随机数元素交换</span><br><span class="line">        * 获取随机数写在循环中，所以每次生成的随机数不同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5.方法</span><br><span class="line"></span><br><span class="line">### 1.方法的介绍</span><br><span class="line"></span><br><span class="line">#### 1.定义</span><br><span class="line"></span><br><span class="line">* **方法**（method）是程序当中**最小** 的执行单元</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.使用场景</span><br><span class="line"></span><br><span class="line">* 将重复的代码，具有独立功能的代码抽取到方法中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.方法的格式</span><br><span class="line"></span><br><span class="line">#### 1.最简单的</span><br><span class="line"></span><br><span class="line">##### 1.定义</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void 方法名()&#123;</span><br><span class="line">	方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="2-调用">2.调用</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名();</span><br></pre></td></tr></table></figure>
<h4 id="2-带参数的">2.带参数的</h4>
<h5 id="1-定义-2">1.定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名(参数<span class="number">1</span>,参数<span class="number">2</span>,……)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-调用-2">2.调用</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名(参数<span class="number">1</span>,参数<span class="number">2</span>,……)</span><br></pre></td></tr></table></figure>
<p># 参数个数必须和方法中的一样</p>
<h5 id="3-形参和实参">3.形参和实参</h5>
<ul>
<li>形参：形式参数，是指方法定义中的参数</li>
<li>实参：实际参数，方法调用中的参数</li>
</ul>
<h4 id="3-带返回值的">3.带返回值的</h4>
<h5 id="1-定义-3">1.定义</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 方法名(参数<span class="number">1</span>,参数<span class="number">2</span>,……)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>return表示<strong>结束方法</strong>，return后就不能再写了</li>
</ul>
<p># 返回类型[]表示返回一个此数据类型的数组</p>
<h5 id="2-调用-3">2.调用</h5>
<h6 id="1-直接调用">1.直接调用</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名(实参);</span><br></pre></td></tr></table></figure>
<h6 id="2-赋值调用">2.赋值调用</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名 = 方法名(实参);</span><br></pre></td></tr></table></figure>
<h6 id="3-输出调用">3.输出调用</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(方法名(实参));</span><br></pre></td></tr></table></figure>
<h3 id="3-方法的重载">3.方法的重载</h3>
<ul>
<li>在<strong>同一个类</strong> 中，定义了<strong>多个同名</strong> 的方法，这些同名的方法具有<strong>同种的功能</strong></li>
<li>每个方法具有不同的参数类型和参数个数，这些同名的方法，就构成了重载关系</li>
<li>参数不同
<ul>
<li>个数不同</li>
<li>类型不同</li>
<li>顺序不同：定义的形参的类型的顺序</li>
</ul>
</li>
</ul>
<p># Java虚拟机会通过参数的不同来区分同名的方法</p>
<h3 id="4-方法的内存">4.方法的内存</h3>
<h4 id="1-方法调用的基本内存原理">1.方法调用的基本内存原理</h4>
<ul>
<li>被调用则入栈，方法中调用了其他的方法则会再将其他的方法入栈，当栈顶的方法使用完后，出栈，再接着运行下面一个方法</li>
</ul>
<h4 id="2-方法传递基本数据类型的内存原理">2.方法传递基本数据类型的内存原理</h4>
<h5 id="基本数据类型">基本数据类型</h5>
<ul>
<li>
<p>变量中存储的是真实的数据</p>
</li>
<li>
<p>数据值是存储在自己的空间中</p>
</li>
<li>
<p>赋值给其他变量，也是赋的真实的值</p>
</li>
<li>
<p>传递基本数据类型时，传递的是真实的数据，形参的改变不会影响实际参数的值</p>
</li>
</ul>
<p># 例如先定义一个变量并赋值为1，再方法中将变量赋值为2，调用方法传入定义的变量，输出变量，此时显示的值仍为1</p>
<p>定义并赋值时，先入栈，然后调用的方法再入栈，给变量赋值为2，然后方法出栈，但是<strong>先入栈的变量并没有被修改值</strong>，所以再打印变量，输出的仍然是原来的值</p>
<p>要解决这个问题，可以在方法中返回修改后的变量，同时使用方法格式中的带返回值的格式中的赋值调用，再赋给一个新的变量，再将这个变量输出</p>
<h4 id="3-方法传递引用数据类型的内存原理">3.方法传递引用数据类型的内存原理</h4>
<h5 id="引用数据类型">引用数据类型</h5>
<ul>
<li>
<p>变量中存储的是地址值，即使用其他空间中的数据，自己空间中存储的是地址值</p>
</li>
<li>
<p>传递引用数据类型，传递的是地址值，形参的改变会影响到实际参数的值</p>
</li>
</ul>
<p># 和数组的内存相同</p>
<h2 id="6-面向对象">6.面向对象</h2>
<h3 id="1-设计对象并使用">1.设计对象并使用</h3>
<h4 id="1-类和对象">1.类和对象</h4>
<ul>
<li>类：是对象共同特征的描述</li>
<li>对象：是真实存在的东西</li>
</ul>
<p># java中必须先设计类，才能获得对象</p>
<h5 id="1-如何定义类">1.如何定义类</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">	<span class="number">1.</span>成员变量（属性）</span><br><span class="line">    <span class="number">2.</span>成员方法（行为）</span><br><span class="line">    <span class="number">3.</span>构造器</span><br><span class="line">    <span class="number">4.</span>代码块</span><br><span class="line">    <span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-如何获得类的对象">2.如何获得类的对象</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>
<h5 id="3-如何使用对象">3.如何使用对象</h5>
<ul>
<li>访问属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.成员变量</span><br></pre></td></tr></table></figure>
<ul>
<li>访问行为</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.方法名(……)</span><br></pre></td></tr></table></figure>
<h4 id="2-类的补充">2.类的补充</h4>
<h5 id="1-定义类的补充事项">1.定义类的补充事项</h5>
<ul>
<li>
<p>用来描述一类事物的类，叫做：Jvavbean类</p>
</li>
<li>
<p>在Jvavbean类中，是不写main方法的</p>
</li>
<li>
<p>编写的main方法的类，叫做测试类</p>
</li>
<li>
<p>测试类中可以创建javabean类的对象并进行赋值调用</p>
</li>
<li>
<p>一个java文件中可以定义多个类，且只能有一个类是public修饰</p>
</li>
<li>
<p>public修饰的类名必须成为代码文件名</p>
</li>
</ul>
<p># 实际开放中一个文件定义一个class类</p>
<ul>
<li>成员变量的完整定义格式是</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 数据类型 变量名 = 初始化值;</span><br></pre></td></tr></table></figure>
<p># 一般无需指定初始化值，存在默认值</p>
<h5 id="2-开发中类的设计">2.开发中类的设计</h5>
<ul>
<li>根据需求，从中提取名词，作为属性</li>
<li>根据需求，从中提取动词，作为行为</li>
</ul>
<h3 id="2-封装">2.封装</h3>
<ul>
<li>封装：如何正确设计对象的属性和方法</li>
</ul>
<p># 面向对象三大特征之一</p>
<h4 id="1-原则">1.原则</h4>
<ul>
<li><strong>对象代表什么，就得到封装对应的数据，并提供数据对应的行为</strong></li>
</ul>
<h4 id="2-private关键字">2.private关键字</h4>
<ul>
<li>
<p>是一个<strong>权限修饰符</strong></p>
</li>
<li>
<p>可以修饰成员（成员变量和成员方法）</p>
</li>
<li>
<p>被private修饰的成员<strong>只能在本类中才能访问</strong></p>
</li>
<li>
<p>保证数据安全性</p>
</li>
</ul>
<p># 与public相反</p>
<ul>
<li>如果要使其他类能够使用，可以提供两个方法
<ul>
<li>set：给成员赋值</li>
<li>get：对外提供成员变量的值</li>
</ul>
</li>
</ul>
<p># 这两个需要用public修饰</p>
<h3 id="3-this关键字">3.this关键字</h3>
<h4 id="1-成员变量和局部变量">1.成员变量和局部变量</h4>
<h5 id="1-局部变量">1.局部变量</h5>
<ul>
<li>定义在方法内</li>
</ul>
<h5 id="2-成员变量">2.成员变量</h5>
<ul>
<li>定义在类内，方法外</li>
</ul>
<h5 id="3-就近原则">3.就近原则</h5>
<ul>
<li>
<p>局部变量和成员变量重名时</p>
</li>
<li>
<p>使用本方法的变量</p>
</li>
</ul>
<h4 id="2-this">2.this</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.变量名</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用成员变量</li>
</ul>
<h3 id="4-构造方法">4.构造方法</h3>
<h4 id="1-概述-3">1.概述</h4>
<ul>
<li>构造方法：也叫构造器，构造函数</li>
<li>作用：在创建对象的时候给成员变量进行赋值的</li>
</ul>
<h4 id="2-构造方法的格式">2.构造方法的格式</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">	修饰符 类名(参数)&#123;</span><br><span class="line">		方法体;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>特点</p>
<ul>
<li>
<p>方法名与类名相同</p>
</li>
<li>
<p>没有返回值类型，void也没有</p>
</li>
<li>
<p>没有具体的返回值（不能由return带回结果数据）</p>
</li>
</ul>
</li>
<li>
<p>执行时机</p>
<ul>
<li>创建对象的时候由虚拟机调用，不能手动调用构造方法</li>
<li>每创建一次对象，就会调用一次构造方法</li>
</ul>
</li>
</ul>
<h4 id="3-构造方法注意事项">3.构造方法注意事项</h4>
<ul>
<li>
<p>定义</p>
<ul>
<li>如果没有定义构造方法，系统将给出一个默认的无参数构造方法</li>
<li>如果定义了构造方法，系统将不再提供默认的构造方法</li>
</ul>
</li>
<li>
<p>重载</p>
<ul>
<li>带参构造方法，和无参数构造方法，两者方法名相同，但是参数不同，这就叫构造方法的重载</li>
</ul>
</li>
<li>
<p>推荐使用方式</p>
<ul>
<li>无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法</li>
</ul>
</li>
</ul>
<h3 id="5-标准JavaBean">5.标准JavaBean</h3>
<ul>
<li>标准的JavaBean类
<ul>
<li>类名要<strong>见名知意</strong></li>
<li>成员变量使用<strong>private修饰</strong></li>
<li>提供至少<strong>两个构造方法</strong>
<ul>
<li>无参构造方法</li>
<li>带全部参数的构造方法</li>
</ul>
</li>
<li>成员方法
<ul>
<li>提供每一个成员变量<strong>对应的set/get</strong></li>
<li>如果还有其他行为，也需要写上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-对象内存图">6.对象内存图</h3>
<h4 id="1-一个对象的内存图">1.一个对象的内存图</h4>
<ul>
<li>例如</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>1.加载class文件到<strong>方法区</strong>
<ul>
<li>main（）同时临时存储到方法区</li>
<li>再加载JavaBean类的class文件
<ul>
<li>包含所有成员变量和成员方法等</li>
</ul>
</li>
</ul>
</li>
<li>2.申明局部变量
<ul>
<li>在栈内存中，main方法进栈后，在方法中开辟一个空间即s</li>
</ul>
</li>
<li>3.在堆内存中开辟一个空间
<ul>
<li>new的Student
<ul>
<li>其中存储所有成员变量</li>
<li>还有成员方法的地址
<ul>
<li>指向方法区的方法</li>
<li>用对象调用方法时可以找到对应方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>4.默认初始化
<ul>
<li>给堆内存中的成员变量默认初始化</li>
</ul>
</li>
<li>5.显示初始化
<ul>
<li>如果一开始赋值了，堆内存中的成员变量就按赋的值初始化</li>
</ul>
</li>
<li>6.构造方法初始化
<ul>
<li>空参构造或者有参构造</li>
</ul>
</li>
<li>7.将堆内存中的地址赋值给左边的局部变量
<ul>
<li>堆内存中的地址值赋值给栈内存中的s</li>
</ul>
</li>
<li>8.方法进栈
<ul>
<li>调用方法</li>
</ul>
</li>
<li>9.方法出栈
<ul>
<li>main方法中调用的方法使用完后先出栈</li>
<li>main方法再出栈
<ul>
<li>其中的变量也消失
<ul>
<li>变量指向的堆内存中的空间也消失</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-多个对象的内存图">2.多个对象的内存图</h4>
<ul>
<li>和一个对象的内存图相似</li>
<li>但是JavaBean类的class文件只需要加载一次</li>
<li>堆内存中的两个方法地址都指向方法区的同一个方法</li>
</ul>
<h4 id="3-两个变量指向同一个对象内存图">3.两个变量指向同一个对象内存图</h4>
<ul>
<li>
<p>和前面的两个数组指向同一个空间相似</p>
</li>
<li>
<p>如果将第一个变量赋值null，表示不存在的空间</p>
<ul>
<li>则这个变量就会和堆内存中的空间的连接断开</li>
<li>输出时就会显示NullPointerException报错</li>
</ul>
</li>
<li>
<p>但是第二个变量和堆内存中的空间并没有断开，所以还能正常输出变量</p>
</li>
<li>
<p>如果两个变量都赋值null则和堆内存的连接都断开，堆内存中的空间就变成会垃圾消失</p>
</li>
</ul>
<h4 id="4-this的内存原理">4.this的内存原理</h4>
<ul>
<li>this的本质：代表方法<strong>调用者的地址值</strong></li>
</ul>
<h4 id="5-基本数据类型和引用数据类型的区别">5.基本数据类型和引用数据类型的区别</h4>
<h5 id="1-基本数据类型">1.基本数据类型</h5>
<ul>
<li>数据直接存储在栈内存中</li>
</ul>
<p># 赋值给其他变量，也是赋的真实的值</p>
<h5 id="2-引用数据类型">2.引用数据类型</h5>
<ul>
<li>栈内存中记录的是其他空间的地址值</li>
</ul>
<p># 赋值给其他变量，赋的<strong>地址值</strong></p>
<h4 id="6-局部变量和成员变量的区别">6.局部变量和成员变量的区别</h4>
<table>
<thead>
<tr>
<th>区别</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>类中的位置不同</td>
<td>类中，方法外</td>
<td>方法内，方法申明上</td>
</tr>
<tr>
<td>初始化值不同</td>
<td>有默认初始化值</td>
<td>没有，使用之前需要完成赋值</td>
</tr>
<tr>
<td>内存位置不同</td>
<td>堆内存</td>
<td>栈内存</td>
</tr>
<tr>
<td>生命周期不同</td>
<td>随着对象的创建而存在，随着对象的消失而消失</td>
<td>随着方法的调用而存在，随着方法的运行结束而消失</td>
</tr>
<tr>
<td>作用域</td>
<td>整个类中有效</td>
<td>当前方法中有效</td>
</tr>
</tbody>
</table>
<h2 id="7-字符串">7.字符串</h2>
<h3 id="1-API">1.API</h3>
<ul>
<li>API（Application Programming Interface）：应用程序编程接口</li>
</ul>
<h3 id="2-String">2.String</h3>
<h4 id="1-概述-4">1.概述</h4>
<ul>
<li>
<p>java.lang.String类代表字符串，java程序中的所有字符串文字都为此类的对象</p>
</li>
<li>
<p>字符串的内容是不会发生改变的，它的对象在创建后不能被改变</p>
</li>
</ul>
<p># 要修改就要先对原字符串，创建一个数组，里面存储每个字符，再修改对应的字符</p>
<h4 id="2-创建String对象的两种方式">2.创建String对象的两种方式</h4>
<h5 id="1-直接赋值">1.直接赋值</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Sting</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-new">2.new</h5>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String()</td>
<td>创建空白字符串，不含任何内容</td>
</tr>
<tr>
<td>public String(String original)</td>
<td>根据传入的字符串，创建字符串对象</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符数组，创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] chs)</td>
<td>根据字节数组，创建字符串对象</td>
</tr>
</tbody>
</table>
<p># 后两个都要先创建一个对应的数组即char[] chs和byte[] chs</p>
<h5 id="3-内存分析">3.内存分析</h5>
<ul>
<li>有一个单独的串池（StringTable）</li>
</ul>
<p># 7以前在方法区，后在堆内存中</p>
<ul>
<li>
<p><strong>直接创建</strong> 的，在赋值时，系统先在串池观察是否有这个字符串，如果没有则创建，然后将地址赋值到栈内存中的变量，如果有则直接赋值到栈内存中的变量（复用）</p>
</li>
<li>
<p>new的，不会涉及到串池，直接在堆内存中开辟空间，直接把地址值赋值到栈内存中，不会有复用现象，占用更多空间</p>
</li>
</ul>
<p># 键盘录入的也是new的</p>
<h3 id="3-String的比较">3.String的比较</h3>
<h4 id="1-号">1.==号</h4>
<h5 id="1-基本数据类型-2">1.基本数据类型</h5>
<ul>
<li>比较的是具体的数据值</li>
</ul>
<h5 id="2-引用数据类型-2">2.引用数据类型</h5>
<ul>
<li>比较的是数据的的地址值</li>
</ul>
<h4 id="2-bolean-equals方法">2.bolean equals方法</h4>
<ul>
<li>变量名.equals(要比较的字符串)：完全一样结果才是true，否则为false</li>
</ul>
<h4 id="3-bolean-equalslgnoreCase方法">3.bolean equalslgnoreCase方法</h4>
<ul>
<li>变量名.equalslgnoreCase(要比较的字符串)：忽略大小写的比较</li>
</ul>
<h3 id="4-StringBuilder">4.StringBuilder</h3>
<h4 id="1-概述-5">1.概述</h4>
<ul>
<li>StringBuilder可以看作一个容器，创建后里面的内容是可变的</li>
<li>作用：提高字符串的操作效率</li>
</ul>
<h4 id="2-构造方法">2.构造方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringBuilder()</td>
<td>创建一个空白可变字符串对象，不含任何内容</td>
</tr>
<tr>
<td>public StringBuilder(String str)</td>
<td>根据字符串的内容，来创建可变字符串对象</td>
</tr>
</tbody>
</table>
<h4 id="3-常用方法">3.常用方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringBuilder append(任意类型)</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>public StringBuilder reverse()</td>
<td>反转容器中的内容</td>
</tr>
<tr>
<td>public int length()</td>
<td>返回长度（字符出现的个数）</td>
</tr>
<tr>
<td>public String toString()</td>
<td>通过toString()就可以实现把StringBuilder转换为String</td>
</tr>
</tbody>
</table>
<h3 id="5-StringJoiner">5.StringJoiner</h3>
<ul>
<li>StringJoiner和StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的</li>
<li>作用：提高字符串的操作效率，而且代码编写更加简洁</li>
</ul>
<p># 因为在jdk8后才出现，所以使用较少</p>
<h4 id="1-构造方法">1.构造方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringJoiner （间隔符号）</td>
<td>创建一个StringJoiner对象，指定拼接时的间隔符号</td>
</tr>
<tr>
<td>public StringJoiner（间隔符号，开始符号，结束符号）</td>
<td>创建一个StringJoiner对象，指定拼接时的间隔符号，开始符号，结束符号</td>
</tr>
</tbody>
</table>
<h4 id="2-成员方法">2.成员方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringJoiner add（添加的内容）</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>public int length（）</td>
<td>返回长度（字符出现的个数）</td>
</tr>
<tr>
<td>public String toString（）</td>
<td>返回一个字符串（该字符串就是拼接之后的结果）</td>
</tr>
</tbody>
</table>
<h3 id="6-字符串原理">6.字符串原理</h3>
<h4 id="1-字符串存储的内存原理">1.字符串存储的内存原理</h4>
<ul>
<li>直接赋值的
<ul>
<li>会<strong>复用</strong> 字符串常量池中的</li>
</ul>
</li>
<li>new出来的
<ul>
<li>不会复用，而是<strong>开辟一个新的空间</strong></li>
</ul>
</li>
</ul>
<h4 id="2-比较的原理">2.==比较的原理</h4>
<ul>
<li><strong>基本数据类型</strong> 比较<strong>数据值</strong></li>
<li><strong>引用数据类型</strong> 比较<strong>地址值</strong></li>
</ul>
<h4 id="3-字符串拼接的底层原理">3.字符串拼接的底层原理</h4>
<ul>
<li>
<p>拼接的时候没有变量，都是字符串</p>
<ul>
<li>触发字符串的优化机制</li>
<li>在编译的时候就已经是最终的结果了</li>
</ul>
</li>
<li>
<p>有变量和字符参与拼接</p>
<ul>
<li>jdk8前使用StringBuilder
<ul>
<li>main方法进栈</li>
<li>变量直接赋值，并且在串池生成一个对应字符串</li>
<li>在堆内存中创建一个StringBuilder的方法，通过append方法将参与的变量和字符放到StringBuilder中</li>
<li>再用toString将其变回字符串，字符串就变成了拼接好的
<ul>
<li>toString中使用了一个名为newString的方法，这个方法在返回的时候是new了一个新的字符串</li>
</ul>
</li>
</ul>
</li>
<li>jdk8
<ul>
<li>先预估最终字符串的长度并创建该长度的数组</li>
<li>把字符存进去后，再把数组整体变成一个字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-StringBuilder提高效率原理图">4.StringBuilder提高效率原理图</h4>
<ul>
<li>main方法进栈</li>
<li>StringBuilder方法进栈，同时在堆内存中开辟空间</li>
<li>调用append方法把字符全部添加到堆内存中的空间中</li>
</ul>
<h4 id="5-StringBuilder原码分析">5.StringBuilder原码分析</h4>
<ul>
<li>在创建的时候会创建一个字节数组，默认<strong>容量</strong> 16，表示最多能存储16</li>
<li>向其中添加字符串时，添加的是ASCII码
<ul>
<li>当添加的字符串大于16，就会扩容，创建一个新的数组，容量=老容量*2+2</li>
<li>如果添加的数据超出了扩容后的容量，则会创建一个当前数据量的容量的数组</li>
</ul>
</li>
</ul>
<h2 id="8-ArrayList">8.ArrayList</h2>
<h3 id="1-集合介绍">1.集合介绍</h3>
<ul>
<li>与数组类似，用于存储元素，但区别于数组的是可以自动扩容</li>
<li>但是集合只能存储引用数据类型
<ul>
<li>如果要存储基本数据类型就要包装类</li>
<li>基本数据类型中int对应Integer，char对应Character，其余数据类型都将首字母大写</li>
</ul>
</li>
</ul>
<h3 id="2-集合">2.集合</h3>
<h4 id="ArrayList">ArrayList</h4>
<ul>
<li>
<p>ArrayList是Java中写好的一个类</p>
</li>
<li>
<p>需要导包：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure>
<h5 id="1-泛型">1.泛型</h5>
<ul>
<li>限定集合中存储数据的类型</li>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;类型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;类型&gt;();</span><br></pre></td></tr></table></figure>
<p># jdk7前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;类型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p># jdk7后</p>
<h5 id="2-成员方法-2">2.成员方法</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(E e)</td>
<td>添加元素，返回值表示是否添加成功</td>
</tr>
<tr>
<td>boolean remove(E e)</td>
<td>删除指定元素，返回值表示是否删除成功</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定索引的元素，返回被删除元素</td>
</tr>
<tr>
<td>E set(int index,E e)</td>
<td>修改指定索引下的元素，返回原来的元素</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>获取指定索引的元素</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中元素的个数</td>
</tr>
</tbody>
</table>
<h2 id="9-面向对象进阶">9.面向对象进阶</h2>
<h3 id="1-static">1.static</h3>
<h4 id="1-static-2">1.static</h4>
<ul>
<li>static表示静态，是Java中的一个修饰符，可以修饰成员方法，成员变量</li>
</ul>
<h5 id="1-静态变量">1.静态变量</h5>
<ul>
<li>
<p>特点：</p>
<ul>
<li>被该类所有对象<strong>共享</strong></li>
<li>不属于对象，属于类</li>
<li><strong>静态变量是随着类的加载而加载的，优先于对象出现</strong></li>
</ul>
</li>
<li>
<p>调用方式：</p>
<ul>
<li>类名调用（推荐）</li>
<li>对象名调用</li>
</ul>
</li>
<li>
<p>内存图</p>
<ul>
<li>
<p>main方法进栈</p>
</li>
<li>
<p>用类名调用静态变量</p>
<ul>
<li>类名的字节码会加载到方法区</li>
<li>在堆内存中会创建一个静态存储位置（静态区）</li>
</ul>
<p># jdk8前静态区在方法区</p>
<ul>
<li>在静态区存入静态变量
<ul>
<li><strong>静态变量是随着类的加载而加载的，优先于对象出现</strong></li>
</ul>
</li>
<li>给变量赋值</li>
</ul>
</li>
<li>
<p>创建一个对象</p>
</li>
<li>
<p>在堆内存中为非静态变量开辟空间</p>
</li>
<li>
<p>给对象的属性赋值</p>
</li>
</ul>
</li>
</ul>
<h5 id="2-静态方法">2.静态方法</h5>
<ul>
<li>
<p>特点：</p>
<ul>
<li>多用于<strong>测试类</strong> 和<strong>工具类</strong>
<ul>
<li>工具类：
<ul>
<li>不描述任何事物的类
<ul>
<li>类名见名知意</li>
<li>私有化构造方法</li>
<li>方法定义为静态便于调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>JavaBean类中很少使用</li>
</ul>
</li>
<li>
<p>调用方式：</p>
<ul>
<li>类名调用（推荐）</li>
<li>对象名调用</li>
</ul>
</li>
</ul>
<h4 id="2-注意事项">2.注意事项</h4>
<ul>
<li>
<p>静态方法只能访问静态变量和静态方法</p>
</li>
<li>
<p>非静态方法可以访问静态变量或静态方法，也可以访问非静态的成员变量和非静态的成员方法</p>
</li>
<li>
<p>静态方法中没有this关键字</p>
</li>
<li>
<p>内存图</p>
<ul>
<li>静态：
<ul>
<li>随着类的加载而加载</li>
</ul>
</li>
<li>非静态：
<ul>
<li>跟对象有关</li>
</ul>
</li>
<li>静态方法不能访问非静态变量（实例变量）：
<ul>
<li>main方法进栈</li>
<li>将对象的字节码文件加载到方法区
<ul>
<li>包含对象的属性变量和方法</li>
</ul>
</li>
<li>将静态的变量存到堆内存中的静态区</li>
<li>静态方法进栈</li>
<li>方法调用变量会到静态区调用
<ul>
<li>但是静态区中只有静态的变量，非静态的在方法区</li>
</ul>
</li>
</ul>
</li>
<li>非静态可以访问所有：
<ul>
<li>main方法进栈</li>
<li>将对象的字节码文件加载到方法区
<ul>
<li>包含对象的属性变量和方法</li>
</ul>
</li>
<li>将静态的变量存到堆内存中的静态区</li>
<li>有new在堆内存中开辟空间
<ul>
<li>存储对象的属性变量</li>
<li>空间关联静态区</li>
</ul>
</li>
<li>空间的地址赋值给栈内存中的变量</li>
<li>非静态方法调用到堆内存中访问开辟的空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-继承">2.继承</h3>
<h4 id="1-概述-6">1.概述</h4>
<ul>
<li>
<p>面向对象的三大特点之一</p>
</li>
<li>
<p>Java中提供一个关键字extends，用这个关键字，可以让一个类和另一个类建立起继承关系</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Student称为<strong>子类（派生类）</strong>，Person称为<strong>父类（基类或超类）</strong></p>
</li>
<li>
<p>将多个子类中重复的代码抽取到父类中，提高了代码的复用性</p>
</li>
<li>
<p>子类可以在父类的基础上，增加其他功能，使子类更强大</p>
</li>
</ul>
<h4 id="2-什么时候使用继承">2.什么时候使用继承</h4>
<ul>
<li>在类与类之间，存在相同的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码</li>
</ul>
<h4 id="3-特点">3.特点</h4>
<ul>
<li>Java只支持单继承，不支持多继承，但支持多层继承，子类只能<strong>访问</strong> 父类中非私有的成员</li>
<li>只支持单继承：
<ul>
<li>一个子类只能继承一个父类</li>
</ul>
</li>
<li>不支持多继承：
<ul>
<li>子类不能同时继承多个父类</li>
</ul>
</li>
<li>支持多层继承：
<ul>
<li>子类的父类可以有父类
<ul>
<li>父类的父类就是子类的<strong>间接父类</strong></li>
<li>所有类都直接或间接继承<strong>Object</strong>
<ul>
<li>默认继承于<strong>Object</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-子类能继承的">4.子类能继承的</h4>
<table>
<thead>
<tr>
<th>父类中的</th>
<th>非私有</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造方法</td>
<td>不能</td>
<td>不能</td>
</tr>
<tr>
<td>成员变量</td>
<td>能</td>
<td>能</td>
</tr>
<tr>
<td>成员方法</td>
<td>能</td>
<td>不能</td>
</tr>
</tbody>
</table>
<h5 id="1-构造方法-2">1.构造方法</h5>
<ul>
<li>如果继承父类的构造方法则构造方法的名字和父类相同，但是构造方法的特点是方法名和类名相同</li>
</ul>
<h5 id="2-成员变量-2">2.成员变量</h5>
<ul>
<li>
<p>内存图</p>
<ul>
<li>
<p>main方法进栈</p>
</li>
<li>
<p>字节码加载进方法区</p>
</li>
<li>
<p>将子类的字节码文件加载到方法区</p>
</li>
<li>
<p>将子类的父类的字节码文件加载到方法区</p>
</li>
<li>
<p>在栈内存中声明变量</p>
<ul>
<li>在堆内存中开辟空间
<ul>
<li>把这个空间一分为二</li>
<li>存储子类和父类的成员</li>
</ul>
</li>
</ul>
</li>
<li>
<p>赋值时，先在堆内存的子类中找是否有对应的成员，没有则在父类中找，再赋值</p>
</li>
</ul>
</li>
</ul>
<p># 但是如果父类中的变量private了，则不能赋值</p>
<h5 id="3-成员方法">3.成员方法</h5>
<ul>
<li>不会直接继承方法</li>
<li>而是会有一个<strong>虚方法表</strong>
<ul>
<li>虚方法：
<ul>
<li>非private</li>
<li>非static</li>
<li>非final</li>
</ul>
</li>
</ul>
</li>
<li>每个子类中继承父类的虚方法表的同时再加上自己的虚方法，然后给其子类继承</li>
</ul>
<h4 id="5-继承中的访问特点">5.继承中的访问特点</h4>
<h5 id="1-成员变量">1.成员变量</h5>
<ul>
<li>就近原则：逐级查找最近的变量</li>
<li>如果几个类中的变量重名：
<ul>
<li>不加关键字：从局部开始向上找</li>
<li>加this关键字：从本类中开始向上找</li>
<li>加super关键字：从父类中开始向上找</li>
</ul>
</li>
</ul>
<h5 id="2-成员方法-3">2.成员方法</h5>
<ul>
<li>
<p>与成员变量的特点相同</p>
</li>
<li>
<p>方法的重写：当父类的方法不能满足子类现在的需求时，需要进行方法重写</p>
<ul>
<li>
<p>书写格式：在继承体系中，子类出现了和父类一样的方法声明，则这个子类的方法就是重写的方法</p>
</li>
<li>
<p>@Override重写注解：@Override写在重写后的方法上，校验子类重写时语法是否正确</p>
</li>
<li>
<p>本质：将原来继承的虚方法表中的方法覆盖为当前类的方法，其子类继承的虚方法表也就是覆盖后的虚方法表</p>
</li>
</ul>
</li>
<li>
<p>注意事项</p>
<ul>
<li>重写方法的名称和形参列表必须和父类中的一致</li>
<li>子类重写父类方法时，访问权限子类必须大于等于父类</li>
<li>子类重写父类方法时，返回值类型子类必须小于等于父类</li>
<li>只有被添加到虚方法表中的方法才能被重写</li>
</ul>
</li>
</ul>
<h5 id="3-构造方法">3.构造方法</h5>
<ul>
<li>
<p>父类中的构造方法不会被子类继承</p>
</li>
<li>
<p>子类中所有的构造方法默认先访问父类中的无参构造，再执行自己</p>
<ul>
<li>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类就无法使用</li>
<li>子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化</li>
</ul>
</li>
<li>
<p>子类的构造方法第一行语句默认都是super();（不写也是默认存在的），第二行才可以写构造方法</p>
</li>
<li>
<p>如果要调用父类的有参构造，则需要加上super(父类中带参构造的变量名);</p>
</li>
</ul>
<h4 id="6-this，super使用总结">6.this，super使用总结</h4>
<h5 id="1-this">1.this</h5>
<ul>
<li>可以理解为一个变量，表示当前方法调用者的地址值</li>
</ul>
<h5 id="2-super">2.super</h5>
<ul>
<li>代表父类存储空间</li>
</ul>
<h3 id="3-多态">3.多态</h3>
<ul>
<li>面向对象三大特点之一</li>
</ul>
<h4 id="1-概述-7">1.概述</h4>
<ul>
<li>同类型的对象，表现出的不同形态</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 对象名称 = 子类对象;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>前提：</p>
<ul>
<li>有继承关系</li>
<li>有父类引用指向子类对象</li>
<li>有方法重写</li>
</ul>
</li>
<li>
<p>好处：</p>
<ul>
<li>使用父类型作为参数，可以接收所有子类的对象</li>
</ul>
</li>
</ul>
<h4 id="2-调用成员的特点">2.调用成员的特点</h4>
<h5 id="1-变量调用">1.变量调用</h5>
<ul>
<li>编译看左边，运行看左边</li>
</ul>
<p># javac在编译的时候看左边的父类中有没有这个变量，有则能编译成功</p>
<p># 运行时，实际获取的就是左边父类中成员变量的值</p>
<h5 id="2-方法调用">2.方法调用</h5>
<ul>
<li>编译看左边，运行看右边</li>
</ul>
<p># javac在编译的时候看左边的父类中有没有这个方法，有则能编译成功</p>
<p># 运行时，实际运行的是子类中的方法</p>
<h4 id="3-优势">3.优势</h4>
<ul>
<li>在多态形式下，右边对象可以实现解耦合，便于扩展和维护</li>
<li>定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性和便利</li>
</ul>
<h4 id="4-弊端">4.弊端</h4>
<ul>
<li>不能使用子类的特有功能</li>
<li>如果要使用就要转换类型</li>
</ul>
<p># 就可以将其转换为真正的子类类型，从而调用子类的特有功能</p>
<p># 转换类型与真实对象类型不一致会报错</p>
<h5 id="判断是否为某一类型并且强制转换">判断是否为某一类型并且强制转换</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量名<span class="number">1</span> <span class="keyword">instanceof</span> 类型<span class="number">1</span> 变量名<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p># 如果变量名1是类型1则强转为类型1，转换后变量名为变量名2</p>
<p># 如果不是则不强转，结果返回false</p>
<p># 在jdk14后</p>
<h3 id="4-包，final，权限修饰符，代码块">4.包，final，权限修饰符，代码块</h3>
<h5 id="1-包">1.包</h5>
<ul>
<li>
<p>文件夹，用于管理不同功能的Java类，便于后期代码维护</p>
</li>
<li>
<p>包名规则：</p>
<ul>
<li>公司域名反写+包的作用，全部英文小写，见名知意</li>
</ul>
</li>
<li>
<p>全类名（全限定名）：</p>
<ul>
<li>
<p>包名+类名</p>
</li>
<li>
<p>使用其他类时就要使用全类名</p>
</li>
<li>
<p>或者直接导包：</p>
<ul>
<li>import 全类名</li>
</ul>
</li>
<li>
<p>使用同一个包中的类时，不需要导包</p>
</li>
<li>
<p>java.lang包中的类不需要导包</p>
</li>
<li>
<p>如果同时使用两个包中的同名类，需要用全类名</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-final">2.final</h4>
<h5 id="1-修饰方法">1.修饰方法</h5>
<ul>
<li>表示该方法是最终方法，不能被重写</li>
</ul>
<h5 id="2-修饰类">2.修饰类</h5>
<ul>
<li>表示该类是最终类，不能被继承</li>
</ul>
<h5 id="3-修饰变量">3.修饰变量</h5>
<ul>
<li>
<p>叫做常量，只能被赋值一次</p>
<ul>
<li>常量的命名：
<ul>
<li>单个单词：全部大写</li>
<li>多个单词：全部大写，中间用下划线连接</li>
</ul>
</li>
</ul>
</li>
<li>
<p>修饰的变量是基本数据类型：</p>
<ul>
<li>变量存储的数据值不能发生改变</li>
</ul>
</li>
<li>
<p>修饰的变量是引用数据类型：</p>
<ul>
<li>变量存储的地址值不能发生改变，对象内部的可以改变</li>
</ul>
<p># 例如数组中的值可以变，但是数组的地址值是不能变的</p>
</li>
</ul>
<h4 id="3-权限修饰符">3.权限修饰符</h4>
<h5 id="作用范围">作用范围</h5>
<ul>
<li>private&lt;空&lt;protected&lt;public</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类</th>
<th>同一个包中的其他类</th>
<th>不同包下的子类</th>
<th>不同包下的无关类</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody>
</table>
<p># 如果方法中的代码抽取其他方法中共性的代码，这个方法一般也私有</p>
<h4 id="4-代码块">4.代码块</h4>
<h5 id="1-局部代码块">1.局部代码块</h5>
<ul>
<li>{}中的内容，可以其他结束代码块中的变量的生命周期</li>
</ul>
<p># 但是现在已经不需要节省变量的一点空间了</p>
<h5 id="2-构造代码块">2.构造代码块</h5>
<ul>
<li>把构造方法中重复的内容写在成员位置的代码块</li>
<li>执行时机：
<ul>
<li>在创建本类对象的时候会先执行构造代码块再执行构造方法</li>
</ul>
</li>
</ul>
<p># 使用也较少，因为不够灵活</p>
<h5 id="3-静态代码块">3.静态代码块</h5>
<ul>
<li>格式：
<ul>
<li>static{}</li>
</ul>
</li>
<li>特点：
<ul>
<li>需要通过static关键字修饰，随着类的加载而加载，并且自动触发，只执行一次</li>
</ul>
</li>
<li>使用场景：
<ul>
<li>在类加载的时候，做一些数据初始化的时候使用</li>
</ul>
</li>
</ul>
<h3 id="5-抽象类">5.抽象类</h3>
<h4 id="1-抽象方法">1.抽象方法</h4>
<ul>
<li>
<p>一个方法抽取到父类中，但是子类的具体写法不同，这时候就可以写一个抽象方法，起所在的类就是抽象类</p>
</li>
<li>
<p>抽象方法的定义格式：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象类的定义格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-注意事项-2">2.注意事项</h4>
<ul>
<li>抽象类不能实例化
<ul>
<li>即不能创建对象</li>
</ul>
</li>
<li>抽象类不一定有抽象方法，有抽象方法一定是抽象类</li>
<li>抽象类可以有构造方法
<ul>
<li>当创建子类对象时，给属性进行赋值</li>
</ul>
</li>
<li>抽象类的子类
<ul>
<li>重写抽象类中的所有抽象方法</li>
<li>或者是抽象类</li>
</ul>
</li>
</ul>
<h4 id="3-意义">3.意义</h4>
<ul>
<li>强制子类按照格式重写这个抽象方法</li>
<li>在开发时可以更加统一</li>
</ul>
<h3 id="6-接口">6.接口</h3>
<ul>
<li>一个父类下的几个子类，其他几个可以共享一个方法，但也有不能使用这个方法的，这样就不能写在父类中</li>
<li>这时候就需要接口，只给几个子类使用</li>
<li>和抽象类很像
<ul>
<li>但是一般只表示行为</li>
<li>一般不像抽象类表示一种事物</li>
</ul>
</li>
</ul>
<h4 id="1-定义接口并使用接口">1.定义接口并使用接口</h4>
<ul>
<li>接口用关键字interface来定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口不能实例化</li>
<li>接口和类之间是实现关系，通过implements关键字表示</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口的子类（实现类）
<ul>
<li>重写接口中的所有抽象方法</li>
<li>或者是抽象类</li>
</ul>
</li>
</ul>
<h4 id="2-接口中的成员特点">2.接口中的成员特点</h4>
<h5 id="1-成员变量-2">1.成员变量</h5>
<ul>
<li>只能是常量</li>
<li>默认修饰符：public static final</li>
</ul>
<h5 id="2-构造方法-2">2.构造方法</h5>
<ul>
<li>无</li>
</ul>
<h5 id="3-成员方法-2">3.成员方法</h5>
<ul>
<li>只能是抽象方法</li>
<li>默认修饰符：public abstract</li>
</ul>
<p># jdk7前接口中只能定义抽象方法</p>
<h4 id="3-接口和类之间的关系">3.接口和类之间的关系</h4>
<h5 id="1-类和类">1.类和类</h5>
<ul>
<li>继承关系，只能单继承，不能多继承，但是可以多层继承</li>
</ul>
<h5 id="2-类和接口">2.类和接口</h5>
<ul>
<li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li>
</ul>
<p># 在多个接口中有重名的方法，重写的时候所有方法只需要重写一次即可</p>
<h5 id="3-接口和接口">3.接口和接口</h5>
<ul>
<li>继承关系，可以单继承，也可以多继承</li>
</ul>
<p># 实现类在实现的时候就要把接口的继承体系中的所有方法都重写</p>
<h4 id="4-JDK8后的接口">4.JDK8后的接口</h4>
<ul>
<li>
<p>可以定义有方法体的方法，即默认方法</p>
<ul>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以不强制重写，但是重写的时候就要把default去掉</li>
<li>当多个接口中有相同名字的默认方法，子类必须对该方法重写</li>
</ul>
</li>
<li>
<p>允许在接口中定义静态方法，用static修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只能通过接口名调用，不能通过实现类名或者对象名调用</li>
</ul>
</li>
<li>
<p>可以定义私有的方法</p>
<ul>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于静态的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于抽取出方法中重复的代码，再给方法调用，但是不让其他方法调用</li>
</ul>
</li>
</ul>
<p># 私有方法在jdk9后</p>
<h4 id="5-接口的应用">5.接口的应用</h4>
<ul>
<li>
<p>接口代表规则，是行为的抽象，要让一个类拥有这个行为，就让这个类实现对应接口</p>
</li>
<li>
<p>当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方法称之为接口多态</p>
</li>
</ul>
<h4 id="6-适配器设计模式">6.适配器设计模式</h4>
<ul>
<li>
<p><strong>设计模式</strong> ：</p>
<ul>
<li>是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结，使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性，程序的重用性</li>
</ul>
</li>
<li>
<p><strong>适配器设计模式</strong> ：</p>
<ul>
<li>解决接口与接口实现类之间的矛盾问题</li>
<li>当一个接口中有很多抽象方法，但有时候只需要用到其中一部分的时候
<ul>
<li>先编写一个中间类，实现对应接口，对接口中的抽象方法进行空实现，即不写方法体</li>
<li>让真正的实现类继承中间类，并重写需要用到的方法</li>
<li>为了避免其他类创建适配器类的对象，中间类用abstract修饰</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-内部类">7.内部类</h3>
<ul>
<li>
<p>类的五大成员之一</p>
</li>
<li>
<p>在一个类中，再定义一个类</p>
</li>
<li>
<p>内部类表示的事物是外部类的一部分</p>
</li>
<li>
<p>内部类单独出现没有任何意义</p>
</li>
<li>
<p>访问特点：</p>
<ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类要访问内部类的成员，必须创建对象</li>
</ul>
</li>
</ul>
<h4 id="1-成员内部类">1.成员内部类</h4>
<ul>
<li>写在成员位置的，属于外部类的成员</li>
</ul>
<h5 id="1-如何书写">1.如何书写</h5>
<ul>
<li>可以被一些修饰符修饰</li>
<li>成员内部类中的成员，在jdk16后可以定义静态变量</li>
</ul>
<h5 id="2-创建成员内部类">2.创建成员内部类</h5>
<ul>
<li>在外部类中编写方法，对外提供内部类的对象</li>
</ul>
<p># 在内部类私有的时候使用</p>
<p>或</p>
<ul>
<li>直接创建：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = 外部类对象.内部类对象;</span><br></pre></td></tr></table></figure>
<h5 id="3-成员内部类如何获取外部类的成员变量">3.成员内部类如何获取外部类的成员变量</h5>
<ul>
<li>
<p>没有重名的时候可以直接调用</p>
</li>
<li>
<p>有重名时则会<strong>就近原则</strong></p>
</li>
<li>
<p>用this可以调用内部类的方法外的变量</p>
</li>
<li>
<p>要调用外部类的变量则要用<strong>外部类名.this.变量名</strong></p>
</li>
<li>
<p>内存图</p>
<ul>
<li>内部类和外部类是两个字节码加载到方法区</li>
<li>堆内存中开辟两个空间
<ul>
<li>一个是外部类</li>
<li>一个是内部类
<ul>
<li>内部类中除了其本身的成员，还有一个隐藏的this记录外部类对象的地址值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-静态内部类">2.静态内部类</h4>
<ul>
<li>
<p>成员内部类的一种特殊情况</p>
</li>
<li>
<p>被用static修饰</p>
</li>
<li>
<p>创建静态内部类对象的格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.内部类名;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>调用非静态方法的格式</p>
<ul>
<li>先创建对象，用对象调用</li>
</ul>
</li>
<li>
<p>调用静态方法的格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类名.内部类名.方法名();</span><br></pre></td></tr></table></figure>
<h4 id="3-局部内部类">3.局部内部类</h4>
<ul>
<li>将内部类定义在方法里面，类似于方法里面的局部变量</li>
<li>外界是无法直接使用的，需要在方法内部创建对象并使用</li>
<li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li>
</ul>
<h4 id="4-匿名内部类">4.匿名内部类</h4>
<ul>
<li>本质就是隐藏了名字的内部类</li>
<li>可以写在成员位置，也可以写在局部位置</li>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名()&#123;</span><br><span class="line">	重写方法;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>其实际名字：外部类名$序号</li>
<li>这个整体就是一个类的子类对象或者是一个接口的实现类对象</li>
<li>应用场景
<ul>
<li>当方法的参数是接口或者类时</li>
<li>可以传递这个接口的实现类对象</li>
<li>但是如果这个实现类对象只使用一次，就没必要定义，可以用匿名内部类简化代码</li>
</ul>
</li>
</ul>
<h2 id="10-常用API">10.常用API</h2>
<h3 id="1-Math">1.Math</h3>
<ul>
<li>用于进行数学计算的工具类</li>
<li><strong>私有化构造方法，所有方法都是静态的</strong></li>
<li>用<strong>Math.方法名</strong> 调用</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public static int abs(int a)</td>
<td>获取参数绝对值</td>
</tr>
<tr>
<td style="text-align:left">public static double ceil(double a)</td>
<td>向上取整</td>
</tr>
<tr>
<td style="text-align:left">public static double floor(float a)</td>
<td>向下取整</td>
</tr>
<tr>
<td style="text-align:left">public static int round(float a)</td>
<td>四舍五入</td>
</tr>
<tr>
<td style="text-align:left">public static int max(int a, int b)</td>
<td>获取两个int值中的较大值</td>
</tr>
<tr>
<td style="text-align:left">public static double pow(double a,double b)</td>
<td>返回a的b次幂的值</td>
</tr>
<tr>
<td style="text-align:left">public static double random()</td>
<td>返回值为double的随机值，0.0-1.0，包含0.0，不包含1.0</td>
</tr>
</tbody>
</table>
<p># 在int类型中的最小值-2147483648没有绝对值</p>
<h3 id="2-System">2.System</h3>
<ul>
<li>工具类，提供了一些于系统相关的方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static void exit(int status)</td>
<td>终止当前运行的Java虚拟机，其中0为正常停止，非0为异常停止</td>
</tr>
<tr>
<td>public static long currentTimeMills()</td>
<td>返回当前系统的时间毫秒值形式</td>
</tr>
<tr>
<td>public static void arraycopy(数据源数组，起始索引，目的地数组，起始索引，拷贝个数)</td>
<td>数组拷贝</td>
</tr>
</tbody>
</table>
<p># 数组拷贝时如果是基本数据类型则数据类型要一致，如果是引用数据类型则子类类型可以赋值给父类类型也不能超过数组长度</p>
<h3 id="3-Runtime">3.Runtime</h3>
<ul>
<li>表示当前虚拟机的运行环境</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static Runtime grtRuntime()</td>
<td>当前系统的运行环境对象</td>
</tr>
<tr>
<td>public void exit(int status)</td>
<td>停止虚拟机</td>
</tr>
<tr>
<td>public int availableProcessors()</td>
<td>获得CPU的线程数</td>
</tr>
<tr>
<td>public long maxMemory()</td>
<td>JVM能从系统中获取总内存大小（单位byte）</td>
</tr>
<tr>
<td>public long totalMemory()</td>
<td>JVM已经从系统中获取总内存大小（单位byte）</td>
</tr>
<tr>
<td>public long freeMemory()</td>
<td>JVM剩余内存大小（单位byte）</td>
</tr>
<tr>
<td>public Process exec(String command)</td>
<td>运行cmd命令</td>
</tr>
</tbody>
</table>
<h3 id="4-Object和Objects">4.Object和Objects</h3>
<ul>
<li>Java中的父类，所有类都直接或简洁的继承于Object类</li>
</ul>
<h4 id="1-Object的构造方法">1.Object的构造方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Object()</td>
<td>空参构造</td>
</tr>
</tbody>
</table>
<h4 id="2-Object的成员方法">2.Object的成员方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String toString()</td>
<td>返回对象的字符串表示形式</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>比较两个对象是否相等</td>
</tr>
<tr>
<td>protected Object clone(int a)</td>
<td>对象克隆</td>
</tr>
</tbody>
</table>
<p># Object中的equals比较的是地址值，一般需要重写用alt+insert选择自动重写，可以比较具体的属性</p>
<p># toString一般也会重写，打印对象时打印属性</p>
<h4 id="3-对象克隆">3.对象克隆</h4>
<ul>
<li>把A对象的属性值完全拷贝给B对象，也叫对象拷贝，对象复制</li>
<li>要重写Object中的clone方法</li>
<li>在JavaBean类中实现接口</li>
</ul>
<h5 id="1-浅克隆">1.浅克隆</h5>
<ul>
<li>基本数据类型直接拷贝数据</li>
<li>引用数据类型直接拷贝地址值</li>
</ul>
<h5 id="2-深克隆">2.深克隆</h5>
<ul>
<li>基本数据类型直接拷贝数据</li>
<li>字符串复用串池的</li>
<li>引用数据类型
<ul>
<li>例如数组</li>
<li>先创建一个新的数组</li>
<li>把原来数组的数据拷贝到新的数组中</li>
<li>再把新的数组的地址值给对象</li>
</ul>
</li>
</ul>
<h4 id="4-Objects">4.Objects</h4>
<ul>
<li>一个工具类，提供一些方法去完成一些功能</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static boolean equals(Object a,Object b)</td>
<td>先做非空判断，比较两个对象</td>
</tr>
<tr>
<td>public static boolean isNull(Object obj)</td>
<td>判断对象是否为null，为null返回true，反之</td>
</tr>
<tr>
<td>public static boolean nonNull(Object obj)</td>
<td>判断对象是否为null，是isNull的结果相反</td>
</tr>
</tbody>
</table>
<h3 id="5-BigInteger和BigDecimal">5.BigInteger和BigDecimal</h3>
<h4 id="1-BigInteger">1.BigInteger</h4>
<h5 id="1-构造方法-3">1.构造方法</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public BigInteger(int num,Random rnd)</td>
<td>获取随机大整数，范围：0~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{num}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
<tr>
<td>public BigInteger(String val)</td>
<td>获取指定的大整数，字符串中必须是整数</td>
</tr>
<tr>
<td>public BigInteger(String val,int radix)</td>
<td>获取指定进制的大整数</td>
</tr>
<tr>
<td>public static BigInteger valueOf(long val)</td>
<td>静态方法获取BigInteger的对象，内部有优化，对常用数字-16~16进行了优化，会提前创建好，如果多次获取不会重新创建新的</td>
</tr>
</tbody>
</table>
<p># 对象一旦创建，内部记录的值不能发生改变</p>
<h5 id="2-常见成员方法">2.常见成员方法</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public BigInteger add(BigInteger val)</td>
<td>加法</td>
</tr>
<tr>
<td>public BigInteger subtract(BigInteger val)</td>
<td>减法</td>
</tr>
<tr>
<td>public BigInteger multiply(BigInteger val)</td>
<td>乘法</td>
</tr>
<tr>
<td>public BigInteger divide(BigInteger val)</td>
<td>除法，获取商</td>
</tr>
<tr>
<td>public BigInteger[] divideAndRemainder(BigInteger val)</td>
<td>除法，获取商和余数，返回数组，0索引的为商，1索引的为余数</td>
</tr>
<tr>
<td>public bollean equals(Object x)</td>
<td>比较是否相同，比较的是属性值</td>
</tr>
<tr>
<td>public BigInteger pow(int exponent)</td>
<td>次幂</td>
</tr>
<tr>
<td>public BigInteger max/min(BigInteger val)</td>
<td>返回较大值/较小值</td>
</tr>
<tr>
<td>public int inValue(BigInteger val)</td>
<td>转为int类型整数，超出范围数据有误</td>
</tr>
</tbody>
</table>
<h5 id="3-底层存储方式">3.底层存储方式</h5>
<ul>
<li>先把一个大整数转化成补码</li>
<li>再把补码每32位分为一组</li>
<li>再把每一组转成各自的十进制</li>
<li>再按顺序放到一个数组中
<ul>
<li>数组的最大长度的理论值是int的最大值：2147483647约为21亿</li>
<li>数组中的每一位能表示的数字范围：-2147483648~2147483647约为42亿</li>
<li>所以BigInteger能表示的最大数字为42亿的21亿次方
<ul>
<li>几乎是无限的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-BigDecimal">2.BigDecimal</h4>
<ul>
<li>计算机中用二进制存储小数通常需要很多位</li>
<li>而在Java中</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用字节数</th>
<th>总bit位数</th>
<th>小数部分bit位数</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4个字节</td>
<td>32个bit位</td>
<td>23个bit位</td>
</tr>
<tr>
<td>double</td>
<td>8个字节</td>
<td>64个bit位</td>
<td>52个bit位</td>
</tr>
</tbody>
</table>
<h5 id="1-作用">1.作用</h5>
<ul>
<li>用于小数的精确计算</li>
<li>用于表示很大的小数</li>
</ul>
<h5 id="2-创建对象">2.创建对象</h5>
<ul>
<li>通过传递double类型的小数来创建对象</li>
</ul>
<p># 可能不精确</p>
<ul>
<li>
<p>通过传递字符串表示的小数来创建对象</p>
</li>
<li>
<p>通过静态方法获取对象</p>
</li>
</ul>
<p># 如果要表示的数字没有超过double的范围，建议使用这种方法</p>
<p># 如果传递0~10之间的整数，包含0和10，那么方法会返回已经创建好的对象，不会new</p>
<h5 id="3-使用">3.使用</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static BigDecimal valueOf(double val)</td>
<td>获取对象</td>
</tr>
<tr>
<td>public BigDecimal add(BigDecimal val)</td>
<td>加法</td>
</tr>
<tr>
<td>public BigDecimal subtract(BigDecimal val)</td>
<td>减法</td>
</tr>
<tr>
<td>public BigDecimal multiply(BigDecimal val)</td>
<td>乘法</td>
</tr>
<tr>
<td>public BigDecimal divide(BigDecimal val)</td>
<td>除法</td>
</tr>
<tr>
<td>public BigDecimal divide(BigDecimal val,精确几位,舍入模式)</td>
<td>除法</td>
</tr>
</tbody>
</table>
<h5 id="4-底层存储方式">4.底层存储方式</h5>
<ul>
<li>将要存储的字符串形式的小数</li>
<li>先遍历每一个字符</li>
<li>然后将这些字符对应的ASCII码存储到数组中</li>
</ul>
<h4 id="6-正则表达式">6.正则表达式</h4>
<ul>
<li>用**.matches(“规则”)** 使用正则表达式</li>
</ul>
<h5 id="1-作用-2">1.作用</h5>
<ul>
<li>校验字符串是否满足规则</li>
<li>在一段文本中查找满足要求的内容</li>
</ul>
<h5 id="2-规则">2.规则</h5>
<p>字符类（只匹配一个字符）</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]</td>
<td>只能是a，b或c</td>
</tr>
<tr>
<td>[^abc]</td>
<td>除了a，b，c之外的任何字符</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>a到z A到Z</td>
</tr>
<tr>
<td>[a-d[m-p]]</td>
<td>a到d，或m到p</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[def]]</td>
<td>a-z和d，e，f的交集，即d，e，f</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[^bc]]</td>
<td>a-z和非bc的交集（等同于[ad-z]）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[^m-p]]</td>
<td>a到z和除了m到p的交集（等同于[a-lq-z]</td>
</tr>
</tbody>
</table>
<p>预定义字符（只匹配一个字符）</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任何字符</td>
</tr>
<tr>
<td>\d</td>
<td>一个数字[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字[^0-9]</td>
</tr>
<tr>
<td>\s</td>
<td>一个空白字符[\t\n\x08\f\r]</td>
</tr>
<tr>
<td>\S</td>
<td>非空白字符[^\s]</td>
</tr>
<tr>
<td>\w</td>
<td>[a-zA-A_0-9]英文，数字，下划线</td>
</tr>
<tr>
<td>\W</td>
<td>[^\w]一个非单词字符</td>
</tr>
</tbody>
</table>
<p># 用的时候在\前再加一个\</p>
<p>数量词</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>X?</td>
<td>X，一个或0次</td>
</tr>
<tr>
<td>X*</td>
<td>X，0次或多次</td>
</tr>
<tr>
<td>X+</td>
<td>X，一个或多次</td>
</tr>
<tr>
<td>X{n}</td>
<td>X，正好n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X，至少n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X，至少n次但不超过m次</td>
</tr>
</tbody>
</table>
<h5 id="3-分组">3.分组</h5>
<ul>
<li>用()将规则划分组</li>
<li>以左括号为基准，最左为第一组</li>
</ul>
<h5 id="4-捕获分组">4.捕获分组</h5>
<ul>
<li>后续还要使用本组的数据</li>
<li>在正则内部：
<ul>
<li><strong>\\组号</strong></li>
</ul>
</li>
<li>在正则外部：
<ul>
<li><strong>$组号</strong></li>
</ul>
</li>
</ul>
<h5 id="5-非捕获分组">5.非捕获分组</h5>
<ul>
<li>分组后不需要再使用本组数据，仅仅将数据括起来</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>(?:正则)</td>
<td>获取所有</td>
</tr>
<tr>
<td>(?=正则)</td>
<td>获取前面部分</td>
</tr>
<tr>
<td>(?!正则)</td>
<td>获取不是指定内容的前面部分</td>
</tr>
</tbody>
</table>
<p># 非捕获分组是不会占用组号的</p>
<h4 id="7-JDK7以前时间相关类">7.JDK7以前时间相关类</h4>
<h5 id="1-Date时间类">1.Date时间类</h5>
<ul>
<li>JDK写好的JavaBean类，用来描述时间，精确到毫秒</li>
<li>利用空参构造创建的对象，默认表示系统当前时间</li>
<li>利用有参构造创建的对象，表示指定时间</li>
<li>修改时间对象中的毫秒值
<ul>
<li>setTime(毫秒值);</li>
</ul>
</li>
<li>获取时间对象中的毫秒值
<ul>
<li>getTime();</li>
</ul>
</li>
</ul>
<h5 id="2-SimpleDateFormat类">2.SimpleDateFormat类</h5>
<ul>
<li>格式化：
<ul>
<li>将时间转化形式</li>
</ul>
</li>
<li>解析：
<ul>
<li>将字符串表示的时间变成Date对象</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public SimpleDateFormat()</td>
<td>构造一个SimpleDateFormat，使用默认格式</td>
</tr>
<tr>
<td>public SimpleDateFormat(String pattern)</td>
<td>构造一个SimpleDateFormat，使用指定格式</td>
</tr>
</tbody>
</table>
<p># 其中格式例如：yyyy-MM-dd HH:mm:ss或者yyyy年MM月dd日 HH时mm分ss秒</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public final String format(Date date)</td>
<td>格式化（日期对象转化为字符串）</td>
</tr>
<tr>
<td>public Date parse(String source)</td>
<td>解析（字符串转化为日期对象）</td>
</tr>
</tbody>
</table>
<h5 id="3-Calendar">3.Calendar</h5>
<ul>
<li>
<p>代表系统当前时间的日历对象，可以单独修改，获取时间中的年月日</p>
</li>
<li>
<p>是一个抽象类，不能直接创建对象</p>
</li>
<li>
<p>获取Calendar日历类对象的方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static Calendar getInstance()</td>
<td>获取当前时间的日历对象</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public final Date getTime()</td>
<td>获取日期对象</td>
</tr>
<tr>
<td>public final setTime(Date date)</td>
<td>给日历设置日期对象</td>
</tr>
<tr>
<td>public long getTimeInMillis()</td>
<td>拿到时间毫秒值</td>
</tr>
<tr>
<td>public void setTimeInMillis(long millis)</td>
<td>给日历设置时间毫秒值</td>
</tr>
<tr>
<td>public int get(int field)</td>
<td>取日历中的某个字段信息</td>
</tr>
<tr>
<td>public void set(int field,int value)</td>
<td>修改日历的某个字段信息</td>
</tr>
<tr>
<td>public void add(int field,int amount)</td>
<td>为某个字段增加/减少指定的值</td>
</tr>
</tbody>
</table>
<h4 id="8-JDK8新增时间相关类">8.JDK8新增时间相关类</h4>
<ul>
<li>原有的时间对象是不变的</li>
</ul>
<h5 id="1-Date时间类-2">1.Date时间类</h5>
<ul>
<li>ZoneId：时区</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static Set<String> getAvailableZoneIds()</td>
<td>获取Java中支持的所有时区</td>
</tr>
<tr>
<td>static ZoneId systemDefault()</td>
<td>获取系统默认时区</td>
</tr>
<tr>
<td>static ZoneId of(String zonId)</td>
<td>获取一个指定时区</td>
</tr>
</tbody>
</table>
<ul>
<li>Instant：时间戳</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static Instant now()</td>
<td>获取当前时间的Instant对象（标准时间）</td>
</tr>
<tr>
<td>static Instant ofxxxx(long epochMilli)</td>
<td>根据（秒/毫秒/纳秒）获取Instant对象</td>
</tr>
<tr>
<td>ZonedDate atZone(ZoneId zone)</td>
<td>指定时区</td>
</tr>
<tr>
<td>boolean isxxxx(Instant otherInstant)</td>
<td>判断系列的方法</td>
</tr>
<tr>
<td>Instatnt minusxxx(long millisToSubtract)</td>
<td>减少时间系列的方法</td>
</tr>
<tr>
<td>Instant pulsxxx(long millisToSubstract)</td>
<td>增加时间系列的方法</td>
</tr>
</tbody>
</table>
<p># 其中xxx是Years/Days/Hours/Minutes/Nanos/Seconds/Weeks</p>
<ul>
<li>ZoneDateTime：带时区的时间</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static ZonedDateTime now()</td>
<td>获取当前时间的ZonedDateTime对象</td>
</tr>
<tr>
<td>static ZonedDateTime ofxxxx(……)</td>
<td>获取指定时间的ZonedDateTime对象</td>
</tr>
<tr>
<td>ZonedDateTime withxxx(时间)</td>
<td>修改时间系列的方法</td>
</tr>
<tr>
<td>ZonedDateTime minusxxx(时间)</td>
<td>减少时间系列的方法</td>
</tr>
<tr>
<td>ZonedDateTime plusxxx(时间)</td>
<td>增加时间系列的方法</td>
</tr>
</tbody>
</table>
<h5 id="2-SimpleDateFormat类-2">2.SimpleDateFormat类</h5>
<ul>
<li>DateTimeFoemat：用于时间的格式化和解析</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static DateTimeFormatter ofPattern(格式)</td>
<td>获取格式对象</td>
</tr>
<tr>
<td>String format(时间对象)</td>
<td>按照指定方式格式化</td>
</tr>
</tbody>
</table>
<h5 id="3-Calendar-2">3.Calendar</h5>
<ul>
<li>LocalDate：年月日</li>
<li>LocalTime：时分秒</li>
<li>LocalDateTime：年月日时分秒</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static xxx now()</td>
<td>获取当前时间的对象</td>
</tr>
<tr>
<td>static xxx of(……)</td>
<td>获取指定时间的对象</td>
</tr>
<tr>
<td>get开头的方法</td>
<td>获取日历中的年月日时分秒风信息</td>
</tr>
<tr>
<td>isBefore，isAfter</td>
<td>比较两个LocalDate</td>
</tr>
<tr>
<td>with开头的</td>
<td>修改时间系列的方法</td>
</tr>
<tr>
<td>minus开头的</td>
<td>减少时间系列的方法</td>
</tr>
<tr>
<td>plus开头的</td>
<td>增加时间系列的方法</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public LocalDate toLoacalDate()</td>
<td>LocalDateTime转换成一个LocalDate对象</td>
</tr>
<tr>
<td>public LocalTime toLocalTime()</td>
<td>LocalDateTime转换成一个LocalTime对象</td>
</tr>
</tbody>
</table>
<h5 id="4-工具类">4.工具类</h5>
<ul>
<li>Duration：时间间隔（秒，纳秒）</li>
<li>Period：时间间隔（年月日）</li>
<li>ChronnUnit：时间间隔（所有单位）</li>
</ul>
<h4 id="9-包装类">9.包装类</h4>
<ul>
<li>
<p>基本数据类型对应的引用类型</p>
</li>
<li>
<p>基本数据类型中int对应Integer，char对应Character，其余数据类型都将首字母大写</p>
</li>
<li>
<p>在JDK5提出一个机制：</p>
<ul>
<li>自动装箱
<ul>
<li>把基本数据类型自动的变成其对应的包装类</li>
</ul>
</li>
<li>自动拆箱
<ul>
<li>把包装类自动的变成其对应的基本数据类型</li>
</ul>
</li>
</ul>
</li>
<li>
<p>int和Integer可以看作一个东西，在内部会自动转换</p>
</li>
<li>
<p>Integer成员方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static String toBinaryString(int i)</td>
<td>得到二进制</td>
</tr>
<tr>
<td>public static String toOctalString(int i)</td>
<td>得到八进制</td>
</tr>
<tr>
<td>public static String toHexString(int i)</td>
<td>得到十六进制</td>
</tr>
<tr>
<td>public static int paresInt(String s)</td>
<td>把字符串类型的整数转换为int类型的整数</td>
</tr>
</tbody>
</table>
<p>​</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL进阶</title>
    <url>/2025/08/27/MySQL%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>MySQL进阶</h1>
<h2 id="1-储存引擎">1.储存引擎</h2>
<h3 id="1-MySQL体系结构">1.MySQL体系结构</h3>
<ul>
<li>
<p>客户端连接器：PHP,Python，Java的JDBC等</p>
</li>
<li>
<p>MySQL服务端：</p>
</li>
<li>
<p>连接层：</p>
<ul>
<li>连接池，用于接收客户端的连接，完成连接的处理，认证授权（校验用户名密码），校验每个客户端的权限，相关安全方案，检查是否超过最大连接数</li>
</ul>
</li>
<li>
<p>服务层：SQL接口，完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程，函数等</p>
<ul>
<li>SQL接口</li>
<li>解析器</li>
<li>查询优化器</li>
<li>缓存</li>
</ul>
</li>
<li>
<p>引擎层：复杂数据的存储和提取，服务器通过API和存储引擎进行通信。其中含有多个可选择的引擎，不同的存储引擎有不同功能，也可以在此基础上扩展。</p>
<ul>
<li>可插拔存储引擎
<ul>
<li>InnoDB（MySQL5.5后的默认引擎）</li>
<li>NDB</li>
<li>MyISAM</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>
<p>存储层：主要将数据存储在文件系统之上，并完成与存储引擎的交互</p>
<ul>
<li>系统文件</li>
<li>文件和日志</li>
</ul>
</li>
</ul>
<h3 id="2-储存引擎简介">2.储存引擎简介</h3>
<ul>
<li>存储数据，建立索引，查询/更新数据等技术的实现方式。</li>
<li>存储引擎是基于表的，而不是基于库的，所以存储引擎也可以称为表类型</li>
</ul>
<h4 id="1-查询表的存储引擎">1.查询表的存储引擎</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create table</span> 表名；</span><br></pre></td></tr></table></figure>
<ul>
<li>用查询建表语句查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `user1` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  `gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `id_for_connent` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `name` (`name`),</span><br><span class="line">  KEY `fk_user1_name_dept_id` (`id_for_connent`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_user1_name_dept_id` <span class="keyword">FOREIGN KEY</span> (`id_for_connent`) <span class="keyword">REFERENCES</span> `dept` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `user1_chk_1` <span class="keyword">CHECK</span> (((`age` <span class="operator">&gt;</span> <span class="number">0</span>) <span class="keyword">and</span> (`age` <span class="operator">&lt;=</span> <span class="number">120</span>)))</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci COMMENT<span class="operator">=</span><span class="string">&#x27;用于学习约束的用户表&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>其中查询出的<strong>ENGINE=InnoDB</strong> 就是存储引擎，InnoDB为默认引擎</p>
</li>
<li>
<p><strong>AUTO_INCREMENT=4</strong> 代表id是自增的</p>
</li>
<li>
<p><strong>DEFAULT CHARSET=utf8mb4</strong> 即当前表的默认字符集是utf8mb4</p>
</li>
<li>
<p><strong>COLLATE=utf8mb4_0900_ai_ci</strong> 即排序方式</p>
</li>
</ul>
<h4 id="2-创建表时指定存储引擎">2.创建表时指定存储引擎</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> tables 表名(</span><br><span class="line"></span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>的类型（comment 字段<span class="number">1</span>的注释）,      #注意逗号</span><br><span class="line"></span><br><span class="line">	字段<span class="number">2</span> 字段<span class="number">2</span>的类型（comment 字段<span class="number">2</span>的注释）,</span><br><span class="line"></span><br><span class="line">	........</span><br><span class="line"></span><br><span class="line">) engine<span class="operator">=</span>innodb（comment 表注释）；</span><br></pre></td></tr></table></figure>
<h4 id="3-查看当前数据库支持的存储引擎">3.查看当前数据库支持的存储引擎</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engine；</span><br></pre></td></tr></table></figure>
<ul>
<li>查询后显示</li>
</ul>
<p>engine（引擎名称）       support（是否支持）        comment（描述）       transactions       XA       savepoints</p>
<h3 id="3-储存引擎特点">3.储存引擎特点</h3>
<h4 id="1-InnoDB">1.InnoDB</h4>
<ul>
<li>
<p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>DML（数据的增删改）操作遵循ACID模型（事务的四大特性），支持<strong>事务</strong></li>
<li><strong>行级锁</strong> ，提高并发访问性能</li>
<li>支持<strong>外键</strong> foreign key约束，保证数据的完整性和正确性</li>
</ul>
</li>
<li>
<p>文件：</p>
<ul>
<li>
<p>xxx.ibd:xxx代表的是表名，innodb引擎的每一张表都会对应这样一个表空间文件，储存该表的表结构（frm，sdi），数据和索引</p>
</li>
<li>
<p>#文件不能直接打开，可以在文件夹中打开cmd，<strong>ibd2sdi xxx.idb</strong> 会返回一长串json</p>
</li>
<li>
<p>参数：innodb_file_per_table</p>
</li>
<li>
<p>#可以用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> varialbes <span class="keyword">like</span>‘innodb_file_per_table’;</span><br></pre></td></tr></table></figure>
<p>查看是否打开，打开则表示每张表对应一个表空间文件</p>
</li>
</ul>
</li>
<li>
<p>逻辑存储结构</p>
<ul>
<li>tablespace：表空间，其中包含多个segment
<ul>
<li>segment：段，其中包含多个extent
<ul>
<li>extent：区（大小固定，每个区1M），其中包含多个page（可以包含64个页）
<ul>
<li>page：页（大小固定，每个页16K，页也是磁盘操作的最小单元），其中包含多个row
<ul>
<li>row：行，其中包含最后一次操作事务的id，指针，字段</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-MyISAM">2.MyISAM</h4>
<ul>
<li>
<p>MyISAM是MySQL早期的默认存储引擎</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
</li>
<li>
<p>文件：</p>
<ul>
<li>xxx.MYD：存储数据</li>
<li>xxx.MYI：存储索引</li>
<li>xxx.sdi：存储表结构信息，打开是文本形式的json，json格式化后查看</li>
</ul>
</li>
</ul>
<h4 id="3-Memory">3.Memory</h4>
<ul>
<li>
<p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题，或断电问题的影响，只能将这些表作为临时表或缓存使用</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>内存存放（所以访问速度快）</li>
<li>hash索引（默认）</li>
</ul>
</li>
<li>
<p>xxx.sdi：存储表结构信息</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>—</td>
<td>—支持</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持（5.6后）</td>
<td>支持</td>
<td>—</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td>—</td>
<td>—</td>
</tr>
</tbody>
</table>
<h3 id="4-储存引擎选择">4.储存引擎选择</h3>
<ul>
<li>应根据应用系统的特点选择合适的存储引擎，对于复杂的应用系统，可以根据实际情况选择多种存储引擎
<ul>
<li>InnoDB：是MySQL的默认存储引擎，支持事务，外键。如果应用对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新，删除操作，那么InnoDB存储引擎是比较合适的选择</li>
<li>MyISAM：如果应用是以读写操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性，并发性要求不是很高，那么MyISAM是合适的选择</li>
<li>Memory：将所有数据保存在内存种，访问速度快，通常用于临时表及缓存。Memory的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li>
</ul>
</li>
</ul>
<h2 id="2-索引">2.索引</h2>
<h3 id="1-索引概述">1.索引概述</h3>
<ul>
<li>索引（index）：帮助MySQL<strong>高效获取数据</strong> 的<strong>数据结构（有序）</strong> 。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据上实现高级查找算法，这种数据结构就是索引。</li>
</ul>
<p># 无索引时，例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">40</span>；</span><br></pre></td></tr></table></figure>
<p>会与每一条数据匹配，称为全表扫描，性能极低</p>
<ul>
<li>
<p>优点：</p>
<ul>
<li>提高数据检索的效率，降低数据的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>
</ul>
</li>
<li>
<p>缺点（影响较小）</p>
<ul>
<li>索引列也要占用空间</li>
<li>索引提高了查询效率，但同时也降低更新表的速度，如对表进行insert，update，delete时效率降低</li>
</ul>
</li>
</ul>
<h3 id="2-索引结构">2.索引结构</h3>
<ul>
<li>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构</li>
</ul>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+Tree索引</td>
<td>最常见的索引类型，大部分引擎都支持B+树索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的，只有精确匹配索引列查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R-tree(空间索引)</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间的数据类型，使用较少</td>
</tr>
<tr>
<td>Full-text(全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，ES</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text索引</td>
<td>5.6后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<h4 id="1-二叉树">1.二叉树</h4>
<ul>
<li>
<p>树状图，但是每个节点下最多只有两个分叉</p>
</li>
<li>
<p>缺点：</p>
<ul>
<li>1.极端情况如顺序插入时，会形成一个链表（即斜树，只有左子树或者只有右子树），查询性能大大降低。</li>
<li>2.大数据量情况下，层级较深，检索速度慢</li>
</ul>
</li>
<li>
<p>红黑数只能解决第一个缺点</p>
</li>
</ul>
<h4 id="2-B-Tree（多路平衡查找树）">2.B-Tree（多路平衡查找树）</h4>
<ul>
<li>同样是树状图，但是可以有多个节点，一个节点的子节点个数称为度数（max-degree），每个节点可以存储（度数-1）个key，度数个指针</li>
<li>当插入超过（度数-1）个key时，中间元素则向上裂变，例如数字：23，56，28，49，如果再插入一个数字59，则中间元素49向上裂变，（23，28），（56，59）成为49的两个子节点</li>
</ul>
<h4 id="3-B-Tree">3.B+Tree</h4>
<ul>
<li>与B树类似，但是所有元素都会出现在叶子节点，上面的非叶子节点主要起到索引的作用，叶子节点则存放数据。同时叶子节点形成一个单向链表，每个节点通过指针指向下一个元素</li>
<li>在MySQL中对B+Tree进行了优化，增加了一个指向相邻页子节点的链表指针，形成带有顺序指针的B+Tree，提高区间访问的性能</li>
<li>其中的键值，数据，指针，都是存放在页</li>
</ul>
<p># 假设一行数据大小为1k，那高度为2时可以存储18736字节的数据，高度为3时可以存储21939856字节的数据</p>
<h4 id="4-Hash">4.Hash</h4>
<ul>
<li>
<p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中</p>
</li>
<li>
<p>如果两个或多个键值，映射到同一个槽位上，就产生了hash冲突（hash碰撞），可以通过链表解决</p>
</li>
<li>
<p>特点</p>
<ul>
<li>1.Hash索引只能用于对等比较（=，in），不支持范围查询（between，&gt;,&lt;,…）</li>
<li>2.无法利用索引完成排序操作</li>
<li>3.查询效率高，通常（不出现hash碰撞）只需要一次检索就可以，效率通常要高于B+tree索引</li>
</ul>
</li>
<li>
<p>存储引擎支持</p>
<ul>
<li>MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的</li>
</ul>
</li>
</ul>
<h4 id="5-思考">5.思考</h4>
<ul>
<li>为什么InnoDB存储引擎用B+Tree索引结构
<ul>
<li>相对于二叉树，层级少，搜素效率高</li>
<li>对于B-tree，无论叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li>
<li>相对Hash索引，B+tree支持范围匹配及排序操作</li>
</ul>
</li>
</ul>
<h3 id="3-索引分类">3.索引分类</h3>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>primary</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>unique</td>
</tr>
<tr>
<td>常规索引</td>
<td>定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>fulltext</td>
</tr>
</tbody>
</table>
<ul>
<li>在InnoDB中根据索引的存储形式，又分为两种</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>聚焦索引</td>
<td>将数据存储与索引放在一块，索引结构的叶子节点保存了行数据</td>
<td>必须有，且只有一个</td>
</tr>
<tr>
<td># 叶子节点下对应的是主键和这一行的行数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td>二级索引</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
<tr>
<td># 叶子节点下对应的是索引对应字段和字段对应的主键</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>两个索引都是B+tree索引</p>
</li>
<li>
<p>例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;arm&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这时候就会先根据name这个字段的二级索引查找对应name下面对应的主键，再根据主键去主键的聚焦索引查找对应主键下面的行数据。这个过程称为<strong>回表查询</strong></p>
</li>
<li>
<p>所以根据主键查询的效率要更高</p>
</li>
<li>
<p>聚焦索引选取规则</p>
<ul>
<li>如果存在主键，主键索引就是聚焦索引</li>
<li>如果不存在主键，将使用第一个唯一索引作为聚焦索引</li>
<li>如果以上都没有则自动生成一个rowid作为隐藏的聚焦索引</li>
</ul>
</li>
</ul>
<h3 id="4-索引语法">4.索引语法</h3>
<p>1.创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span><span class="operator">/</span>fulltext index 索引名称 <span class="keyword">on</span> 表名(表中字段名<span class="number">1</span>,.....);</span><br></pre></td></tr></table></figure>
<p># 如果省略unique或者fulltext则创建一个常规索引</p>
<p># 关联一个字段则为单列索引，多个则为联合索引（联合索引）</p>
<p># 索引名称规范一般为<strong>idx_表名_字段名</strong></p>
<p>2.查看索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名\G；</span><br></pre></td></tr></table></figure>
<p># 不加G显示出来的是表格，但是内容过多会导致表格变形，加上G可以使其每行显示一条</p>
<p>3.删除索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名称 <span class="keyword">on</span> 表名；</span><br></pre></td></tr></table></figure>
<h3 id="5-SQL性能分析">5.SQL性能分析</h3>
<h4 id="1-SQL执行频率">1.SQL执行频率</h4>
<ul>
<li>MySQL中通过<strong>show session/global status</strong> 可以提供服务器状态信息。</li>
</ul>
<p># session和global分别为当前会话和全局</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> ’Com_____________<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure>
<p># Com后面有几个下划线则为模糊匹配几个字符，可以查看当前数据库的insert，update，delete，select的访问频次</p>
<h4 id="2-慢查询日志">2.慢查询日志</h4>
<ul>
<li>
<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认不开启，需要在MySQL的配置文件（/etc/my.cnf）中配置</p>
</li>
<li>
<p><strong>slow_query_log=1</strong> 在配置文件中配置开启</p>
</li>
<li>
<p><strong>long_query_time=2</strong> 设置慢查询日志的时间为2秒</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> ‘slow_query_log<span class="string">&#x27;；</span></span><br></pre></td></tr></table></figure>
<p>查询慢查询日志是否打开</p>
<ul>
<li>日志存放在**/var/lib/mysql** 中会有一个以**-slow.log** 结尾的文件</li>
</ul>
<p># 日志中会记录：哪一个用户通过哪一个主机连接,执行用了多少时间，锁了多少行，返回了多少条记录，用的哪一个数据库，执行的时间，执行的语句</p>
<ul>
<li><strong>tail  -f  文件名</strong> 在Linux中这个指令可以查看文件实时输出的内容</li>
</ul>
<h4 id="3-profile详情">3.profile详情</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>；</span><br></pre></td></tr></table></figure>
<p># 通过have_profiling参数，能够看到当前MySQL是否支持profile操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>；</span><br></pre></td></tr></table></figure>
<p># 查看返回数字，是否开启</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>；</span><br></pre></td></tr></table></figure>
<p># 默认profiling是关闭的，可以选择在session/global级别开启</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles；</span><br></pre></td></tr></table></figure>
<p>#查看每一条SQL的耗时基本情况</p>
<p># 会显示query_id，duration，query</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query 指定query_id；</span><br></pre></td></tr></table></figure>
<p># 查看指定query_id的SQL语句各阶段的耗时情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query 指定query_id；</span><br></pre></td></tr></table></figure>
<p># 查看指定query_id的SQL语句cpu的使用情况</p>
<h4 id="4-explain执行计划">4.explain执行计划</h4>
<ul>
<li>explain或者desc命令获取MySQL如何执行select语句的信息，包括select语句执行过程中表如何连接和连接的顺序</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件；</span><br></pre></td></tr></table></figure>
<p># 直接在select语句前加关键字explain/desc</p>
<p># 会显示id，select_type（查询类型）,table（使用的表），partitions（分区），type（连接的类型），possible_keys（可能用到的索引），key（实际用到的索引），key_len（索引长度），rows（扫描记录数），ref，filtered，extra</p>
<ul>
<li>
<p>explain执行计划各字段含义</p>
<ul>
<li>
<p>id</p>
<ul>
<li>
<p>select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，则值越大的先执行）</p>
<p># 多表查询会出现多条记录，会有多个id</p>
</li>
</ul>
</li>
<li>
<p>select_type</p>
<ul>
<li>表示select的类型，常见有simple（简单表，即不使用表连接或者子查询），primary（主查询，即外层的查询），union（union中的第二个或者后面的查询语句），subquery（select/where之后包含了子查询）等</li>
</ul>
</li>
<li>
<p>type</p>
<ul>
<li>表示连接（访问）类型，性能由好到坏为，null（基本不会出现，除非不访问表），system（访问系统表），const（根据主键和唯一索引访问），eq_ref（联表查询中根据主键和唯一索引访问）,ref（根据非唯一性的索引访问）,range,index（遍历整个索引）,all（全表扫描）</li>
</ul>
</li>
<li>
<p>possible_keys</p>
<ul>
<li>表可能会用到的索引，会有一个或多个</li>
</ul>
</li>
<li>
<p>key</p>
<ul>
<li>实际使用的索引，没有使用索引则为null</li>
</ul>
</li>
<li>
<p>key_len</p>
<ul>
<li>表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li>
</ul>
</li>
<li>
<p>rows</p>
<ul>
<li>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是估计值</li>
</ul>
</li>
<li>
<p>filtered</p>
<ul>
<li>表示返回结果的行数占需要读取行数的百分比，值越大越好</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-索引使用">6.索引使用</h3>
<h4 id="1-验证索引效率">1.验证索引效率</h4>
<ul>
<li>在未建立索引之前，执行SQL语句查看SQL耗时</li>
<li>针对字段创建索引后再执行相同的SQL语句，再次查看SQL耗时</li>
</ul>
<h4 id="2-使用原则">2.使用原则</h4>
<h5 id="1-最左前缀法则">1.最左前缀法则</h5>
<ul>
<li>
<p>最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳过某一列，<strong>索引将部分失效，则此列后面的字段失效</strong></p>
</li>
<li>
<p>如果索引了多列（即联合索引），要遵守最左前缀法则</p>
</li>
</ul>
<p># 例如建立联合索引按顺序关联name，age，status三个字段，在使用联合查询的时候，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> ......;</span><br></pre></td></tr></table></figure>
<p>​    要遵守最左前缀法则，则where后面必须存在name=（位置不限），否则不会根据索引查询，</p>
<p>​    在查询时用and连接字段，如果跳过了age字段，则name根据索引查询，status则不会</p>
<h5 id="2-范围查询">2.范围查询</h5>
<ul>
<li>联合索引中，出现范围查询（&gt;,&lt;)，<strong>范围查询右侧的列索引失效</strong></li>
</ul>
<p># 同样是上面的例子，如果查询的时候where后面age&gt;30，则其右侧即status失效（age仍然根据索引查询）</p>
<p># 在允许的情况下用&gt;=和&lt;=可以规避这个问题</p>
<h5 id="3-索引列运算">3.索引列运算</h5>
<ul>
<li>不要在索引列上进行运算操作，<strong>索引将失效</strong></li>
</ul>
<p># 例如建立了关于phone这个字段的索引，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> phone<span class="operator">=</span>‘号码’；</span><br></pre></td></tr></table></figure>
<p>这样查询是可以根据索引查询的</p>
<p>如果使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> substring（phone，<span class="number">10</span>，<span class="number">2</span>）<span class="operator">=</span>‘<span class="number">12</span>’；</span><br></pre></td></tr></table></figure>
<p>即用了substring函数进行了运算</p>
<p>则进行的是全表扫描，不会根据索引查询</p>
<p># 最左前缀法则中中间字段进行了运算会导致此字段和其后的字段索引失效</p>
<h5 id="4-字符串不加引号">4.字符串不加引号</h5>
<ul>
<li>字符串类型字段使用时，不叫引号，<strong>索引将失效</strong> ，根本原因是对其进行了隐式类型转换，字符串转为数字，而索引存储的是原字符串</li>
</ul>
<p># possibilities_keys为字段相关的索引，但是实际索引key为null</p>
<p># 在最左前缀法则中，如果中间字段没有加引号，<strong>则此字段以及后面的索引全部失效</strong></p>
<h5 id="5-模糊查询">5.模糊查询</h5>
<ul>
<li>如果仅仅是尾部查询模糊匹配（abc%），索引不会失效。但是只要头部模糊匹配（%abc），索引就失效</li>
</ul>
<p># 同样在最左前缀法则中尾部模糊查询会导致当前索引可以使用，其后索引失效。</p>
<p># 只要有头部模糊就会导致，此字段索引及其后索引失效</p>
<h5 id="6-or连接的条件">6.or连接的条件</h5>
<ul>
<li>用or分割开的条件，任一条件中列没有索引，那么前后索引都不会被用到</li>
</ul>
<p># 只要有条件中的字段是联合索引里的中间字段且没有单独索引则失效，如果只是最左索引则可以使用</p>
<p># 会有可能索引，但实际索引key为null</p>
<p># 如果要查询字段是联合索引里的中间字段则需要创建单独索引</p>
<h5 id="7-数据分布影响">7.数据分布影响</h5>
<ul>
<li>如果MySQL评估使用索引比全表更慢，则不使用索引</li>
</ul>
<p># 主要取决于数据的分布，如果条件筛选出来的是小部分数据则会使用索引，反之不使用</p>
<h5 id="8-SQL提示">8.SQL提示</h5>
<ul>
<li>在SQL语句中加入一些提示来达到优化操作的目的</li>
</ul>
<h6 id="1-use-index：建议MySQL使用某个索引，实际使用的索引根据MySQL的判断">1.use index：建议MySQL使用某个索引，实际使用的索引根据MySQL的判断</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 use index（索引名）<span class="keyword">where</span> ......；</span><br></pre></td></tr></table></figure>
<p># 可以用explain查看最终使用了哪个索引</p>
<h6 id="2-ignore-index：不使用某个索引">2.ignore index：不使用某个索引</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 ignore index（索引名）<span class="keyword">where</span> ........;</span><br></pre></td></tr></table></figure>
<h6 id="3-force-index：强制使用某个索引">3.force index：强制使用某个索引</h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 force index（索引名）<span class="keyword">where</span> .........；</span><br></pre></td></tr></table></figure>
<h5 id="9-覆盖索引">9.覆盖索引</h5>
<ul>
<li>尽量使用覆盖索引（查询使用了索引，并且需要返回的列在该索引中已经全部能够找到），减少select*出现</li>
</ul>
<p># 例如建立了关联了phone，age，name的联合索引，select id，phone，age，name后面条件包含三个字段</p>
<p>​	根据二级索引，主键id也包含在内，四个字段都在使用的索引中，这时候用explain查询，extra信息会显示</p>
<p>​	using where；using index：查找使用了索引，但是需要的数据都在索引列中能找到，使用不需要回表查询</p>
<p>​	如果再查询status，这个字段不包含在使用到的索引中，则extra信息会显示</p>
<p>​	using index condition：查找使用了索引，但是需要回表查询数据</p>
<p>​	如果要查询则再建立phone，age，name，status的联合索引，以提高效率，单独再建一个status的单列索引仍然会回表查询</p>
<h5 id="10-前缀索引">10.前缀索引</h5>
<ul>
<li>
<p>当字段类型为字符串（varchar，text等）使，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘io，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样可以对的节约索引空间，从而提高索引效率</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名称 <span class="keyword">on</span> 表名（字段名（n））；</span><br></pre></td></tr></table></figure>
<p># n表示要提取这个字段的前面n个字符来构建索引</p>
<ul>
<li>前缀长度</li>
<li>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的</li>
<li>计算公式：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> count（<span class="keyword">distinct</span> 字段名）<span class="operator">/</span>count（\<span class="operator">*</span>） <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p># distinct用于去除重复记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> count（<span class="keyword">distinct</span> substring（字段名，起始位置，截取长度））<span class="operator">/</span>count（\<span class="operator">*</span>） <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p># substring用于截取，起始位置从1开始</p>
<ul>
<li>前缀索引查询流程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> email<span class="operator">=</span>‘完整的邮箱’；</span><br></pre></td></tr></table></figure>
<p># 先根据完整邮箱的前n位到创建的邮箱的前n位的二级索引中查找得到对应主键，再到聚合索引中找到对应主键的行数据，再将行数据中的email与要查询的完整邮箱比对，完全一致则返回数据。如果出现前n位相同，则将几个主键都拿到聚合索引中查询，最终一致的再返回出来</p>
<h5 id="11-单列索引与联合索引">11.单列索引与联合索引</h5>
<ul>
<li>如果存在多个查询条件，考虑针对于查询字段建立索引，建议建立联合索引，而非单列索引</li>
</ul>
<p># 在使用时，即使创建了联合索引，MySQL可能仍会使用单列索引，会回表查询，可以使用SQL提示</p>
<ul>
<li>联合索引情况：</li>
<li>仍然是B+tree，每个节点存储的键值是几个索引的组合情况</li>
</ul>
<p># 例如将phone，name，age按顺序关联成联合索引，则每个键值的形式都是phone+name+age，根据phone来排序，phone一致则再根据name来排序，以此类推。同时phone就作为最左列</p>
<h3 id="7-索引设计原则">7.索引设计原则</h3>
<p>1.针对于数据量较大（数据量超过100万左右），且查询比较频繁的表建立索引。</p>
<p>2.针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。</p>
<p>3.尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p>
<p>4.如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p>
<p>5.尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p>
<p>6.要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p>
<p>7.如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p>
<h2 id="3-SQL优化">3.SQL优化</h2>
<h3 id="1-插入数据">1.插入数据</h3>
<h4 id="1-insert优化">1.insert优化</h4>
<h5 id="1-批量插入">1.批量插入</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 <span class="keyword">values</span>（），（），（），.....；</span><br></pre></td></tr></table></figure>
<p># 因为每一次insert插入都会与数据库进行建立连接和网络传输，所以将多个insert合并为一个</p>
<p># 插入数据量在500-1000较为合适</p>
<h5 id="2-手动提交事务">2.手动提交事务</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction；</span><br><span class="line"></span><br><span class="line">insert......;</span><br><span class="line"></span><br><span class="line">insert......;</span><br><span class="line"></span><br><span class="line">insert......;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-主键顺序插入">3.主键顺序插入</h5>
<ul>
<li>主键乱序插入</li>
<li>主键顺序插入</li>
</ul>
<p># 顺序插入的性能高于乱序插入，与MySQL的数据组织结构有关</p>
<h4 id="2-大批量插入数据">2.大批量插入数据</h4>
<ul>
<li>
<p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入</p>
</li>
<li>
<p>客户端连接服务端时，加上参数  --local-infile  用于加载本地文件</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql --local-infile -u root -p</span><br></pre></td></tr></table></figure>
<ul>
<li>设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile<span class="operator">=</span><span class="number">1</span>；</span><br></pre></td></tr></table></figure>
<p># 可以再用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@local_infile</span>；</span><br></pre></td></tr></table></figure>
<p>查看值为多少，是否开启</p>
<ul>
<li>执行load指令将准备好的数据，加载到表结构中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">load data <span class="keyword">local</span> infile ‘<span class="operator">/</span>root<span class="operator">/</span>文件名’ <span class="keyword">into</span> ‘表名’ fields terminated <span class="keyword">by</span>  ‘，’ lines terminated <span class="keyword">by</span> ‘\n<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure>
<p># ‘，’表示指定用，分割每个字段，‘\n’表示指定用\n分割每一行数据</p>
<p># 需要先将文件上传到服务器中</p>
<p># 同样要按照主键顺序插入</p>
<h3 id="2-主键优化">2.主键优化</h3>
<h4 id="1-数据组织方式">1.数据组织方式</h4>
<ul>
<li>
<p>在innodb存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（iot）</p>
</li>
<li>
<p>页分裂</p>
</li>
<li>
<p>页可以为空，也可以填充一半，或者全部填充，每个页至少包含2行数据（如果某一行数据过大，会行溢出），根据主键排列</p>
</li>
<li>
<p>主键顺序插入：当第一个页填充满了，数据会在第二个页继续填充，同时会在一二页中维护一个双向指针</p>
</li>
<li>
<p>主键乱序插入：例如第一个页中有值为1 5 9 23 47，第二个页中有值为55 67 89 101 107，且这两页已经填充满，此时插入一个值为50的行数据，那么会先生成一个新的数据页，再找到第一个页的50%的位置，即1 5 9和23 47，则先将23 47移动到生成的第三个页，再将50插入到第三个页，那么原本的链表指针是一二之间的，则重新设置一三间的双向指针和三二之间的双向指针，此现象被称为页分裂</p>
</li>
<li>
<p>页合并</p>
</li>
<li>
<p>当删除一行数据时，并没有真正的删除，只是数据被标记为删除并且它的空间允许被其他数据声明使用</p>
</li>
<li>
<p>当页中删除的数据达到merge_threshold（合并页的阈值，默认为页的50%，可以自己设置，在创建表或者创建索引时指定），innodb会开始寻找最近的页查看是否可以将两个页合并以优化空间使用</p>
</li>
</ul>
<h4 id="2-主键设计原则">2.主键设计原则</h4>
<ul>
<li>
<p>满足业务需求的情况下，尽可能降低主键的长度，过长会占用空间，耗费大量磁盘io</p>
</li>
<li>
<p>插入数据时，尽量选择顺序插入，选择auto_increment自增主键</p>
</li>
<li>
<p>尽量不要使用uuid（每次生成的是无序的，导致乱序插入，可能页分裂，uuid v7是有序的）做主键或者其他自然主键，如身份证号（长度较长）</p>
</li>
<li>
<p>业务操作时，避免对主键的修改</p>
</li>
</ul>
<h3 id="3-order-by优化">3.order by优化</h3>
<ul>
<li>
<p>using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所以不是通过索引直接返回排序结果的排序都叫FileSort排序</p>
</li>
<li>
<p>using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高</p>
</li>
<li>
<p>索引创建出来默认是升序排序的，在信息collation中显示A（asc），所以如果在查询时order by后面的字段都是倒序，就会在explain的extra中提示backward index scan（反向扫描索引）</p>
</li>
<li>
<p>如果既有升序又有降序那么在extra中就会既有using index又有using filesort</p>
</li>
</ul>
<p># <strong>可以在创建索引的时候在字段名后加asc/desc来指定升序或降序</strong></p>
<ul>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li>
<li>尽量使用覆盖索引</li>
<li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则</li>
<li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k）</li>
</ul>
<p># 可以用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> ‘sort_buffer_size’；</span><br></pre></td></tr></table></figure>
<p>来查看排序缓冲区的大小</p>
<p># 如果排序缓冲区满了，会在磁盘文件中排序，性能就会较低</p>
<h3 id="4-group-by优化">4.group by优化</h3>
<ul>
<li>通过索引来提升效率</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的</li>
</ul>
<p># 在group by后面使用字段也可以走联合索引</p>
<h3 id="5-limit优化">5.limit优化</h3>
<ul>
<li>正常limit查询时，如从200000000条开始一页10行数据，这时会将前200000010都排序，但是最终只返回10条记录</li>
<li>可以通过覆盖索引和子查询来解决</li>
</ul>
<h3 id="6-count优化">6.count优化</h3>
<ul>
<li>InnoDB中查询count（*）会很耗时，执行时需要把每一行数据从引擎里读出来，然后累加</li>
<li>erMyISAM引擎把一个表的总行数存在了磁盘上，因此执行count（*）的时候会直接返回这个数，效率高</li>
</ul>
<p># 前提是查询时后面没有where条件</p>
<ul>
<li>
<p>count的几种用法</p>
<ul>
<li>
<p>count（）是一个聚合函数，对于返回的结果集，一行一行地判断，如果count函数的参数不是null，累计值就加1，否则不加，最后返回累计值</p>
</li>
<li>
<p>用法：</p>
<ul>
<li>count（*）：InnoDB引擎不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行累加</li>
<li>count（主键）：InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层，服务层获取主键后直接按行进行累加（主键不可能是null）</li>
<li>count（字段）：
<ul>
<li>没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null则计数</li>
<li>有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回服务层直接累加</li>
</ul>
</li>
<li>count（1）：InnoDB引擎会遍历整张表，但不取值，服务层对于返回的每一行，放一个数字1进去，直接按行累加</li>
</ul>
<p># 官方文档中说，count（*）和count（1）的优化是一样的</p>
<p># 效率：count（字段）&lt;count（主键）&lt;count（1）=count（*）</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-update优化">7.update优化</h3>
<ul>
<li>InnoDB的行锁是针对索引加的锁，不是针对记录加的，并且该索引不能失效，否则会从行锁升级为表锁</li>
</ul>
<p># 在一个窗口中开启事务，where条件后跟的是有索引的且不能是前面提到过的各种索引失效的字段，则符合条件的行数据会被锁定（在另一个会话中可以对其他行数据进行update），否则则会将整张表锁住，在另一个会话中开启事务对表中任意一行数据update都无法成功</p>
<h2 id="4-视图">4.视图</h2>
<h3 id="1-介绍">1.介绍</h3>
<ul>
<li>视图（view）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图查询中使用的表（基表/基础表），并且在使用视图时动态生成的</li>
<li>视图只保存查询的SQL逻辑，不保存查询结果，所以在创建视图的时候，主要在于创建SQL查询语句</li>
</ul>
<h3 id="2-基本语法">2.基本语法</h3>
<h4 id="1-创建">1.创建</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名称（列名列表） <span class="keyword">as</span> <span class="keyword">select</span>语句 wtih <span class="keyword">cascaded</span><span class="operator">/</span>loacl <span class="keyword">check</span> option；</span><br></pre></td></tr></table></figure>
<p># 如不需要替换视图则or replace可以省略</p>
<p># 不需要检查增删改是否满足条件时wtih cascaded/loacl check option可以省略</p>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> stu_i_n <span class="keyword">as</span> <span class="keyword">select</span> id，name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-查询">2.查询</h4>
<ul>
<li>查看创建视图的语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名称；</span><br></pre></td></tr></table></figure>
<ul>
<li>查看视图数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 视图名称 .........;</span><br></pre></td></tr></table></figure>
<p># 后面可以添加条件</p>
<h4 id="3-修改">3.修改</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名称（列名列表） <span class="keyword">as</span> <span class="keyword">select</span>语句 wtih <span class="keyword">cascaded</span><span class="operator">/</span>loacl <span class="keyword">check</span> option；</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称（列名列表） <span class="keyword">as</span> <span class="keyword">select</span>语句 wtih <span class="keyword">cascaded</span><span class="operator">/</span>loacl <span class="keyword">check</span> option；</span><br></pre></td></tr></table></figure>
<h4 id="4-删除">4.删除</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> 视图名称 <span class="number">1</span>，视图名称<span class="number">2</span>， .......；</span><br></pre></td></tr></table></figure>
<h3 id="3-检查选项">3.检查选项</h3>
<ul>
<li>
<p>当使用with check option子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的条件。MySQL允许基于另一个视图创建视图，它还会检查<strong>所依赖视图</strong> 中的规则以保持一致性。为了确定检查的范围，MySQL提供了两个选项：cascaded和local，默认值为cascaded（级联）</p>
</li>
<li>
<p><strong>cascaded</strong> ：检查视图以及其所依赖的视图的条件</p>
</li>
<li>
<p><strong>local</strong> ：检查视图条件，再查看其所依赖的视图是否有with check option来检查条件，有则检查，没有则只需满足当前视图条件</p>
</li>
</ul>
<h3 id="4-更新">4.更新</h3>
<ul>
<li>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则视图不可更新
<ul>
<li>聚合函数或窗口函数（sum，min，max，count）</li>
<li>distinct</li>
<li>group by</li>
<li>having</li>
<li>union或union all</li>
</ul>
</li>
</ul>
<h3 id="5-作用">5.作用</h3>
<ul>
<li>简单
<ul>
<li>视图不仅可以简化用户对数据的理解，也可以简化操作。经常使用的查询可以被定义为视图（类似于封装成函数），从而使得用户不必为以后的操作每次指定全部的条件</li>
</ul>
</li>
<li>安全
<ul>
<li>数据库可以授权，但不能授权到数据库的特定行和列上。通过视图用户只能查询修改授权的数据</li>
</ul>
</li>
<li>数据独立
<ul>
<li>视图可以帮助用户屏蔽真实表结构变化带来的影响，当基表的字段名改变时，可以通过起别名的方式使视图的字段名和基表原始字段相同</li>
</ul>
</li>
</ul>
<h2 id="5-储存过程">5.储存过程</h2>
<h3 id="1-介绍-2">1.介绍</h3>
<ul>
<li>
<p>存储过程是事先经过编译并存储在数据库中的一段SQL语句集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器间的传输，提高数据处理的效率</p>
</li>
<li>
<p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>封装，重用</li>
<li>可以接收参数，也可以返回数据</li>
<li>减少网络交互，提升效率</li>
</ul>
</li>
</ul>
<h3 id="2-基本语法-2">2.基本语法</h3>
<h4 id="1-创建-2">1.创建</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称（参数列表）</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">SQL</span>语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>；</span><br></pre></td></tr></table></figure>
<p># 在<strong>命令行</strong> 中创建存储过程时，SQL语句中会有**；** ，导致判定为SQL语句完成</p>
<p># <strong>需要用关键字delimiter指定SQL语句的结束符</strong></p>
<ul>
<li>
<p>即<strong>delimiter</strong> 指定符号</p>
</li>
<li>
<p>在end后将；改为指定符号</p>
</li>
<li>
<p>同样也可以改回；</p>
</li>
</ul>
<h4 id="2-调用">2.调用</h4>
<ul>
<li><strong>call 名称（参数）；</strong></li>
</ul>
<h4 id="3-查看">3.查看</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema <span class="operator">=</span> <span class="string">&#x27;xxxx&#x27;</span>；</span><br></pre></td></tr></table></figure>
<p># 在information_schema这个数据库中的routines这张表中，routine_schema限制数据库名称</p>
<p># 查询指定数据库的存储过程及状态信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称；</span><br></pre></td></tr></table></figure>
<ul>
<li># 查询某个存储过程的定义</li>
</ul>
<h4 id="4-删除-2">4.删除</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> 存储过程名称；</span><br></pre></td></tr></table></figure>
<h3 id="3-变量">3.变量</h3>
<h4 id="1-系统变量">1.系统变量</h4>
<ul>
<li>是MySQL服务器提供，不是用户自定义的，属于服务器层面，分为全局变量（global），会话变量(session）</li>
</ul>
<p># 没有指定session或global则默认为session</p>
<h5 id="1-查看系统变量">1.查看系统变量</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> session<span class="operator">/</span><span class="keyword">global</span> variables；</span><br></pre></td></tr></table></figure>
<p># 查看所有系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> session<span class="operator">/</span><span class="keyword">global</span> variables <span class="keyword">like</span> ‘.........’；</span><br></pre></td></tr></table></figure>
<p># 通过like模糊匹配查找变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span><span class="operator">/</span>global.系统变量名；</span><br></pre></td></tr></table></figure>
<p># 查看指定变量的值</p>
<h5 id="2-设置系统变量">2.设置系统变量</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session<span class="operator">/</span><span class="keyword">global</span> 系统变量名<span class="operator">=</span>值；</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@session</span><span class="operator">/</span><span class="keyword">global</span> 系统变量名<span class="operator">=</span>值；</span><br></pre></td></tr></table></figure>
<p># 重启后设置的全局参数会恢复默认值，可以在/etc/my.cnf中配置</p>
<h4 id="2-用户自定义变量">2.用户自定义变量</h4>
<ul>
<li>是用户根据需要自己定义的变量，<strong>用户变量不用提前声明</strong> ，在用的时候直接用**@变量名** 使用就可以，其作用域为当前连接</li>
</ul>
<h5 id="1-赋值">1.赋值</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @变量名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>，......；</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @变量名<span class="number">1</span> ：<span class="operator">=</span>值<span class="number">1</span>，......；</span><br></pre></td></tr></table></figure>
<p># 建议使用**：=**</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @变量名<span class="number">1</span> ：<span class="operator">=</span>值<span class="number">1</span>，......；</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> @变量名 <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure>
<p># 将查询结果赋给变量</p>
<h5 id="2-使用">2.使用</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @变量名<span class="number">1</span>，......；</span><br></pre></td></tr></table></figure>
<p># 直接使用一个未赋值的变量也不会报错，只会返回null</p>
<h4 id="3-局部变量">3.局部变量</h4>
<ul>
<li>是根据需要定义的在局部生效的变量，<strong>访问前需要declare声明</strong> ，可用作存储过程内的局部变量和输入参数，<strong>局部变量的范围是在其内声明的begin…end块</strong></li>
</ul>
<h5 id="1-声明">1.声明</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> 变量名 变量类型 <span class="keyword">default</span> ....；</span><br></pre></td></tr></table></figure>
<h5 id="2-赋值">2.赋值</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名<span class="operator">=</span>值；</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名 ：<span class="operator">=</span>值；</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名 ......；</span><br></pre></td></tr></table></figure>
<h3 id="4-if">4.if</h3>
<ul>
<li>语法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if 条件<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">	.......</span><br><span class="line">elseif 条件<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">	........</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	........</span><br><span class="line"><span class="keyword">end</span> if；</span><br></pre></td></tr></table></figure>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> score <span class="type">int</span> <span class="keyword">default</span> <span class="number">58</span> #这里将分数的默认值设为<span class="number">58</span>，没有参数</span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">	if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">	elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;不及格&#x27;</span></span><br><span class="line">	<span class="keyword">end</span> if;</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-参数">5.参数</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td># 默认为in</td>
</tr>
<tr>
<td>out</td>
<td>该类参数作为输出，也就是该参数可以作为返回值</td>
<td></td>
</tr>
<tr>
<td>inout</td>
<td>既可以作为输入参数，也可以作为输出参数</td>
<td># 可以用于作为百分制转化的参数</td>
</tr>
</tbody>
</table>
<ul>
<li>语法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称（<span class="keyword">in</span><span class="operator">/</span><span class="keyword">out</span><span class="operator">/</span><span class="keyword">inout</span> 参数名 参数类型）</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">SQL</span>语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>；</span><br></pre></td></tr></table></figure>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1(<span class="keyword">in</span> score <span class="type">int</span>，<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>)) #这里将分数的类型设置为<span class="keyword">in</span>传入，同时设置<span class="keyword">result</span>为<span class="keyword">out</span>返回</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">	elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;不及格&#x27;</span></span><br><span class="line">	<span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p># call的时候就要传入一个参数，同时还要自定义一个变量来接收返回的结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> p1(<span class="number">68</span>,<span class="variable">@result1</span>);</span><br></pre></td></tr></table></figure>
<p># 这里执行完不会直接显示result，要查询@result1才能显示</p>
<h3 id="6-case">6.case</h3>
<ul>
<li>语法一</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 表达式</span><br><span class="line">	<span class="keyword">when</span> 值<span class="number">1</span> <span class="keyword">then</span> sql1语句</span><br><span class="line">	<span class="keyword">when</span> 值<span class="number">2</span> <span class="keyword">then</span> sql2语句</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">else</span> sql3语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>语法二</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br><span class="line">	<span class="keyword">when</span> 条件表达式<span class="number">1</span> <span class="keyword">then</span> sql1语句</span><br><span class="line">	<span class="keyword">when</span> 条件表达式<span class="number">2</span> <span class="keyword">then</span> sql2语句</span><br><span class="line">	.......</span><br><span class="line">	<span class="keyword">else</span> sql3语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure>
<p># 例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p6(<span class="keyword">in</span> <span class="keyword">month</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>）；</span><br><span class="line">	<span class="keyword">case</span></span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;第一季度&#x27;</span>；</span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">6</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;第二季度&#x27;</span>；</span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">9</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;第三季度&#x27;</span>；</span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">12</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;第四季度&#x27;</span>；</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span><span class="string">&#x27;非法参数&#x27;</span>；</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">case</span>；</span><br><span class="line">	<span class="keyword">select</span> concat(<span class="string">&#x27;您输入的月份为：&#x27;</span>,<span class="keyword">month</span>，<span class="string">&#x27;，所属的季度为：&#x27;</span>，<span class="keyword">result</span>）；</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-循环">7.循环</h3>
<h4 id="1-while">1.while</h4>
<ul>
<li>
<p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">while 条件 do</span><br><span class="line">	<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure>
<p># 先判定条件，如果为true，则执行语句，否则不执行</p>
<p># 例如从1到n的累加</p>
<h4 id="2-repeat">2.repeat</h4>
<ul>
<li>
<p>repeat是有条件的循环控制语句，当满足条件时退出循环</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">repeat</span><br><span class="line">	<span class="keyword">sql</span>语句</span><br><span class="line">	until 条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure>
<p># 先执行一次语句，然后判定是否满足条件，满足则退出，不满足则继续下一次循环</p>
<p># 同样也可以做累加的操作</p>
<h4 id="3-loop">3.loop</h4>
<ul>
<li>
<p>loop实现简单的循环，如果不在SQL语句中增加退出循环的条件，可以用其来实现简单的死循环</p>
</li>
<li>
<p>loop配合以下两个语句使用</p>
</li>
<li>
<p><strong>leave</strong> ：配合循环使用，退出循环</p>
</li>
<li>
<p><strong>iterate</strong> ：必须用在循环中，作用时跳过当前循环剩下的语句，直接进入下一次循环</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">标识名:loop</span><br><span class="line">	<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span> loop 标识名;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">leave 标识名;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">iterate 标识名;</span><br></pre></td></tr></table></figure>
<p># 同样可以做累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	sum:loop</span><br><span class="line">		if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">			Leave sum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">set</span> total:<span class="operator">=</span> total<span class="operator">+</span>n;</span><br><span class="line">		<span class="keyword">set</span> n:<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">end</span> loop sum;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p># 配合iterate可以做到累加偶数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	sum:loop</span><br><span class="line">		if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">			Leave sum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line">		</span><br><span class="line">		if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">			iterate sum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">set</span> total:<span class="operator">=</span> total<span class="operator">+</span>n;</span><br><span class="line">		<span class="keyword">set</span> n:<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">end</span> loop sum;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-游标（光标）">8.游标（光标）</h3>
<ul>
<li>
<p>游标（cursor）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环处理。游标的使用包括游标的声明，open，fetch，close</p>
</li>
<li>
<p>语法</p>
</li>
<li>
<p>声明游标</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> 游标名称 <span class="keyword">cursor</span> <span class="keyword">for</span> 查询语句;</span><br></pre></td></tr></table></figure>
<p># 游标的声明要在普通变量声明的后面</p>
<ul>
<li>打开游标</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> 游标名称;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取游标记录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fetch</span> 游标名称 <span class="keyword">into</span> 变量<span class="number">1</span>，变量<span class="number">2</span>，......;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭游标</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">close</span> 游标名称;</span><br></pre></td></tr></table></figure>
<h3 id="9-条件处理程序">9.条件处理程序</h3>
<ul>
<li>
<p>条件处理程序（handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> handler_action handler <span class="keyword">for</span> condition_value,condition_value,.... <span class="keyword">sql</span>语句;</span><br></pre></td></tr></table></figure>
<p># handler_action:</p>
<p>​	continue：继续执行当前程序</p>
<p>​	exit：终止执行当前程序</p>
<p># condition_value</p>
<p>​	sqlstate：状态码，如0200</p>
<p>​	sqlwarning：所有以01开头的sqlstate代码的简称</p>
<p>​	not found：所有以02开头的sqlstate代码的简称</p>
<p>​	sqlexception：所有没有被sqlwarning和not found捕获的sqlstate代码的简称</p>
<p># 例如要查询所有年龄小于uage的用户的名称和专业</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>）</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>）；</span><br><span class="line">	<span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>）；</span><br><span class="line">	<span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line">	#游标在普通声明后声明</span><br><span class="line">    <span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor；</span><br><span class="line">	#条件处理程序，用于在循环体里结束循环</span><br><span class="line"></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">	<span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">		id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment，</span><br><span class="line">		name <span class="type">varchar</span>(<span class="number">100</span>），</span><br><span class="line">		profession <span class="type">varchar</span>(<span class="number">100</span>）</span><br><span class="line">	）；</span><br><span class="line">	#创建空的表来接收查询出来的数据</span><br><span class="line">                         </span><br><span class="line">    <span class="keyword">open</span> u_cursor；</span><br><span class="line">	while <span class="literal">true</span> do</span><br><span class="line">		<span class="keyword">fetch</span> ucursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">		<span class="keyword">insert into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>, uname, upro)；</span><br><span class="line">	<span class="keyword">end</span> while；</span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line">	#将游标中的数据循环读出，当读完所有数据时仍会循环读取，就会报错<span class="number">02000</span>，上面的条件处理程序就会使其停止执行</span><br><span class="line">                           </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="6-存储函数">6.存储函数</h2>
<ul>
<li>
<p>存储函数是有返回值的存储过程，存储函数的参数只能是in类型的</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数名称（参数列表）</span><br><span class="line"><span class="keyword">returns</span> 数据类型 characteristic</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">sql</span>语句</span><br><span class="line">	return.......;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p># characteristic：</p>
<p>​	deterministic：相同的输入参数总是产生相同的结果</p>
<p>​	no sql：不包含sql语句</p>
<p>​	reads sql data：包含读取数据的语句，但不包含写入数据的语句</p>
<p># 二进制制在版本8是默认开启的，所以会强制指定一个characteristic</p>
<p># 因为有return…;所以可以直接查询这个存储函数来获取结果</p>
<p># 使用较少，存储过程可以替代存储函数</p>
<h2 id="7-触发器">7.触发器</h2>
<h3 id="1-介绍-3">1.介绍</h3>
<ul>
<li>触发器是与表有关的数据库对象，值在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作</li>
<li>使用别名old和new来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发</li>
</ul>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>new和old</th>
</tr>
</thead>
<tbody>
<tr>
<td>insert型触发器</td>
<td>new表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>update型触发器</td>
<td>old表示修改之前的数据，new表示将要或者已经修改后的数据</td>
</tr>
<tr>
<td>delete型触发器</td>
<td>old表示将要或者已经修改的数据</td>
</tr>
</tbody>
</table>
<h3 id="2-语法">2.语法</h3>
<ul>
<li>创建</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名称</span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> #行级触发器</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	具体逻辑;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> 数据库名称.触发器名称</span><br></pre></td></tr></table></figure>
<p># 如果没有指定数据库名称则默认为当前的数据库</p>
<p>#例如一个用户表在增删改时要将增删改的内容记录到一个日志中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> user_logs(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> auto_increment,</span><br><span class="line">operation <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;操作类型，insert/update/delete&#x27;</span>,</span><br><span class="line">operate_time datetime <span class="keyword">not null</span> comment <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">operate_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;操作的ID&#x27;</span>,</span><br><span class="line">operate_params <span class="type">varchar</span>(<span class="number">500</span>) comment <span class="string">&#x27;操作参数&#x27;</span>,</span><br><span class="line"><span class="keyword">primary key</span>(`id`）</span><br><span class="line">engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p># 先创建一个日志用于记录</p>
<p># 创建插入数据触发器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert <span class="keyword">trigger</span></span><br><span class="line">	after <span class="keyword">insert</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">	#插入数据触发必然是after</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <span class="keyword">VALUES</span></span><br><span class="line">	(<span class="keyword">null</span>, <span class="string">&#x27;insert&#x27;</span>, now(), new.id, concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,NEW.phpne,<span class="string">&#x27;,email=&#x27;</span>,NEW.email,<span class="string">&#x27;,professiom=&#x27;</span>,NEW.profession))</span><br><span class="line">	#id是自增的</span><br><span class="line">	#<span class="keyword">insert</span>表示数据操作的类型</span><br><span class="line">	#now()获取当前数据操作时的实际</span><br><span class="line">	#new.id获取操作数据的id</span><br><span class="line">	#concat用于拼接后面这些新的数据</span><br><span class="line"><span class="keyword">end</span>；</span><br></pre></td></tr></table></figure>
<p># 更新和删除也类似，更新时要同时记录更新前和更新后的数据，就再用old.字段名来获取，删除则只记录删除操作前的数据，只需要old.字段名</p>
<h2 id="8-锁">8.锁</h2>
<h3 id="1-介绍-4">1.介绍</h3>
<ul>
<li>锁是计算机协调多个进程或者线程并发访问某一资源的机制。在数据库中，除传统的计算资源（cpu，ram，i/o）的争用以外，数据也是一种供许多用户享用的资源。任何保证数据并发访问的一致性，有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素</li>
</ul>
<h3 id="2-全局锁">2.全局锁</h3>
<ul>
<li>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于<strong>只读状态</strong> ，后续的dml语句，ddl语句和已经更新操作的事务提交语句都会被阻塞</li>
<li>典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性</li>
</ul>
<h4 id="1-语法">1.语法</h4>
<ul>
<li>加全局锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure>
<ul>
<li>备份时可以使用MySQL的工具mysqldump（不要在MySQL中执行，这是MySQL的工具）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p密码 表名&gt;要转移到的表的表名.sql</span><br></pre></td></tr></table></figure>
<ul>
<li>解锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<h4 id="2-特点">2.特点</h4>
<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务停摆</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟</li>
</ul>
<p># 在InnoDB引擎中，可以在备份时加上参数 --single-transaction参数来完成不加锁的一致性数据备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -p密码 表名&gt;要转移到的表的表名.sql</span><br></pre></td></tr></table></figure>
<h3 id="3-表级锁">3.表级锁</h3>
<ul>
<li>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率高，并发度最低。应用在MyISAM，InnoDB，BDB等存储引擎中</li>
</ul>
<h4 id="1-表锁">1.表锁</h4>
<ul>
<li>
<p>可以分为两类：</p>
<ul>
<li>1.表共享读锁（read lock，读锁）:所有客户端都只能读取数据，加了表锁的客户端写入会报错，其他客户端会被阻塞</li>
<li>2.表独占写锁（write lock，写锁）：加了表锁的客户端可以读写，其他客户端读写会被阻塞</li>
</ul>
</li>
<li>
<p>语法：</p>
</li>
<li>
<p>加锁</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lock tables 表名..... read<span class="operator">/</span>write;</span><br></pre></td></tr></table></figure>
<p># 可以锁定多张表</p>
<ul>
<li>释放锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<p># 或者直接将客户端关闭</p>
<h4 id="2-元数据锁（meta-data-lock，mdl）">2.元数据锁（meta data lock，mdl）</h4>
<ul>
<li>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作，为了避免DML和DDL冲突，保证读写的正确性</li>
<li>MySQL5.5中引入的MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）</li>
</ul>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock tables xxx read/write</td>
<td>shared_read_only/shared_no_read_write</td>
<td></td>
</tr>
<tr>
<td>select，select…lock in share mode</td>
<td>shared_read（共享）</td>
<td>与shared_read，shared_write兼容，与exclusive互斥</td>
</tr>
<tr>
<td>insert，update，delete，select…for update</td>
<td>shared_write（共享）</td>
<td>与shared_read，shared_write兼容，与exclusive互斥</td>
</tr>
<tr>
<td>alter table…</td>
<td>exclusive（排他）</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody>
</table>
<ul>
<li>查看元数据锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure>
<p># metadata_locks这张表中记录了当前数据库中是元数据锁</p>
<h4 id="3-意向锁">3.意向锁</h4>
<ul>
<li>
<p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</p>
</li>
<li>
<p>分为两种：</p>
<ul>
<li>意向共享锁（IS）：由语句select … lock in share mode添加
<ul>
<li>与表锁共享锁（read）兼容，与表锁排他锁（write）互斥，会被阻塞</li>
</ul>
</li>
<li>意向排他锁（IX）：由insert，upadte，delete，select … for update 添加
<ul>
<li>与表锁共享锁（read）及排他锁（write）都互斥。意向锁之间不会互斥</li>
</ul>
</li>
</ul>
</li>
<li>
<p>查看意向锁及行锁的加锁情况</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure>
<h3 id="4-行级锁">4.行级锁</h3>
<h4 id="1-介绍-5">1.介绍</h4>
<ul>
<li>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中</li>
<li>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，不是对记录加锁。</li>
<li>主要分为三类：
<ul>
<li>行锁（record lock，记录锁）：锁定单个行数据的锁，防止其他事务对此行进行update和delete。在rc（read commit），rr（repeatable read）隔离级别下都支持</li>
<li>间隙锁（gap lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在rr隔离级别下都支持</li>
<li>临建锁（next-key lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙gap。在rr隔离级别下支持</li>
</ul>
</li>
</ul>
<h4 id="2-行锁">2.行锁</h4>
<ul>
<li>InnoDB实现了以下两种类型的行锁
<ul>
<li>共享锁（s）：允许一个事务去读一行，即共享锁之间兼容，阻止其他事务获得相同数据集的排他锁</li>
<li>排他锁（x）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">请求锁类型</th>
<th style="text-align:center">s（共享锁）</th>
<th style="text-align:center">x（排他锁）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">当前锁类型：s（共享锁）</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">冲突</td>
</tr>
<tr>
<td style="text-align:left">x（排他锁）</td>
<td style="text-align:center">冲突</td>
<td style="text-align:center">冲突</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>insert</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>update</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>delete</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>select</td>
<td>不加任何锁</td>
<td></td>
</tr>
<tr>
<td>select…lock in share mode</td>
<td>共享锁</td>
<td>需要手动在select后加lock in share mode</td>
</tr>
<tr>
<td>select…for update</td>
<td>排他锁</td>
<td>需要手动在select后加for update</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>在默认情况下，InnoDB在repeatable read事务隔离级别运行，InnoDB使用next-key锁进行搜素和索引扫描，以防止幻读</p>
</li>
<li>
<p>1.针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁</p>
</li>
<li>
<p>2.InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁</p>
</li>
<li>
<p>查看意向锁及行锁的加锁情况</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure>
<h4 id="3-间隙锁-临建锁">3.间隙锁/临建锁</h4>
<ul>
<li>默认情况下，InnoDB在repeatable read事务隔离级别运行，InnoDB使用next-key锁进行搜素和索引扫描，以防止幻读</li>
<li>1.索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁</li>
<li>2.索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁</li>
<li>3.索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止</li>
</ul>
<p># 间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙采用间隙锁</p>
<h2 id="9-InnoDB引擎">9.InnoDB引擎</h2>
<h3 id="1-逻辑存储结构">1.逻辑存储结构</h3>
<ul>
<li>tablespace：表空间（ibd文件）一个mysql实例可以对应多个表空间，用于存储记录，索引等数据
<ul>
<li>segment：段，分为数据段（leaf node segment），索引段（non-leaf node segment），回滚段（rollback segment），InnoDB是索引组织表，数据段就是B+tree的叶子节点，索引是B+tree的非叶子节点。段用来管理多个区
<ul>
<li>extent：区，表空间的单元结构，每个页的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页
<ul>
<li>page：页，是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区
<ul>
<li>row：行，InnoDB存储引擎数据是按行进行存放的
<ul>
<li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给Trx_id隐藏列</li>
<li>Roll_pointer：每次对某条记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-架构">2.架构</h3>
<ul>
<li>MySQL5.5之后，默认使用InnoDB存储引擎，它擅长事务处理，具有奔溃恢复特性，在日常开发中使用广泛</li>
</ul>
<h4 id="1-内存架构">1.内存架构</h4>
<h5 id="1-Buffer-Pool">1.Buffer Pool</h5>
<ul>
<li>
<p>缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</p>
</li>
<li>
<p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态将Page分为三种类型：</p>
<ul>
<li>free page：空闲page，未被使用</li>
<li>clean page：被使用page，数据没有被修改过</li>
<li>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘数据产生了不一致，还未刷新到磁盘</li>
</ul>
</li>
</ul>
<h5 id="2-Change-Buffer">2.Change Buffer</h5>
<ul>
<li>
<p>更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中</p>
</li>
<li>
<p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更<br>
新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了<br>
ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p>
</li>
</ul>
<h5 id="3-Adaptive-Hash-Index">3.Adaptive Hash Index</h5>
<ul>
<li>自适应hash索引，用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引</li>
<li>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</li>
<li>参数：adaptive_hash_index，可以查询是否开启</li>
</ul>
<h5 id="4-Log-Buffer">4.Log Buffer</h5>
<ul>
<li>日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘IO</li>
<li>参数：
<ul>
<li>缓冲区大小：innodb_log_buffer_size</li>
<li>日志刷新到磁盘时机：innodb_flush_log_at_trx_commit
<ul>
<li>1：日志在每次事务提交时写入并刷新磁盘</li>
<li>0：每秒将日志写入并刷新磁盘一次</li>
<li>2：日志在每次事务提交后写入，并每秒刷新到磁盘一次</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-磁盘结构">2.磁盘结构</h4>
<h5 id="1-System-Tablespace">1.System Tablespace</h5>
<ul>
<li>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等）</li>
<li>参数：innodb_data_file_path</li>
</ul>
<h5 id="2-File-Per-Table-Tablespaces">2.File-Per-Table Tablespaces</h5>
<ul>
<li>每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。</li>
<li>参数：innodb_file_per_table</li>
</ul>
<p># 默认开启</p>
<h5 id="3-General-Tablespaces">3.General Tablespaces</h5>
<ul>
<li>
<p>通用表空间，需要通过CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p>
</li>
<li>
<p>语法：</p>
</li>
<li>
<p>创建通用表空间</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> tablespace xxxx <span class="keyword">add</span> datafile <span class="string">&#x27;表空间关联的表空间文件&#x27;</span> engine<span class="operator">=</span><span class="string">&#x27;引擎名称&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>指定表空间</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> xxx... tablespace 表空间名称;</span><br></pre></td></tr></table></figure>
<h5 id="4-Undo-Tablespaces">4.Undo Tablespaces</h5>
<ul>
<li>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间(初始大小16M)，用于存储undo log日志。</li>
</ul>
<h5 id="5-Temporary-Tablespaces">5.Temporary Tablespaces</h5>
<ul>
<li>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</li>
</ul>
<h5 id="6-Doublewrite-Buffer-Files">6.Doublewrite Buffer Files</h5>
<ul>
<li>
<p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p>
</li>
<li>
<p>dblwr后缀文件</p>
</li>
</ul>
<h5 id="7-Redo-Log">7.Redo Log</h5>
<ul>
<li>
<p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：</p>
<ul>
<li>重做日志缓冲(redo log buffer），在内存中</li>
<li>重做日志文件（redo log）在磁盘中。</li>
</ul>
</li>
<li>
<p>当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p>
</li>
<li>
<p>以循环方式写入重做日志，涉及两个文件ib_logfile0和ib_logfile1</p>
</li>
</ul>
<h4 id="3-后台线程">3.后台线程</h4>
<h5 id="1-Master-Thread">1.Master Thread</h5>
<ul>
<li>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。</li>
</ul>
<h5 id="2-IO-Thread"><a href="http://2.IO">2.IO</a> Thread</h5>
<ul>
<li>在InnoDB存储引擎中大量使用了AIO来处理IO请求，这样可以极大地提高数据库的性能，而IO Thread主要负素这些IO请求的回调。</li>
</ul>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>默认个数</th>
<th>职责</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read thread</td>
<td>4</td>
<td>负责读操作</td>
</tr>
<tr>
<td>Write thread</td>
<td>4</td>
<td>负责写操作</td>
</tr>
<tr>
<td>Log thread</td>
<td>1</td>
<td>负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td>Insert buffer thread</td>
<td>1</td>
<td>负责将写缓冲区内容刷新到磁盘</td>
</tr>
</tbody>
</table>
<h5 id="3-Purge-Thread">3.Purge Thread</h5>
<ul>
<li>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收</li>
</ul>
<h5 id="4-Page-Cleaner-Thread">4.Page Cleaner Thread</h5>
<ul>
<li>协助Master Thread刷新脏页到磁盘的线程，它可以减轻Master Thread的工作压力，减少阻塞</li>
</ul>
<h4 id="4-总结">4.总结</h4>
<ul>
<li>业务操作时直接操作缓冲区中的数据，缓冲区中没有数据时，将磁盘中的数据加载回来再存储到缓冲区中，缓冲区中的数据再以一定的频率，通过后台线程刷新到磁盘中，在磁盘中进行永久化保留</li>
</ul>
<h3 id="3-事务原理">3.事务原理</h3>
<h4 id="1-概述">1.概述</h4>
<ul>
<li>
<p>事务有四个特性：</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
</li>
<li>
<p>其中原子性，一致性，持久性由redo log和undo log这两份日志来保证</p>
</li>
<li>
<p>隔离性则由锁机制和MVCC多版本并发控制来实现</p>
</li>
</ul>
<h4 id="2-redo-log">2.redo log</h4>
<ul>
<li>
<p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>
</li>
<li>
<p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
</li>
<li>
<p>这种先写日志再将脏页中的数据刷新到磁盘的机制称为WAL(Write-Ahead-Logging)</p>
</li>
<li>
<p>保证了事务的持久性</p>
</li>
</ul>
<h4 id="3-undo-log">3.undo log</h4>
<ul>
<li>回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和 MVCC(多版本并发控制)。</li>
<li>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录（updata之前的数据）。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li>
<li>保证了事务的原子性</li>
<li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li>
<li>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</li>
</ul>
<h3 id="4-MVCC">4.MVCC</h3>
<h4 id="1-基本概念">1.基本概念</h4>
<h5 id="1-当前读">1.当前读</h5>
<ul>
<li>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于日常操作，如select…lock in share mode（共享锁），select …for update，update，insert，delete（排他锁）都是一种当前读</li>
</ul>
<h5 id="2-快照读">2.快照读</h5>
<ul>
<li>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</li>
<li>Read Committed：每次select，都生成一个快照读。</li>
<li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li>
<li>Serializable：快照读会退化为当前读。</li>
</ul>
<h5 id="3-MVCC">3.MVCC</h5>
<ul>
<li>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现</li>
<li>MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</li>
</ul>
<h4 id="2-实现原理">2.实现原理</h4>
<h5 id="1-隐藏字段">1.隐藏字段</h5>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DB_TRX_ID</td>
<td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td>
</tr>
</tbody>
</table>
<h5 id="2-undo-log">2.undo log</h5>
<ul>
<li>
<p>回滚日志，在insert、 update、delete的时候产生的便于数据回滚的日志。</p>
<ul>
<li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</li>
<li>而update、delete的时候，产生的undo log不仅在回滚时需要，在快照读时也需要，不会立即被删除。</li>
</ul>
</li>
<li>
<p>undo log版本链</p>
</li>
<li>
<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录</p>
</li>
<li>
<p>DB_ROLL_PTR指向上一个修改的记录</p>
</li>
</ul>
<h5 id="3-readview">3.readview</h5>
<ul>
<li>readview（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交）id</li>
<li>readview中包含四个核心字段：</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>m_ids</td>
<td>当前活跃的事务id集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务id</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务id，当前最大事务id+1（因为事务id是自增的）</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>readview创建者的事务id</td>
</tr>
</tbody>
</table>
<ul>
<li>版本链数据访问规则
<ul>
<li>trx_id==creator_trx_id？可以访问该版本
<ul>
<li>说明数据是当前这个事务更改的</li>
</ul>
</li>
<li>trx_id&lt;min_trx_id？可以访问该版本
<ul>
<li>说明数据已经提交了</li>
</ul>
</li>
<li>trx_id&gt;max_trx_id？不可以访问该版本
<ul>
<li>说明该事务是再readview生成后才开启</li>
</ul>
</li>
<li>min_trx_id&lt;=trx_id&lt;=max_trx_id？如果trx_id<strong>不在</strong> m_ids中是可以访问该版本的
<ul>
<li>说明数据已经提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<p># trx_id：代表undo log中每一条数据的当前事务id</p>
<p># 从最新的undo log记录，逐条数据进行比对，直到查找到符合规则的记录返回</p>
<ul>
<li>不同的隔离级别，生成readview的时机不同
<ul>
<li>rc：在事务每一次执行快照读时生成readview</li>
<li>rr：仅在事务中第一次执行快照读时生成readview，后续复用该readview</li>
</ul>
</li>
</ul>
<h2 id="10-MySQL管理">10.MySQL管理</h2>
<h3 id="1-系统数据库">1.系统数据库</h3>
<ul>
<li>在MySQL数据库安装完后，自带了四个数据库</li>
</ul>
<table>
<thead>
<tr>
<th>数据库</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql</td>
<td>存储MySQL服务器正常运行所需要的各种信息（时区，主从，用户，权限）</td>
</tr>
<tr>
<td>information_schema</td>
<td>提供了访问数据库元数据的各种表和视图，包含数据库，表，字段类型及访问权限等</td>
</tr>
<tr>
<td>performance_schema</td>
<td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td>
</tr>
<tr>
<td>sys</td>
<td>包含了一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</td>
</tr>
</tbody>
</table>
<h3 id="2-常用工具">2.常用工具</h3>
<h4 id="1-mysql">1.mysql</h4>
<ul>
<li>
<p>mysql的客户端工具</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql 选项 数据库</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>选项：</p>
<ul>
<li>
<p>-u，指定用户名</p>
</li>
<li>
<p>-p，指定密码</p>
</li>
<li>
<p>-h，指定服务器IP或域名</p>
</li>
<li>
<p>-P，指定连接端口</p>
</li>
<li>
<p>-e，执行SQL语句并退出</p>
<ul>
<li>
<p>-e这个选项可以在MySQL客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式较为方便</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p密码 数据库名 -e&#x27;sql语句&#x27;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h4 id="2-mysqladmin">2.mysqladmin</h4>
<ul>
<li>
<p>mysqladmin是一个执行管理操作的客户端程序，可以用它来检查服务器的配置和当前状态，创建并删除数据库等</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p密码 drop 数据库名</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p密码 version</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过帮助文档查看选项：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqladmin --help</span><br></pre></td></tr></table></figure>
<h4 id="3-mysqlbinlog">3.mysqlbinlog</h4>
<ul>
<li>
<p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog日志管理工具</p>
</li>
<li>
<p>语法</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlbinlog 选项 binlog文件名1 binlog文件名2 ...</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>选项：</p>
<ul>
<li>-d，指定数据库名称，只列出指定的数据库相关操作</li>
<li>-o，忽略掉日志中的前n行命令</li>
<li>-r，将输出的文本格式日志输出到指定文件中</li>
<li>-s，显示简单格式，省略掉一些信息</li>
<li>–start-datetime=起始日期 --stop-datetime=截止日期，指定日期间隔内的所有日志</li>
<li>–start-positon=日志起始位置 --stop-position=日志截止位置，指定位置间隔内的所有日志</li>
</ul>
</li>
</ul>
<h4 id="4-mysqlshow">4.mysqlshow</h4>
<ul>
<li>
<p>mysqlshow客户端对象查找工具，用来快速查找存在哪些数据库，数据库中的表，表中的列或者索引</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlshow 选项 数据库名称 表名称 字段名称</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>选项：</p>
<ul>
<li>–count，显示数据库及表的统计信息（数据库，表均可不指定）</li>
<li>-i，显示指定数据库或者指定表的状态信息</li>
</ul>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlshow -uroot -p密码 --count</span><br></pre></td></tr></table></figure>
<p># 查询每个数据库的表的数量及表中记录的数量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlshow -uroot -p密码 数据库名 --count</span><br></pre></td></tr></table></figure>
<p># 查询指定数据库中每个表中的字段数及行数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlshow -uroot -p密码 数据库名 表名 --count</span><br></pre></td></tr></table></figure>
<p># 查询指定数据库中指定表的详细情况</p>
<h4 id="5-mysqldump">5.mysqldump</h4>
<ul>
<li>
<p>mysqldump客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump 选项 数据库名 表名</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump 选项 --database 数据库名1 数据库名2 ...</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump 选项 -B 数据库名1 数据库名2 ...</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump 选项 --all-databases</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump 选项 -A</span><br></pre></td></tr></table></figure>
<p># 后面加**&gt; 文件名.sql** 来指定保存到哪个文件</p>
<ul>
<li>
<p>选项：</p>
<ul>
<li>
<p>连接选项：</p>
<ul>
<li>
<p>-u，指定用户名</p>
</li>
<li>
<p>-p，指定密码</p>
</li>
<li>
<p>-h，指定服务器IP或域名</p>
</li>
<li>
<p>-P，指定连接端口</p>
</li>
</ul>
</li>
<li>
<p>输出选项：</p>
<ul>
<li>–add-drop-database，在每个数据库创建语句前加上drop database语句</li>
<li>–add-drop-table，在每个表创建语句前加上drop table语句，默认开启；不开启（–skip-add-drop-table）</li>
<li>-n，不包含数据库的创建语句</li>
<li>-t，不包含数据表的创建语句</li>
<li>-d，不包含数据</li>
<li>-T，自动生成两个文件：
<ul>
<li>.sql后缀文件，创建表结构的语句</li>
<li>.txt后缀文件，数据文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-mysqlimport-source">6.mysqlimport/source</h4>
<ul>
<li>
<p>mysqlimport是客户端数据导入工具，用来导入mysqldump加-T参数后导出的文本文件</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlimport 选项 数据库名 文件位置</span><br></pre></td></tr></table></figure>
<ul>
<li>例如：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlimport -uroot -p密码 数据库名 文件目录/文件名.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果需要导入sql文件，可以使用mysql中的source指令</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /root/文件名.sql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL运维</title>
    <url>/2025/08/27/MySQL%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>MySQL运维</h1>
<h2 id="1-日志">1.日志</h2>
<h3 id="1-错误日志">1.错误日志</h3>
<ul>
<li>
<p>错误日志是 MySQL 中最重要的日志之一，它记录了当mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。</p>
</li>
<li>
<p>当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p>
</li>
<li>
<p>该日志是默认开启的，默认存放目录/var/log/，默认的日志文件名为mysqld.log。查看日志位置：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-二进制日志">2.二进制日志</h3>
<h4 id="1-介绍">1.介绍</h4>
<ul>
<li>
<p>二进制日志（binlog）记录了所有ddl（数据定义语言）语句和dml（数据操纵语言）语句，但不包括数据查询（select，show）语句</p>
</li>
<li>
<p>作用：</p>
<ul>
<li>
<p>灾难时的数据恢复，数据库崩溃后再次执行二进制日志中的内容就可以恢复</p>
</li>
<li>
<p>MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启的，涉及参数：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>可以查询到：</p>
<ul>
<li>log_bin：开启或关闭</li>
<li>log_bin_basename：日志文件位置，文件由binlog和编号组成</li>
<li>log_bin_index：索引文件位置</li>
</ul>
</li>
</ul>
<h4 id="2-日志格式">2.日志格式</h4>
<table>
<thead>
<tr>
<th>日志格式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>statement</td>
<td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中</td>
</tr>
<tr>
<td>row</td>
<td>基于行的日志记录，记录的是每一行的数据变更（默认）</td>
</tr>
<tr>
<td>mixed</td>
<td>混合了statement和row两种格式，默认采用statement，在某些特殊情况下会自动切换为row进行记录</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p># 查询日志格式</p>
<p># 需要在文件中修改日志格式</p>
<p># 修改后会在新的日志文件中记录</p>
<h4 id="3-日志查看">3.日志查看</h4>
<ul>
<li>
<p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具mysqlbinlog来查看</p>
</li>
<li>
<p>语法：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlbinlog 选项 日志文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>选项：</p>
<ul>
<li>-d，指定数据库名称，只列出指定的数据库相关操作</li>
<li>-o，忽略掉日志中的前n行命令</li>
<li>-v，将行事件（数据变更）重构为SQL语句</li>
<li>-w，将行事件（数据变更）重构为SQL语句，并输出注释信息</li>
</ul>
</li>
</ul>
<h4 id="4-日志删除">4.日志删除</h4>
<ul>
<li>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>reset master;</td>
<td>删除全部binlog日志，删除之后，日志编号，将从binlog.000001重新开始</td>
</tr>
<tr>
<td>purge master logs to ‘binlog.xxxxxx’;</td>
<td>删除xxxxxx编号之前的所有日志（此编号不会被删除）</td>
</tr>
<tr>
<td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’;</td>
<td>删除日志为’yyyy-mm-dd hh24:mi:ss’之前产生的所有日志</td>
</tr>
</tbody>
</table>
<ul>
<li>也可以在mysql的配置文件中配置二进制日志的过期时间，设置后，二进制日志过期会自动删除</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_expire_logs_seconds%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p># 默认30天</p>
<h3 id="3-查询日志">3.查询日志</h3>
<ul>
<li>
<p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的</p>
</li>
<li>
<p>涉及参数：general_log</p>
</li>
<li>
<p>修改MySQL的配置文件/etc/my.cnf文件，添加内容：</p>
</li>
<li>
<p><strong>general_log=1</strong></p>
</li>
</ul>
<p># 开启</p>
<ul>
<li>general_log_file=目录/文件名</li>
</ul>
<p># 指定文件名，默认文件名为主机名.log</p>
<h3 id="4-慢查询日志">4.慢查询日志</h3>
<ul>
<li>
<p>慢查询日志记录了所有执行时间超过参数long_query_time 设置值并且扫描记录数不小于min_examined_rowlimit的所有的SQL语句的日志，默认未开启。long_query_time 默认为10秒，最小为0，精度可以到微秒。</p>
</li>
<li>
<p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以在MySQL的配置文件/etc/my.cnf文件中修改log_slow_admin_statements和更改此行为log_queries_not_using_indexes</p>
</li>
<li>
<p><strong>log_slow_admin_statements=1</strong></p>
</li>
</ul>
<p># 记录执行较慢的管理语句</p>
<ul>
<li><strong>log_queries_not_using_indexes=1</strong></li>
</ul>
<p># 记录执行较慢的未使用索引的语句</p>
<h2 id="2-主从复制">2.主从复制</h2>
<h3 id="1-概述">1.概述</h3>
<ul>
<li>
<p>主从复制是指将主数据库的DDL 和 DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库（slave）和主库（master）的数据保持同步。</p>
</li>
<li>
<p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。</p>
</li>
<li>
<p>作用：</p>
<ul>
<li>1.主库出现问题，可以快速切换到从库提供服务。</li>
<li>2.实现读写分离，降低主库的访问压力。</li>
<li>3.可以在从库中执行备份，以避免备份期间影响主库服务。</li>
</ul>
</li>
</ul>
<h3 id="2-原理">2.原理</h3>
<ul>
<li>主要分为三步：
<ul>
<li>1.Master 主库在事务提交时，会把数据变更记录在二进制日志文件 binlog中。</li>
<li>2.从库的IOthread读取主库的二进制日志文件 binlog，写入到从库的中继日志Relay Log。</li>
<li>3.slave从库的SQLthread读取中继日志，再将改变反映它自己的数据。</li>
</ul>
</li>
</ul>
<h3 id="3-搭建">3.搭建</h3>
<h4 id="1-服务器准备">1.服务器准备</h4>
<ul>
<li>
<p>主库和从库</p>
</li>
<li>
<p>关闭服务器的防火墙</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<p># 关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>
<p># 关闭防火墙的开机自启动</p>
<ul>
<li>或者</li>
<li>开放指定的端口号</li>
</ul>
<h4 id="2-主库配置">2.主库配置</h4>
<h5 id="1-修改配置文件-etc-my-cnf">1.修改配置文件/etc/my.cnf</h5>
<ul>
<li><strong>server-id=1</strong></li>
</ul>
<p># mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1，默认为1</p>
<ul>
<li><strong>read-only=0</strong></li>
</ul>
<p># 是否只读，1代表只读，0代表读写</p>
<ul>
<li><strong>binlog-ignore-db=数据库名</strong></li>
</ul>
<p># 忽略数据库，指不需要同步的数据库</p>
<ul>
<li><strong>binlog-do-db=数据库名</strong></li>
</ul>
<p># 指定同步的数据库</p>
<h5 id="2-重启MySQL服务器">2.重启MySQL服务器</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
<p># 没有报错则配置成功</p>
<h5 id="3-登录mysql，创建远程连接的账号，并授予主从复制权限">3.登录mysql，创建远程连接的账号，并授予主从复制权限</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p># 创建用户，并设置密码，因为主机名设置为%所以该用户可在任意主机连接该MySQL服务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p># 为用户分配主从复制权限</p>
<h5 id="4-通过指令，查看二进制日志坐标">4.通过指令，查看二进制日志坐标</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>字段含义说明：</p>
<ul>
<li>file：从哪个日志文件开始推送日志文件</li>
<li>position：从哪个位置开始推送日志</li>
<li>binlog_ignore_db：指定不需要同步的数据库</li>
</ul>
</li>
</ul>
<h4 id="3-从库配置">3.从库配置</h4>
<h5 id="1-修改配置文件-etc-my-cnf-2">1.修改配置文件/etc/my.cnf</h5>
<ul>
<li><strong>server-id=2</strong></li>
</ul>
<p># mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1，和主库不一样即可</p>
<ul>
<li><strong>read-only=1</strong></li>
</ul>
<p># 是否只读，1代表只读，0代表读写</p>
<ul>
<li><strong>super-read-only=1</strong></li>
</ul>
<p># 可以将超级管理员也设置为只读，否则也能读写</p>
<h5 id="2-重启MySQL服务器-2">2.重启MySQL服务器</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
<p># 没有报错则配置成功</p>
<h5 id="3-登录mysql，设置主库配置">3.登录mysql，设置主库配置</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">change replication source <span class="keyword">to</span> source_host<span class="operator">=</span><span class="string">&#x27;原主机ip地址&#x27;</span>,source_user<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>,source_password<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>,source_log_file<span class="operator">=</span><span class="string">&#x27;对应二进制日志文件&#x27;</span>,source_log_pos<span class="operator">=</span>从日志中的哪个位置开始同步;</span><br></pre></td></tr></table></figure>
<p># 从日志中的哪个位置开始同步，可以查看二进制日志坐标中的position</p>
<ul>
<li>老版本</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;原主机ip地址&#x27;</span>,master_user<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;对应二进制日志文件名&#x27;</span>,master_log_pos<span class="operator">=</span>从日志中的哪个位置开始同步;</span><br></pre></td></tr></table></figure>
<h5 id="4-开启同步操作">4.开启同步操作</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> replica;</span><br></pre></td></tr></table></figure>
<ul>
<li>老版本(新版本也兼容)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>
<h5 id="5-查看主从同步状态">5.查看主从同步状态</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status;</span><br></pre></td></tr></table></figure>
<ul>
<li>老版本</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status;</span><br></pre></td></tr></table></figure>
<p># 状态中<strong>Replica_IO_Running</strong> 和<strong>Replica_SQL_Running</strong> 为<strong>Yes</strong> 说明主从复制正常</p>
<h2 id="3-分库分表">3.分库分表</h2>
<h3 id="1-介绍-2">1.介绍</h3>
<h4 id="1-问题分析">1.问题分析</h4>
<ul>
<li>
<p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p>
<ul>
<li>1.IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多，带宽不够，网络IO瓶颈。</li>
<li>2.CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。</li>
</ul>
</li>
<li>
<p>分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。</p>
</li>
</ul>
<h4 id="2-拆分策略">2.拆分策略</h4>
<ul>
<li>
<p>垂直拆分</p>
<ul>
<li>垂直分库：以表为依据，根据业务将不同表拆分到不同库中。
<ul>
<li>每个库的表结构都不一样</li>
<li>每个库的数据也不一样</li>
<li>所有库的并集是全量数据</li>
</ul>
</li>
<li>垂直分表：以字段为依据,根据字段属性将不同字段拆分到不同表中。
<ul>
<li>每个表的结构都不一样</li>
<li>每个表的数据也不一样，一般通过一列（主键/外键）关联</li>
<li>所有表的并集是全量数据</li>
</ul>
</li>
</ul>
</li>
<li>
<p>水平拆分</p>
<ul>
<li>水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。
<ul>
<li>每个库的表结构都一样</li>
<li>每个库的数据都不一样</li>
<li>所有库的并集是全量数据</li>
</ul>
</li>
<li>水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个库中。
<ul>
<li>每个表的表结构都一样</li>
<li>每个表的数据都不一样</li>
<li>所有表的并集是全量数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-实现技术">3.实现技术</h4>
<ul>
<li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。</li>
<li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</li>
</ul>
<h3 id="2-MyCat概述">2.MyCat概述</h3>
<h4 id="1-介绍-3">1.介绍</h4>
<ul>
<li>
<p>Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。mycat伪装了mysql的协议，所以可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在。</p>
</li>
<li>
<p>优势：</p>
<ul>
<li>性能可靠稳定</li>
<li>强大的技术团队</li>
<li>体系完善</li>
<li>社区活跃</li>
</ul>
</li>
<li>
<p>MyCat中间件服务器需要安装jdk和mycat</p>
</li>
<li>
<p>mycat解压后有主要四个目录：</p>
<ul>
<li>bin：存放可执行文件，用于启动停止mycat</li>
<li>conf：存放mycat的配置文件</li>
<li>lib：存放mycat的项目依赖包（jar）</li>
<li>logs：存放mycat的日志文件</li>
</ul>
</li>
</ul>
<h4 id="2-概念介绍">2.概念介绍</h4>
<ul>
<li>逻辑结构：</li>
<li>逻辑库
<ul>
<li>逻辑表
<ul>
<li>分片节点</li>
</ul>
</li>
</ul>
</li>
<li>物理结构：</li>
<li>节点主机（与分片节点相连）</li>
</ul>
<h3 id="3-MyCat入门">3.MyCat入门</h3>
<h4 id="1-需求">1.需求</h4>
<ul>
<li>由于 tb_order 表中数据量很大，磁盘IO及容量都到达了瓶颈，现在需要对tb_order表进行数据分片，分为三个数据节点，每一个节点主机位于不同的服务器上。</li>
</ul>
<h4 id="2-环境准备">2.环境准备</h4>
<ul>
<li>需要在三台服务器上都建立一个空的数据库</li>
<li>将防火墙关闭或者直接开放指定端口</li>
</ul>
<h4 id="3-分片配置（schema-xml）">3.分片配置（schema.xml）</h4>
<ul>
<li>修改mycat中conf中的schema.xml文件</li>
</ul>
<p># 可以用notepad++的插件NppFTP，show NppFTP Windows，便于编辑</p>
<ul>
<li>1.配置table（逻辑表）的表名</li>
<li>2.配置dataNode（数据节点）的数据节点名</li>
<li>3.配置数据节点连接的dataHost（节点主机）的节点主机名</li>
<li>4.配置关联的节点主机的database（数据库）的数据库名</li>
<li>5.在下面的dataHost中详细配置关联的服务器的ip地址，端口号以及用户名和密码</li>
</ul>
<h4 id="4-分片配置（server-xml）">4.分片配置（server.xml）</h4>
<ul>
<li>
<p>修改mycat中conf中的server.xml文件</p>
</li>
<li>
<p>配置mycat的用户及用户的权限信息</p>
</li>
<li>
<p>将user中的schemas后面的testdb改为数据库名</p>
</li>
<li>
<p>在readOnly后可以配置是否只可读</p>
</li>
</ul>
<h4 id="5-启动服务">5.启动服务</h4>
<ul>
<li>切换到mycat的安装目录，执行指令启动mycat</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/mycat start</span><br></pre></td></tr></table></figure>
<p># 启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/mycat stop</span><br></pre></td></tr></table></figure>
<p># 停止</p>
<p># mycat启动后占用端口号8066</p>
<ul>
<li>
<p>启动完成后可以查看logs目录下的启动日志，查看mycat是否启动完成</p>
</li>
<li>
<p>登录</p>
</li>
<li>
<p>和MySQL一样</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h 主机ip地址 -P 8066 -u root -p</span><br></pre></td></tr></table></figure>
<h3 id="4-MyCat配置">4.MyCat配置</h3>
<h4 id="1-schema-xml">1.schema.xml</h4>
<ul>
<li>schema.xml作为MyCat中最重要的配置文件之一，涵盖了MyCat的逻辑库、逻辑表、分片规则、分片节点及数据源的配置。</li>
<li>主要包含三组标签</li>
</ul>
<h5 id="1-schema">1.schema</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;DB01&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name-</span>&quot;<span class="attr">TB</span> <span class="attr">ORDER</span>&quot; <span class="attr">dataNode</span>=<span class="string">&quot;dnl,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>schema标签用于定义 MyCat实例中的逻辑库，一个MyCat实例中，可以有多个逻辑库，可以通过 schema标签来划分不同的逻辑库。</p>
</li>
<li>
<p>MyCat中的逻辑库的概念，等同于ySQL中的database概念，需要操作某个逻辑库下的表时，也需要切换逻辑库(use xxx)。</p>
</li>
<li>
<p>核心属性：</p>
<ul>
<li>name：指定自定义的逻辑库库名</li>
<li>checksdLschema：在SOL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去除，false：不自动去除</li>
<li>sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录</li>
</ul>
</li>
<li>
<p>子标签table</p>
<ul>
<li>table标签定义了MyCat中逻辑库schema下的逻辑表，所有需要拆分的表都需要在table标签中定义。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;DB01&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name-</span>&quot;<span class="attr">TB</span> <span class="attr">ORDER</span>&quot; <span class="attr">dataNode</span>=<span class="string">&quot;dnl, dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>核心属性：</p>
<ul>
<li>name：定义逻辑表表名，在该逻辑库下唯一</li>
<li>dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔</li>
<li>rule：分片规则的名字，分片规则名字是在rule.xml中定义的</li>
<li>primaryKey：逻辑表对应真实表的主键</li>
<li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配置为global</li>
</ul>
</li>
</ul>
<h5 id="2-dataNode">2.dataNode</h5>
<ul>
<li>dataNode标签中定义了MyCat中的数据节点，也就是我们通常说的数据分片。一个dataNode标签就是一个独立的数据分片。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;dbo1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;dbo1&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database-</span>&quot;<span class="attr">dbo1</span>&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>核心属性：
<ul>
<li>name：定义数据节点名称</li>
<li>dataHost：数据库实例主机名称，引用自dataHost 标签中name属性</li>
<li>database：定义分片所属数据库</li>
</ul>
</li>
</ul>
<h5 id="3-dataHost">3.dataHost</h5>
<ul>
<li>dataHost标签在MyCat逻辑库中作为底层标签存在，直接定义了具体的数据库实例、读写分离、心跳语句。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://192.168.200.210:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai&amp;amp:characterEncoding-utf8&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">&lt;/dataHost》</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>核心属性：</p>
<ul>
<li>name：唯一标识，供上层标签使用</li>
<li>maxCon/minCon: 最大连接数/最小连接数</li>
<li>balance:负载均衡策略，取值0,1,2,3</li>
<li>writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）</li>
<li>dbDriver：数据库驱动，支持native、jdbc</li>
</ul>
</li>
</ul>
<h4 id="2-rule-xml">2.rule.xml</h4>
<ul>
<li>rule.xml中定义所有拆分表的规则，在使用过程中可以灵活的使用分片算法，或者对同一个分片算法使用不同的参数，它让分片过程可配置化。主要包含两类标签：tableRule、Function</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-long&quot;</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">colunsJ</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 分片规则</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name-</span>&quot;<span class="attr">mapFile</span>&quot;&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 关联的分片算法rang-long，封装在外部文件autopartition-long.txt</p>
<h4 id="3-server-xml">3.server.xml</h4>
<ul>
<li>
<p>server.xml配置文件包含了MyCat的系统配意信息，主要有两个重要的标签：System、user。</p>
</li>
<li>
<p>system</p>
<ul>
<li>对应的系统配置项及其含义，参考资料。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nonePasswordLogin&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useHandshakeV10&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useSqlStat&quot;</span>&gt;</span>l<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>user</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>schemas后的表示该用户可以访问的逻辑库，多个逻辑库之间逗号分隔</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">privileges</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">dml</span>=<span class="string">&quot;0110&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb01&quot;</span> <span class="attr">dml</span>=<span class="string">&quot;0000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb02&quot;</span> <span class="attr">dml</span>=<span class="string">&quot;1111&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">privileges</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># &lt;privileges check=“false”&gt;表示是否开启DML权限检查，默认为false</p>
<p># &lt;schema name=“TESTDB” dml=“0110”&gt;配置指定逻辑库的权限</p>
<p># &lt;table name=“tb01” dml=“0000”&gt;&lt;/table&gt;配置指定逻辑表的权限，就近原则：以逻辑表为准（如果配置了逻辑表权限）</p>
<p># 0000，用二进制数对应IUSD（增改查删，例如1010则为增和查）的权限</p>
<h3 id="5-MyCat分片">5.MyCat分片</h3>
<h4 id="1-垂直拆分">1.垂直拆分</h4>
<h5 id="1-场景">1.场景</h5>
<ul>
<li>
<p>在业务系统中，涉及以下表结构，但是由于用户与订单每天都会产生大量的数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分，原有的数据库表如下</p>
<ul>
<li>省市区</li>
<li>商品
<ul>
<li>基础信息</li>
<li>品牌</li>
<li>分类</li>
<li>编号</li>
<li>详细信息</li>
</ul>
</li>
<li>订单
<ul>
<li>详细信息</li>
<li>支付记录</li>
</ul>
</li>
<li>用户
<ul>
<li>用户名</li>
<li>用户地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>将用户和省市区，商品，订单存放在三个分片中</p>
</li>
</ul>
<h5 id="2-准备">2.准备</h5>
<ul>
<li>在三台MySQL中创建数据库shopping</li>
</ul>
<h5 id="3-配置">3.配置</h5>
<ul>
<li>在schema中配置逻辑库，逻辑表，以及指定每一个逻辑表所关联的数据节点</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;SHOPPING&quot;</span> <span class="attr">checksgLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb goods base&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dnl&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb goods brand&quot;</span> <span class="attr">dataNode-</span>&quot;<span class="attr">dnl</span>&quot; <span class="attr">primaryKey</span>&quot;<span class="attr">id</span>&quot;/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb goods cat&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;th goods desc&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dnl&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;goods id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb goods item&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dnl&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb order item&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb order master&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;order id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb order pay log&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;out trade no&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;th user address&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb areas provinces&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb areas city&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb areas region&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhostl&quot;</span> <span class="attr">database</span>=<span class="string">&quot;shopping&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;shopping&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name-</span>&quot;<span class="attr">dn3</span>&quot; <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;shopping&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="4-测试">4.测试</h5>
<ul>
<li>在mycat命令行中，通过source指令导入表结构，以及对应的数据，查看数据分布情况</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /目录/文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>查询用户的收件人及收件人地址信息（多表联查）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ua.user_id, ua.contact, p.province, c.city, r.area , ua.address <span class="keyword">from</span> tb_user address ua ,tb_areas_city c, tb_areas_provinces p,tb_areas_region r <span class="keyword">where</span> ua.province_id <span class="operator">=</span> p.provinceid <span class="keyword">and</span> ua.city_id <span class="operator">=</span> c.cityid <span class="keyword">and</span> ua.town_id <span class="operator">=</span> r.areaid;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询每一笔订单及订单的收件地址信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id , payment,receiver,province,city,area <span class="keyword">FROM</span> tb_order_master o , tb_areas_provinces p , tb_areas_city c, tb_areas_region r <span class="keyword">WHERE</span> o.receiver_province <span class="operator">=</span> p.provinceid <span class="keyword">AND</span> o.receiver_city <span class="operator">=</span> c.cityid <span class="keyword">AND</span> o.receiver_region <span class="operator">=</span> r.areaid;</span><br></pre></td></tr></table></figure>
<p># 这里直接执行会报错，这是跨两库的多表联查</p>
<h5 id="5-全局表配置">5.全局表配置</h5>
<ul>
<li>对于省、市、区/县表tb_areas_provinces,tb_areas_city,tb_areas_region，是属于数据字典表，在多个业务模块中都可能会遇到，可以将其设置为全局表，利于业务操作。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_provinces&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dnl,dn2,dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span><span class="attr">type</span>=<span class="string">&quot;global&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p># 对三张表进行全局配置，查询的时候就会把这三张表路由到订单的数据库中，这样就能实现跨两库的多表联查</p>
<p># 全局表更新后关联的其他三个库中的表也会更新</p>
<h4 id="2-水平拆分">2.水平拆分</h4>
<h5 id="1-场景-2">1.场景</h5>
<ul>
<li>在业务系统中，有一张表(日志表，业务系统每天都会产生大量的日志数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分。</li>
</ul>
<h5 id="2-准备-2">2.准备</h5>
<ul>
<li>在三台MySQL中创建数据库itcast</li>
</ul>
<h5 id="3-配置-2">3.配置</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITCAST&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_log&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn4,dn5,dn6&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn4&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhosti&quot;</span> <span class="attr">database</span>=<span class="string">&quot;itcast&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn5&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;itcast&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn6&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;itcast&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p># 这里rule=&quot;mod-long&quot;将分片规则配置为取模</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>SHOPPING,ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 增加访问的逻辑库</p>
<ul>
<li>创建表结构并导入数据</li>
</ul>
<h4 id="3-分片规则">3.分片规则</h4>
<h5 id="1-范围（auto-sharding-long）">1.范围（auto-sharding-long）</h5>
<ul>
<li>根据指定的字段及其配置的范围与数据节点的对应情况，来决定该数据属于哪一个分片。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name-</span>&quot;<span class="attr">tb</span> <span class="attr">operate</span>&quot; <span class="attr">dataNode-</span>&quot;<span class="attr">dn4</span>,<span class="attr">dn5</span>,<span class="attr">dn6</span>&quot; <span class="attr">rule</span>&quot;<span class="attr">auto-sharding-long</span>&quot; /&gt;</span></span><br></pre></td></tr></table></figure>
<p># 在schema.xml中通过rule来指定对应的分片规则</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-long&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p># rule&quot;auto-sharding-long&quot;分片规则引用的是rule.xml中定义的分片规则</p>
<p># &lt;columns&gt;id&lt;columns&gt;定义了根据id字段进行分片</p>
<p># &lt;algorithm&gt;rang-long&lt;/algorithm&gt;分片对应的算法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span> &gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># &lt;algorithm&gt;rang-long&lt;/algorithm&gt;引用rule.xml中的function</p>
<p># class=&quot;io.mycat.route.function.AutoPartitionByLong&quot;这个java类中对分片规则进行定义解析</p>
<p># &lt;property name=“mapFile” &gt;autopartition-long.txt&lt;/property&gt;又引用了一个外部文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># range start-end ,data node index</span><br><span class="line"># K=1000,M=10000.</span><br><span class="line">0-500M=0</span><br><span class="line">500M-1000M=1</span><br><span class="line">1000M-1500M=2</span><br></pre></td></tr></table></figure>
<p># autopartition-long.txt这个外部文件中具体配置了范围对应的节点</p>
<h5 id="2-取模（mod-long）">2.取模（mod-long）</h5>
<ul>
<li>根据指定的字段值与节点数量进行求模运算，根据运算结果，来决定该数据属于哪一个分片。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 在rule.xml中配置节点数</p>
<h5 id="3-一致性hash（sharding-by-murmur）">3.一致性hash（sharding-by-murmur）</h5>
<ul>
<li>所谓一致性哈希，将字符串字段根据哈希计算，相同的哈希因子计算值总是被划分到相同的分区表中，不会因为分区节点的增加而改变原来数据的分区位置。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># function中配置节点数</p>
<h5 id="4-枚举（sharding-by-intfile）">4.枚举（sharding-by-intfile）</h5>
<ul>
<li>通过在配置文件中配置可能的枚举值,指定数据分布到不同数据节点上,本规则适用于按照省份、性别、状态拆分数据等业务。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># function配置默认节点值，当插入的数据超出了指定的枚举值则默认存储到这个节点</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># function中引用外部文件，在partition-hash-int.txt这个文件中直接定义例如3=1，则字段值为3时存到第2个节点，节点是从0开始的</p>
<ul>
<li>如果有不同的字段要用同一种分片规则，则可以将原本的分片规则复制黏贴，修改规则名称，修改字段，对应的算法不更改</li>
</ul>
<h5 id="5-应用指定（sharding-by-substring）">5.应用指定（sharding-by-substring）</h5>
<ul>
<li>运行阶段由应用自主决定路由到那个分片，直接根据子字符串（必须是数字，例如截取前2个数字）计算分片号。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-substring&quot;</span></span></span><br><span class="line"><span class="tag">	&lt;<span class="attr">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-substring<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-substring&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionDirectBySubString&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;startIndex&quot;</span>&gt;</span>O<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultPartition&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 这个分片规则不在默认的样例中，需要自行添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;startIndex&quot;</span>&gt;</span>O<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 在function中配置开始索引</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 配置截取长度</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 配置分片数量</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultPartition&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 配置默认分片，截取出来的子字符串不在分片数量范围内则存储到默认分片</p>
<h5 id="6-固定分片hash算法（sharding-by-long-hash）">6.固定分片hash算法（sharding-by-long-hash）</h5>
<ul>
<li>
<p>该算法类似于十进制的求模运算，但是为二进制的操作，会将指定字段（值必须是数字）的二进制的前10位与1111111111进行位&amp;运算。</p>
</li>
<li>
<p>位&amp;运算：将前十位的每一位数与1111111111中的相同位置的数字进行对比，相同则为1，不同则为0，获得一个新的数字。1111111111对应的十进制数是2^10-1=1023，所以这里的位&amp;运算得出的结果位于0-1023</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>如果是求模，连续的值，分别分配到各个不同的分片；但是此算法会将连续的值可能分配到相同的分片，降低事务处理的难度。</li>
<li>可以均匀分配到节点，也可以非均匀分配。</li>
<li>分片字段必须为数字类型。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>2,1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>256,512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 2,1表示共三个节点，前两个长度都是256，后一个是512（总的分片长度默认最大为1024）</p>
<p># 2,1和256,512这里配置的数字个数必须对应</p>
<h5 id="7-字符串hash解析（sharding-by-stringhash）">7.字符串hash解析（sharding-by-stringhash）</h5>
<ul>
<li>截取字符串中的指定位置的子字符串，进行哈希运算，算出哈希值与1023进行位&amp;运算，算出分片。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-stringhash&quot;</span></span></span><br><span class="line"><span class="tag">	&lt;<span class="attr">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>name<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-stringhash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByString&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&#x27;partitionCount&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashslice&quot;</span>&gt;</span>0:2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 这个分片规则也是需要自行添加的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&#x27;partitionCount&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 两个节点各512长度</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashslice&quot;</span>&gt;</span>0:2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># hash运算位，格式start:end，start从0开始。0在end中出现代表str.length()，-1代表str.length()-1，大于0代表数字本身</p>
<h5 id="8-按（天）日期分片（sharding-by-date）">8.按（天）日期分片（sharding-by-date）</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-date&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByDate&quot;</span>&gt;</span>		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateformat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBecinDate&quot;</span>&gt;</span>2022-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sEndDate&quot;</span>&gt;</span>2022-01-30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sPartionDay&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 需要自行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;daterormat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 日期格式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBeginDate&quot;</span>&gt;</span>2022-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 起始时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sEndDate&quot;</span>&gt;</span>2022-01-30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 截止时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sPartionDay&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 分片周期，每十天位一个分片，到达结束时间后，后面的日期再插入，会重复开始分片插入</p>
<p># dataNode的分片数量必须和这里的分片规则的数量一致，例如从同一年的01-01到12-31，每十天一个分片，则需要37个分片，没有则报错</p>
<h5 id="9-按自然月分片（sharding-by-month）">9.按自然月分片（sharding-by-month）</h5>
<ul>
<li>
<p>mycat中自带的分片规则</p>
</li>
<li>
<p>和按天分片一样需要配置日期格式和起始截止日期</p>
</li>
<li>
<p>一个月为一个分片，到达结束时间后，后面的日期再插入，会重复开始分片插入</p>
</li>
<li>
<p>dataNode的分片数量必须和这里的分片规则的数量一致，例如从同一年的01-01到12-31，每一个月一个分片，则需要12个分片，没有则报错</p>
</li>
</ul>
<h3 id="6-MyCat管理及监控">6.MyCat管理及监控</h3>
<h4 id="1-MyCat原理">1.MyCat原理</h4>
<ul>
<li>
<p>客户端发送插入的SQL语句到mycat</p>
</li>
<li>
<p>mycat</p>
<ul>
<li>解析SQL</li>
<li>分片分析</li>
<li>路由分析，路由到相对应的节点中</li>
<li>读写分离分析</li>
<li>…</li>
</ul>
</li>
<li>
<p>客户端发送查询的SQL语句到mycat</p>
</li>
<li>
<p>mycat</p>
<ul>
<li>解析SQL</li>
<li>分片分析，如果字段值不在规则范围内或者没有这个字段值，则接下来的路由分析会路由到所有库中</li>
<li>路由分析</li>
<li>读写分离分析</li>
<li>…</li>
</ul>
</li>
<li>
<p>分片节点</p>
<ul>
<li>接收到SQL语句</li>
<li>执行后返回结果到mycat</li>
</ul>
</li>
<li>
<p>mycat</p>
<ul>
<li>结果合并</li>
<li>聚合处理</li>
<li>排序处理</li>
<li>分页处理</li>
<li>…</li>
<li>结果返回到客户端</li>
</ul>
</li>
</ul>
<h4 id="2-MyCat管理">2.MyCat管理</h4>
<ul>
<li>
<p>Mycat默认开通2个端口，可以在server.xml中进行修改。</p>
<ul>
<li>
<p>8066数据访问端口，即进行DML和DDL操作。</p>
</li>
<li>
<p>9066数据库管理端口，即mycat服务管理控制功能，用于管理mycat的整个集群状态</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h ip地址 -P 9066 -uroot -p密码</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>show @@help</td>
<td>查看Mycat管理工具帮助文档</td>
</tr>
<tr>
<td>show @@version</td>
<td>查看Mycat的版本</td>
</tr>
<tr>
<td>reload @@config</td>
<td>重新加载Mycat的配置文件</td>
</tr>
<tr>
<td>show @@datasouorce</td>
<td>查Mycat的数据源信息</td>
</tr>
<tr>
<td>show @@datanode</td>
<td>查看MyCat现有的分片节点信息</td>
</tr>
<tr>
<td>show @@threadpool</td>
<td>查看Mycat的线程池信息</td>
</tr>
<tr>
<td>show @@sql</td>
<td>查看执行的SQL</td>
</tr>
<tr>
<td>show @@sql.sum</td>
<td>查看执行的SQL统计</td>
</tr>
</tbody>
</table>
<h4 id="3-MyCat-eye">3.MyCat-eye</h4>
<ul>
<li>
<p>Mlycat-web(Mycat-eye)是对mycat-server提供监控服务，功能不局限于对mycat-server使用。他通过JDBC连接对Mycat、Mysal监控，监控远程服务器(目前仅限于linux系统)的cpu、内存、网络、磁盘。</p>
</li>
<li>
<p>Mycat-eye运行过程中需要依赖zookeeper，因此需要先安装zookeeper。</p>
</li>
<li>
<p>在mycat-web文件夹下</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh start.sh</span><br></pre></td></tr></table></figure>
<p># 启动mycat-web</p>
<ul>
<li>
<p>在浏览器中输入网址：服务器ip：8082/mycat进入网站（需要关闭服务器的防火墙）</p>
</li>
<li>
<p>在网站中进入mycat配置中的mycat服务配置</p>
</li>
<li>
<p>管理端口：9066</p>
</li>
<li>
<p>服务端口：8066</p>
</li>
<li>
<p>数据库名称：这里要配置mycat-server配置文件schema.xml中schema标签配置的name。</p>
</li>
<li>
<p>用户名：这里要配置mycat-server配置文件server.xml中user标签中name配置的值</p>
</li>
<li>
<p>密码：这里要配置mycat-server配置文件server.xml中user标签中，property name=&quot;password&quot;配置的密码。</p>
</li>
</ul>
<h2 id="4-读写分离">4.读写分离</h2>
<h3 id="1-介绍-4">1.介绍</h3>
<ul>
<li>读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</li>
<li>通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</li>
</ul>
<h3 id="2-一主一从">2.一主一从</h3>
<h4 id="1-原理">1.原理</h4>
<ul>
<li>MySQL的主从复制，是基于二进制日志（binlog）实现的。</li>
</ul>
<h4 id="2-环境准备-2">2.环境准备</h4>
<ul>
<li>搭建主从结构</li>
</ul>
<h3 id="3-一主一从读写分离">3.一主一从读写分离</h3>
<h4 id="1-配置">1.配置</h4>
<ul>
<li>在schema.xml文件中配置主库writeHost host=“master” url=和从库readHost host=“slave” url=的ip地址</li>
</ul>
<p># 从库的需要自行添加</p>
<ul>
<li>
<p>还要在server.xml中的user标签中的schemas中新增逻辑库，增加权限</p>
</li>
<li>
<p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控制，将参数值修改为1或3</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>不开启读写分离机制，所有读操作都发送到当前可用的writeHost上</td>
</tr>
<tr>
<td>1</td>
<td>全部的readHost 与备用的writeHost都参与select语句的负载均衡（主要针对于双主双从模式）</td>
</tr>
<tr>
<td>2</td>
<td>所有的读写操作都随机在writeHost，readHost上分发</td>
</tr>
<tr>
<td>3</td>
<td>所有的读请求随机分发到writeHost对应的readHost上执行,writeHost不负担读压力</td>
</tr>
</tbody>
</table>
<h4 id="2-问题">2.问题</h4>
<ul>
<li>主节点Master宕机之后,业务系统就只能够读,而不能写入数据了。</li>
</ul>
<h3 id="4-双主双从">4.双主双从</h3>
<h4 id="1-介绍-5">1.介绍</h4>
<ul>
<li>一个主机 Master1 用于处理所有写请求，它的从机 Slave1和另一台主机 Master2 还有它的从机库Slave2负责所有读请求。当Master1主机宕机后，Master2 主机负责写请求，Master1、Master2 互为备机。</li>
</ul>
<h4 id="2-环境准备-3">2.环境准备</h4>
<ul>
<li>共需要5台服务器，1台中间件，2台主库，2台从库</li>
<li>全部关闭防火墙</li>
</ul>
<h4 id="3-搭建-2">3.搭建</h4>
<h5 id="1-修改主库1的配置文件-etc-my-cnf">1.修改主库1的配置文件/etc/my.cnf</h5>
<ul>
<li><strong>server-id=1</strong></li>
</ul>
<p># mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1，默认为1</p>
<ul>
<li><strong>binlog-do-db=数据库名</strong></li>
</ul>
<p># 指定同步的数据库,需要写三句来同步三个数据库</p>
<ul>
<li><strong>log-slave-updates</strong></li>
</ul>
<p># 在作为从库时，有写入操作也要更新二进制日志文件</p>
<h5 id="2-重启mysql服务">2.重启mysql服务</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
<h5 id="3-修改主库2的配置文件-etc-my-cnf">3.修改主库2的配置文件/etc/my.cnf</h5>
<ul>
<li>与主库1配置相同，只需修改id</li>
</ul>
<h5 id="4-两台主库创建账户并授权">4.两台主库创建账户并授权</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> Root@密码<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure>
<p># 创建用户，并设置密码，该用户可在任意主机连接该MySQL服务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p># 为用户分配主从复制权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure>
<p># 通过指令查看两台主库的二进制日志坐标</p>
<h5 id="5-修改从库1配置文件-etc-my-cnf">5.修改从库1配置文件/etc/my.cnf</h5>
<ul>
<li><strong>server-id=2</strong></li>
</ul>
<p># mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1</p>
<h5 id="6-重启mysql服务">6.重启mysql服务</h5>
<h5 id="7-修改从库2配置文件-etc-my-cnf">7.修改从库2配置文件/etc/my.cnf</h5>
<p># 修改id</p>
<h5 id="8-从库1配置关联的主库1">8.从库1配置关联的主库1</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;对应主库ip&#x27;</span>,MASTER_USER<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>,MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>,MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;二进制日志文件名&#x27;</span>,MASTER_LOG_POS<span class="operator">=</span>日志中开始的位置；</span><br></pre></td></tr></table></figure>
<p># 需要注意slave1对应的是master1，slave2对应的是master2。</p>
<h5 id="9-启动从库主从复制，查看从库状态">9.启动从库主从复制，查看从库状态</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status;</span><br></pre></td></tr></table></figure>
<h5 id="10-从库2配置关联的主库2">10.从库2配置关联的主库2</h5>
<ul>
<li>与从库1配置关联的主库1相同</li>
</ul>
<h5 id="11-主库之间的相互复制">11.主库之间的相互复制</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;另一个主库ip&#x27;</span>,MASTER_USER<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>,MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>,MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;二进制日志文件名&#x27;</span>,MASTER_LOG_POS<span class="operator">=</span>日志中开始的位置；</span><br></pre></td></tr></table></figure>
<p># 在两台主库中都要执行指令</p>
<h5 id="12-启动从库主从复制，查看从库状态">12.启动从库主从复制，查看从库状态</h5>
<h3 id="5-双主双从读写分离">5.双主双从读写分离</h3>
<ul>
<li>在schema.xml文件中配置主库writeHost host=“master” url=和从库readHost host=“slave” url=的ip地址</li>
</ul>
<p># 两个主库从库都要配置，从库分别配置在对应主库下</p>
<ul>
<li>修改balance的数值为1</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1 dbType=&quot;</span><span class="attr">mysql</span>&quot; <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p># 新增writeType和switchType</p>
<ul>
<li>
<p>writeType</p>
<ul>
<li>0：写操作都转发到第1台writeHost, writeHost1挂了，会切换到writeHost2上；</li>
<li>1：所有的写操作都随机地发送到配置的writeHost上；</li>
</ul>
</li>
<li>
<p>switchType</p>
<ul>
<li>-1：不自动切换</li>
<li>1：自动切换</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>小六壬起课器</title>
    <url>/2025/02/24/%E5%B0%8F%E5%85%AD%E5%A3%AC%E8%B5%B7%E8%AF%BE%E5%99%A8/</url>
    <content><![CDATA[<h1><a href="http://xn--65q44jg8bzxec56fv3b.py">小六壬起课器.py</a></h1>
<h2 id="（仅起到起课作用）">（仅起到起课作用）</h2>
<p>​	小六壬，古代中国占卜法，古代主要用于军事韬略，尤以别名诸葛亮马前课著名。</p>
<p>​	在所有术数中时间都是首位，所以第一则是获取当前用户时间。在运行时可能会遇到用户输入各种类型的数据，所以使用try来运行可能出错的代码，并且在报错后循环让用户重新输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#无限循环</span></span><br><span class="line">   <span class="keyword">try</span>: <span class="comment">#尝试运行可能出错的代码</span></span><br><span class="line">      time=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;以24时制输入当地当前时:&quot;</span>)) <span class="comment">#获取时间  </span></span><br><span class="line">   <span class="keyword">except</span> (ValueError, TypeError): <span class="comment">#数值错误和数值类型错误时的处理</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;错误,输入数字有误,例:当前13:11,则输入13&quot;</span>)</span><br><span class="line">      <span class="keyword">continue</span> <span class="comment">#跳过下面的循环，防止因为上面错误导致time没有获取数值而使下面的判断报错</span></span><br><span class="line">   <span class="keyword">if</span> time <span class="keyword">in</span> list10: <span class="comment">#判断输入数字是否为0~23</span></span><br><span class="line">      <span class="keyword">break</span> <span class="comment">#正常则执行下面的代码</span></span><br><span class="line">   <span class="keyword">else</span>: <span class="comment">#不符合则提示并循环</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;错误,输入数字有误,例:当前13:11,则输入13&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>​	小六壬中常见起课方式有日期起课以及随机数起课，在这里仅做了随机数起课。（后续可能增加以日期起课的选择）仍然使用try语句来处理可能遇到的输入数据类型错误，再将得到三个随机数储存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入心中立即想到的任意大小的正整数&quot;</span>)</span><br><span class="line">numbers1 = [<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]  <span class="comment"># 用列表存储 x, y, z</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment"># 循环三次以获取三个数字</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#无限循环</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            numbers1[i] = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">f&quot;请输入第 <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> 个数字: &quot;</span>)) <span class="comment">#使用f语句</span></span><br><span class="line">            <span class="keyword">if</span> numbers1[i] &lt;= <span class="number">0</span>:  <span class="comment"># 检查输入的数字是否为正整数</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;输入数字有误，请输入正负整数&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 如果输入有效，则退出当前的 while 循环</span></span><br><span class="line">        <span class="keyword">except</span> (ValueError,TypeError):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入数字有误，请输入正负整数&quot;</span>)</span><br><span class="line">x, y, z = numbers1 <span class="comment"># 将输入的数字赋值给 x, y, z</span></span><br></pre></td></tr></table></figure>
<p>​	创建一个列表储存十二个时辰，由于一个时辰对应两个小时，所以列表中时辰储存两次，再将时间对应列表中的时辰，以便后续输出，以及字典的调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;子&#x27;</span>,<span class="string">&#x27;丑&#x27;</span>,<span class="string">&#x27;丑&#x27;</span>,<span class="string">&#x27;寅&#x27;</span>,<span class="string">&#x27;寅&#x27;</span>,<span class="string">&#x27;卯&#x27;</span>,<span class="string">&#x27;卯&#x27;</span>,<span class="string">&#x27;辰&#x27;</span>,<span class="string">&#x27;辰&#x27;</span>,<span class="string">&#x27;巳&#x27;</span>,<span class="string">&#x27;巳&#x27;</span>,<span class="string">&#x27;午&#x27;</span>,<span class="string">&#x27;午&#x27;</span>,<span class="string">&#x27;未&#x27;</span>,<span class="string">&#x27;未&#x27;</span>,<span class="string">&#x27;申&#x27;</span>,<span class="string">&#x27;申&#x27;</span>,<span class="string">&#x27;酉&#x27;</span>,<span class="string">&#x27;酉&#x27;</span>,<span class="string">&#x27;戌&#x27;</span>,<span class="string">&#x27;戌&#x27;</span>,<span class="string">&#x27;亥&#x27;</span>,<span class="string">&#x27;亥&#x27;</span>,<span class="string">&#x27;子&#x27;</span>] <span class="comment">#创建时辰列表</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time1 = list1[time] <span class="comment">#将时间对应时辰</span></span><br></pre></td></tr></table></figure>
<p>​	再调用字典将时辰对应12小时制的数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time2 = dict1.get(time1,<span class="string">&#x27;无效值&#x27;</span>) <span class="comment">#调用字典将时辰与数字对应，time1上不用加&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>​	相较于第一版，增加了活六神的功能,仅做展示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time3 = time2%<span class="number">6</span> <span class="comment">#对time2取余数，可知龙头宫位</span></span><br><span class="line">whole = <span class="number">6</span>-time3 <span class="comment">#得出青龙后还有几个元素作为整体</span></span><br><span class="line">element=list11[:whole+<span class="number">1</span>] <span class="comment">#将青龙以及后面的元素作为整体</span></span><br><span class="line"><span class="keyword">if</span> time3 == <span class="number">1</span>:</span><br><span class="line">   list12=list11</span><br><span class="line"><span class="keyword">elif</span> time3 == <span class="number">0</span>:</span><br><span class="line">   list12=[<span class="string">&#x27;朱雀&#x27;</span>,<span class="string">&#x27;勾陈&#x27;</span>,<span class="string">&#x27;白虎&#x27;</span>,<span class="string">&#x27;玄武&#x27;</span>,<span class="string">&#x27;腾蛇&#x27;</span>,<span class="string">&#x27;青龙&#x27;</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   list12=[x <span class="keyword">for</span> x <span class="keyword">in</span> list11 <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> element]+element <span class="comment">#先遍历列表8不属于整体的元素再加上整体中的元素生成新列表10</span></span><br><span class="line">x5,y5,z5 = list5[x1],list5[y1],list5[z1] <span class="comment">#分别给三才赋值六神</span></span><br><span class="line">x6,y6,z6 = list12[x1],list12[y1],list12[z1] <span class="comment">#分别给三才赋值活六神</span></span><br><span class="line">number1,number2,number3 = dict2.get(x3),dict2.get(y3),dict2.get(z3) <span class="comment">#调用字典将五行与列表数字对应</span></span><br><span class="line">list13,list14,list15=<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number1&#125;</span>&#x27;</span>],<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number2&#125;</span>&#x27;</span>],<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number3&#125;</span>&#x27;</span>] <span class="comment">#使用globals()作用于全局区别于locals()只能在一个函数局部内返回变量，生成三才对应的十二长生列表</span></span><br></pre></td></tr></table></figure>
<p>​	由于python自带的以及库中的居中对齐功能无法正常使用，为了美观增加了根据字数增加空格的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_xyz</span>(<span class="params">x,y,z</span>): <span class="comment">#封装成函数</span></span><br><span class="line">   x_len,y_len,z_len = <span class="built_in">len</span>(x),<span class="built_in">len</span>(y),<span class="built_in">len</span>(z)</span><br><span class="line">   <span class="keyword">if</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27; &#x27;</span>, y, <span class="string">&#x27; &#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27; &#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27;&#x27;</span>, y, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27; &#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, y, z)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​	以下是完整代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;子&#x27;</span>,<span class="string">&#x27;丑&#x27;</span>,<span class="string">&#x27;丑&#x27;</span>,<span class="string">&#x27;寅&#x27;</span>,<span class="string">&#x27;寅&#x27;</span>,<span class="string">&#x27;卯&#x27;</span>,<span class="string">&#x27;卯&#x27;</span>,<span class="string">&#x27;辰&#x27;</span>,<span class="string">&#x27;辰&#x27;</span>,<span class="string">&#x27;巳&#x27;</span>,<span class="string">&#x27;巳&#x27;</span>,<span class="string">&#x27;午&#x27;</span>,<span class="string">&#x27;午&#x27;</span>,<span class="string">&#x27;未&#x27;</span>,<span class="string">&#x27;未&#x27;</span>,<span class="string">&#x27;申&#x27;</span>,<span class="string">&#x27;申&#x27;</span>,<span class="string">&#x27;酉&#x27;</span>,<span class="string">&#x27;酉&#x27;</span>,<span class="string">&#x27;戌&#x27;</span>,<span class="string">&#x27;戌&#x27;</span>,<span class="string">&#x27;亥&#x27;</span>,<span class="string">&#x27;亥&#x27;</span>,<span class="string">&#x27;子&#x27;</span>] <span class="comment">#创建时辰列表</span></span><br><span class="line">list2=[<span class="string">&#x27;大安&#x27;</span>,<span class="string">&#x27;留连&#x27;</span>,<span class="string">&#x27;速喜&#x27;</span>,<span class="string">&#x27;赤口&#x27;</span>,<span class="string">&#x27;小吉&#x27;</span>,<span class="string">&#x27;空亡&#x27;</span>] <span class="comment">#创建六宫列表</span></span><br><span class="line">list3=[<span class="string">&#x27;木&#x27;</span>,<span class="string">&#x27;土&#x27;</span>,<span class="string">&#x27;火&#x27;</span>,<span class="string">&#x27;金&#x27;</span>,<span class="string">&#x27;水&#x27;</span>,<span class="string">&#x27;土&#x27;</span>] <span class="comment">#创建五行列表</span></span><br><span class="line">list4=[<span class="string">&#x27;东&#x27;</span>,<span class="string">&#x27;四方&#x27;</span>,<span class="string">&#x27;南&#x27;</span>,<span class="string">&#x27;西&#x27;</span>,<span class="string">&#x27;北&#x27;</span>,<span class="string">&#x27;中央&#x27;</span>] <span class="comment">#创建方位列表</span></span><br><span class="line">list5=[<span class="string">&#x27;青龙&#x27;</span>,<span class="string">&#x27;腾蛇&#x27;</span>,<span class="string">&#x27;朱雀&#x27;</span>,<span class="string">&#x27;白虎&#x27;</span>,<span class="string">&#x27;玄武&#x27;</span>,<span class="string">&#x27;勾陈&#x27;</span>] <span class="comment">#创建六神列表</span></span><br><span class="line">list6=[<span class="string">&#x27;沐浴&#x27;</span>,<span class="string">&#x27;冠带&#x27;</span>,<span class="string">&#x27;临官&#x27;</span>,<span class="string">&#x27;帝旺&#x27;</span>,<span class="string">&#x27;衰&#x27;</span>,<span class="string">&#x27;死&#x27;</span>,<span class="string">&#x27;病&#x27;</span>,<span class="string">&#x27;墓&#x27;</span>,<span class="string">&#x27;绝&#x27;</span>,<span class="string">&#x27;胎&#x27;</span>,<span class="string">&#x27;养&#x27;</span>,<span class="string">&#x27;长生&#x27;</span>] <span class="comment">#创建木对应的十二长生列表</span></span><br><span class="line">list7=[<span class="string">&#x27;胎&#x27;</span>,<span class="string">&#x27;养&#x27;</span>,<span class="string">&#x27;长生&#x27;</span>,<span class="string">&#x27;沐浴&#x27;</span>,<span class="string">&#x27;冠带&#x27;</span>,<span class="string">&#x27;临官&#x27;</span>,<span class="string">&#x27;帝旺&#x27;</span>,<span class="string">&#x27;衰&#x27;</span>,<span class="string">&#x27;死&#x27;</span>,<span class="string">&#x27;病&#x27;</span>,<span class="string">&#x27;墓&#x27;</span>,<span class="string">&#x27;绝&#x27;</span>] <span class="comment">#创建火对应的十二长生列表</span></span><br><span class="line">list8=[<span class="string">&#x27;死&#x27;</span>,<span class="string">&#x27;病&#x27;</span>,<span class="string">&#x27;墓&#x27;</span>,<span class="string">&#x27;绝&#x27;</span>,<span class="string">&#x27;胎&#x27;</span>,<span class="string">&#x27;养&#x27;</span>,<span class="string">&#x27;长生&#x27;</span>,<span class="string">&#x27;沐浴&#x27;</span>,<span class="string">&#x27;冠带&#x27;</span>,<span class="string">&#x27;临官&#x27;</span>,<span class="string">&#x27;帝旺&#x27;</span>,<span class="string">&#x27;衰&#x27;</span>] <span class="comment">#创建金对应的十二长生列表</span></span><br><span class="line">list9=[<span class="string">&#x27;帝旺&#x27;</span>,<span class="string">&#x27;衰&#x27;</span>,<span class="string">&#x27;死&#x27;</span>,<span class="string">&#x27;病&#x27;</span>,<span class="string">&#x27;墓&#x27;</span>,<span class="string">&#x27;绝&#x27;</span>,<span class="string">&#x27;胎&#x27;</span>,<span class="string">&#x27;养&#x27;</span>,<span class="string">&#x27;长生&#x27;</span>,<span class="string">&#x27;沐浴&#x27;</span>,<span class="string">&#x27;冠带&#x27;</span>,<span class="string">&#x27;临官&#x27;</span>] <span class="comment">#创建水，土对应的十二长生列表</span></span><br><span class="line">list10=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>] <span class="comment">#创建时间列表</span></span><br><span class="line">list11=[<span class="string">&#x27;青龙&#x27;</span>,<span class="string">&#x27;朱雀&#x27;</span>,<span class="string">&#x27;勾陈&#x27;</span>,<span class="string">&#x27;白虎&#x27;</span>,<span class="string">&#x27;玄武&#x27;</span>,<span class="string">&#x27;腾蛇&#x27;</span>] <span class="comment">#创建活六神顺序列表</span></span><br><span class="line">dict1=&#123;<span class="string">&#x27;子&#x27;</span>: <span class="number">1</span>,<span class="string">&#x27;丑&#x27;</span>: <span class="number">2</span>,<span class="string">&#x27;寅&#x27;</span>: <span class="number">3</span>,<span class="string">&#x27;卯&#x27;</span>: <span class="number">4</span>,<span class="string">&#x27;辰&#x27;</span>: <span class="number">5</span>,<span class="string">&#x27;巳&#x27;</span>: <span class="number">6</span>,<span class="string">&#x27;午&#x27;</span>: <span class="number">7</span>,<span class="string">&#x27;未&#x27;</span>: <span class="number">8</span>,<span class="string">&#x27;申&#x27;</span>: <span class="number">9</span>,<span class="string">&#x27;酉&#x27;</span>: <span class="number">10</span>,<span class="string">&#x27;戌&#x27;</span>: <span class="number">11</span>,<span class="string">&#x27;亥&#x27;</span>: <span class="number">12</span>&#125; <span class="comment">#创建时辰字典</span></span><br><span class="line">dict2=&#123;<span class="string">&#x27;木&#x27;</span>:<span class="number">6</span>,<span class="string">&#x27;火&#x27;</span>:<span class="number">7</span>,<span class="string">&#x27;金&#x27;</span>:<span class="number">8</span>,<span class="string">&#x27;水&#x27;</span>:<span class="number">9</span>,<span class="string">&#x27;土&#x27;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#无限循环</span></span><br><span class="line">   <span class="keyword">try</span>: <span class="comment">#尝试运行可能出错的代码</span></span><br><span class="line">      time=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;以24时制输入当地当前时:&quot;</span>)) <span class="comment">#获取时间  </span></span><br><span class="line">   <span class="keyword">except</span> (ValueError, TypeError): <span class="comment">#数值错误和数值类型错误时的处理</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;错误,输入数字有误,例:当前13:11,则输入13&quot;</span>)</span><br><span class="line">      <span class="keyword">continue</span> <span class="comment">#跳过下面的循环，防止因为上面错误导致time没有获取数值而使下面的判断报错</span></span><br><span class="line">   <span class="keyword">if</span> time <span class="keyword">in</span> list10: <span class="comment">#判断输入数字是否为0~23</span></span><br><span class="line">      <span class="keyword">break</span> <span class="comment">#正常则执行下面的代码</span></span><br><span class="line">   <span class="keyword">else</span>: <span class="comment">#不符合则提示并循环</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;错误,输入数字有误,例:当前13:11,则输入13&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入心中立即想到的任意大小的正整数&quot;</span>)</span><br><span class="line">numbers1 = [<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]  <span class="comment"># 用列表存储 x, y, z</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment"># 循环三次以获取三个数字</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#无限循环</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            numbers1[i] = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">f&quot;请输入第 <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> 个数字: &quot;</span>)) <span class="comment">#使用f语句</span></span><br><span class="line">            <span class="keyword">if</span> numbers1[i] &lt;= <span class="number">0</span>:  <span class="comment"># 检查输入的数字是否为正整数</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;输入数字有误，请输入正负整数&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 如果输入有效，则退出当前的 while 循环</span></span><br><span class="line">        <span class="keyword">except</span> (ValueError,TypeError):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入数字有误，请输入正负整数&quot;</span>)</span><br><span class="line">x, y, z = numbers1 <span class="comment"># 将输入的数字赋值给 x, y, z</span></span><br><span class="line">time1 = list1[time] <span class="comment">#将时间对应时辰</span></span><br><span class="line">time2 = dict1.get(time1,<span class="string">&#x27;无效值&#x27;</span>) <span class="comment">#调用字典将时辰与数字对应，time1上不用加&#x27;&#x27;</span></span><br><span class="line">time3 = time2%<span class="number">6</span> <span class="comment">#对time2取余数，可知龙头宫位</span></span><br><span class="line">whole = <span class="number">6</span>-time3 <span class="comment">#得出青龙后还有几个元素作为整体</span></span><br><span class="line">element=list11[:whole+<span class="number">1</span>] <span class="comment">#将青龙以及后面的元素作为整体</span></span><br><span class="line">x1,y1,z1= (x-<span class="number">1</span>)%<span class="number">6</span>,(x+y-<span class="number">2</span>)%<span class="number">6</span>,(x+y+z-<span class="number">3</span>)%<span class="number">6</span> <span class="comment">#分别取余数</span></span><br><span class="line">x2,y2,z2 = list2[x1],list2[y1],list2[z1] <span class="comment">#分别给三才赋值六宫</span></span><br><span class="line">x3,y3,z3 = list3[x1],list3[y1],list3[z1] <span class="comment">#分别给三才赋值五行</span></span><br><span class="line">x4,y4,z4 = list4[x1],list4[y1],list4[z1] <span class="comment">#分别给三才赋值方位</span></span><br><span class="line"><span class="keyword">if</span> time3 == <span class="number">1</span>:</span><br><span class="line">   list12=list11</span><br><span class="line"><span class="keyword">elif</span> time3 == <span class="number">0</span>:</span><br><span class="line">   list12=[<span class="string">&#x27;朱雀&#x27;</span>,<span class="string">&#x27;勾陈&#x27;</span>,<span class="string">&#x27;白虎&#x27;</span>,<span class="string">&#x27;玄武&#x27;</span>,<span class="string">&#x27;腾蛇&#x27;</span>,<span class="string">&#x27;青龙&#x27;</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   list12=[x <span class="keyword">for</span> x <span class="keyword">in</span> list11 <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> element]+element <span class="comment">#先遍历列表8不属于整体的元素再加上整体中的元素生成新列表10</span></span><br><span class="line">x5,y5,z5 = list5[x1],list5[y1],list5[z1] <span class="comment">#分别给三才赋值六神</span></span><br><span class="line">x6,y6,z6 = list12[x1],list12[y1],list12[z1] <span class="comment">#分别给三才赋值活六神</span></span><br><span class="line">number1,number2,number3 = dict2.get(x3),dict2.get(y3),dict2.get(z3) <span class="comment">#调用字典将五行与列表数字对应</span></span><br><span class="line">list13,list14,list15=<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number1&#125;</span>&#x27;</span>],<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number2&#125;</span>&#x27;</span>],<span class="built_in">globals</span>()[<span class="string">f&#x27;list<span class="subst">&#123;number3&#125;</span>&#x27;</span>] <span class="comment">#使用globals()作用于全局区别于locals()只能在一个函数局部内返回变量，生成三才对应的十二长生列表</span></span><br><span class="line">x7,y7,z7 =list13[time2-<span class="number">1</span>],list14[time2-<span class="number">1</span>],list15[time2-<span class="number">1</span>]</span><br><span class="line">time_len = <span class="built_in">len</span>(<span class="built_in">str</span>(time))</span><br><span class="line"><span class="keyword">if</span> time_len == <span class="number">1</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;时间&#x27;</span>,<span class="string">&#x27;&#x27;</span>,time,<span class="string">&#x27;  &#x27;</span>,time1)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;时间&#x27;</span>,<span class="string">&#x27;&#x27;</span>,time,<span class="string">&#x27; &#x27;</span>,time1)</span><br><span class="line"><span class="built_in">print</span>(x2,y2,z2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>,x3,<span class="string">&#x27; &#x27;</span>,y3,<span class="string">&#x27; &#x27;</span>,z3)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_xyz</span>(<span class="params">x,y,z</span>): <span class="comment">#封装成函数</span></span><br><span class="line">   x_len,y_len,z_len = <span class="built_in">len</span>(x),<span class="built_in">len</span>(y),<span class="built_in">len</span>(z)</span><br><span class="line">   <span class="keyword">if</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27; &#x27;</span>, y, <span class="string">&#x27; &#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27; &#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">2</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27;&#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">2</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27;&#x27;</span>, y, z)</span><br><span class="line">   <span class="keyword">elif</span> x_len == <span class="number">1</span> <span class="keyword">and</span> y_len == <span class="number">1</span> <span class="keyword">and</span> z_len == <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>, x, <span class="string">&#x27; &#x27;</span>, y, <span class="string">&#x27;&#x27;</span>, z)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">print</span>(x, y, z)</span><br><span class="line">print_xyz(x4,y4,z4) <span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">print</span>(x5,y5,z5)</span><br><span class="line"><span class="built_in">print</span>(x6,y6,z6)</span><br><span class="line">print_xyz(x7,y7,z7) <span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;按下Enter退出&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>术数</category>
      </categories>
      <tags>
        <tag>小六壬</tag>
        <tag>起课器</tag>
      </tags>
  </entry>
  <entry>
    <title>在butterfly主题添加一个副标题，并能够输出自定义的随机语录</title>
    <url>/2025/08/30/%E5%9C%A8butterfly%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%89%AF%E6%A0%87%E9%A2%98%EF%BC%8C%E5%B9%B6%E8%83%BD%E5%A4%9F%E8%BE%93%E5%87%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%AD%E5%BD%95/</url>
    <content><![CDATA[<h1>在butterfly主题添加一个副标题，并能够输出自定义的随机语录</h1>
<p>目前已经有许多在主题中接入一言来实现输出随机语录，但是对于自定义语录库的教程，暂未看到能够明了的讲清楚如何实现这一功能的</p>
<p>通过参考<a href="https://fanyiming.life/?p=128">Butterfly主题首页副标题自定义随机句子 – Eamon’s Blog</a>和deepseek完成了此功能</p>
<h2 id="注意在所有操作前都要确保备份"># 注意在所有操作前都要确保备份</h2>
<h2 id="1-创建语录库">1.创建语录库</h2>
<p>在博客的根目录下的source下(注意不是主题下的source)创建subtitle.json，在里面放句子</p>
<p>格式如下：</p>
<p>[“争知我，倚阑杆处，正恁凝愁！”,</p>
<p>“衣懒换，酒难赊。可怜此夕看梅花。”,</p>
<p>“为伊判作梦中人，索向画图清夜唤真真。”</p>
<p>]</p>
<h2 id="2-修改pug文件">2.修改pug文件</h2>
<p>在主题的文件夹下找到layout\includes\thrid-party\subtitle.pug</p>
<p>划到最下面会有一个case source开头的代码下面有多个when开头的分支和default开头的分支</p>
<p>将default及以下的代码替换为如下的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default</span><br><span class="line">  script.</span><br><span class="line">    // 获取默认内容作为后备</span><br><span class="line">    var defaultQuote = !&#123;JSON.stringify(subContent[0] || &#x27;&#x27;)&#125;;</span><br><span class="line">    // 页面加载完成后执行</span><br><span class="line">    document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123;</span><br><span class="line">      // 尝试从 subtitle.json 获取内容</span><br><span class="line">      fetch(&#x27;/subtitle.json&#x27;)</span><br><span class="line">        .then(response =&gt; &#123;</span><br><span class="line">          if (!response.ok) &#123;</span><br><span class="line">            throw new Error(&#x27;网络响应不正常&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          return response.json();</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(quotes =&gt; &#123;</span><br><span class="line">          // 确保 quotes 是数组且有内容</span><br><span class="line">          if (Array.isArray(quotes) &amp;&amp; quotes.length &gt; 0) &#123;</span><br><span class="line">            // 随机选择一条语录</span><br><span class="line">            var randomIndex = Math.floor(Math.random() * quotes.length);</span><br><span class="line">            displayQuote(quotes[randomIndex]);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // 如果 quotes 无效，使用默认内容</span><br><span class="line">            displayQuote(defaultQuote);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(error =&gt; &#123;</span><br><span class="line">          console.error(&#x27;加载自定义语录失败:&#x27;, error);</span><br><span class="line">          // 出错时使用默认内容</span><br><span class="line">          displayQuote(defaultQuote);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 显示语录的函数</span><br><span class="line">    function displayQuote(quote) &#123;</span><br><span class="line">      var subtitleElement = document.getElementById(&quot;subtitle&quot;);</span><br><span class="line">      if (subtitleElement) &#123;</span><br><span class="line">        subtitleElement.innerHTML = quote;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p># 注意，deepseek提示这段代码需要与上面的when语句对齐，至于没有对齐是否能完成此功能，未进行测试</p>
<h2 id="3-配置博客的配置文件">3.配置博客的配置文件</h2>
<p>在博客的根目录下打开_config.yml文件，查找</p>
<p>subtitle:<br>
enable: true</p>
<p>确保enable后的是true开启</p>
<h2 id="4-关于打字机效果">4.关于打字机效果</h2>
<p>在enable下面会有effect，后面也为true则为开启</p>
<p>但是实际实现中共没有能做到这个效果，在浏览器控制台中会有报错</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>副标题</tag>
        <tag>语录</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法8</title>
    <url>/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%958/</url>
    <content><![CDATA[<h2 id="8-堆">8.堆</h2>
<h3 id="1-堆">1.堆</h3>
<ul>
<li><strong>堆</strong> （heap）是一种满足特定条件的<strong>完全二叉树</strong>
<ul>
<li><strong>小顶堆</strong> （min heap）：任意节点的值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span> 其子节点的值。</li>
<li><strong>大顶堆</strong> （max heap）：任意节点的值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span> 其子节点的值。</li>
</ul>
</li>
</ul>
<pre><code class="highlight mermaid">flowchart TB
	subgraph 大顶堆
	direction TB
	9&#x27;[9] --&gt; 8&#x27;[8]
	9&#x27; --&gt; 6&#x27;&#x27;&#x27;[6]
	8&#x27; --&gt; 6&#x27;&#x27;&#x27;&#x27;[6]
	6&#x27;&#x27;&#x27;&#x27; --&gt; 1&#x27;[1]
	6&#x27;&#x27;&#x27;&#x27; --&gt; 4&#x27;[4]
	8&#x27; --&gt; 7&#x27;[7]
	7&#x27; --&gt; 3&#x27;[3]
	7&#x27; --&gt; 6&#x27;&#x27;&#x27;&#x27;&#x27;[6]
	6&#x27;&#x27;&#x27; --&gt; 5&#x27;[5]
    6&#x27;&#x27;&#x27; --&gt; 2&#x27;&#x27;[2]
    5&#x27; --&gt; 2&#x27;&#x27;&#x27;[2]
	end

	subgraph 小顶堆
	direction TB
	1[1] --&gt; 3[3]
	1 --&gt; 2[2]
	3 --&gt; 6[6]
	6 --&gt; 8[8]
	6 --&gt; 7[7]
	3 --&gt; 4[4]
	4 --&gt; 9[9]
	4 --&gt; 6&#x27;&#x27;[6]
	2 --&gt; 2&#x27;[2]
	2 --&gt; 6&#x27;[6]
	2&#x27; --&gt; 5[5]	
	end</code></pre>
<ul>
<li>堆是完全二叉树的一个特例
<ul>
<li>最底层节点<strong>靠左填充</strong> ，<strong>其他层</strong> 的节点都被<strong>填满</strong> 。</li>
<li>我们将二叉树的<strong>根节点</strong> 称为<strong>堆顶</strong> ，将<strong>底层最靠右</strong> 的节点称为<strong>堆底</strong> 。</li>
<li>对于大顶堆（小顶堆），堆顶元素（根节点）的值是最大（最小）的。</li>
</ul>
</li>
</ul>
<h4 id="1-堆的常用操作">1.堆的常用操作</h4>
<ul>
<li>
<p>许多编程语言提供的是<strong>优先队列</strong> （priority queue），这是一种抽象的数据结构，定义为具有<strong>优先级排序</strong> 的队列。</p>
</li>
<li>
<p>堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列。从使用角度来看，可以将<strong>优先队列</strong> 和<strong>堆</strong> 看作<strong>等价</strong> 的数据结构</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>push()</td>
<td>元素入堆</td>
<td>𝑂(log 𝑛)</td>
</tr>
<tr>
<td>pop()</td>
<td>堆顶元素出堆</td>
<td>𝑂(log 𝑛)</td>
</tr>
<tr>
<td>peek()</td>
<td>访问堆顶元素（对于大 / 小顶堆分别为最大 / 小值）</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>size()</td>
<td>获取堆的元素数量</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断堆是否为空</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化小顶堆</span></span><br><span class="line">min_heap, flag = [], <span class="number">1</span></span><br><span class="line"><span class="comment"># 初始化大顶堆</span></span><br><span class="line">max_heap, flag = [], -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的 heapq 模块默认实现小顶堆</span></span><br><span class="line"><span class="comment"># 考虑将“元素取负”后再入堆，这样就可以将大小关系颠倒，从而实现大顶堆</span></span><br><span class="line"><span class="comment"># 在本示例中，flag = 1 时对应小顶堆，flag = -1 时对应大顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入堆</span></span><br><span class="line">heapq.heappush(max_heap, flag * <span class="number">1</span>)</span><br><span class="line">heapq.heappush(max_heap, flag * <span class="number">3</span>)</span><br><span class="line">heapq.heappush(max_heap, flag * <span class="number">2</span>)</span><br><span class="line">heapq.heappush(max_heap, flag * <span class="number">5</span>)</span><br><span class="line">heapq.heappush(max_heap, flag * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取堆顶元素</span></span><br><span class="line">peek: <span class="built_in">int</span> = flag * max_heap[<span class="number">0</span>] <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出堆</span></span><br><span class="line"><span class="comment"># 出堆元素会形成一个从大到小的序列</span></span><br><span class="line">val = flag * heapq.heappop(max_heap) <span class="comment"># 5</span></span><br><span class="line">val = flag * heapq.heappop(max_heap) <span class="comment"># 4</span></span><br><span class="line">val = flag * heapq.heappop(max_heap) <span class="comment"># 3</span></span><br><span class="line">val = flag * heapq.heappop(max_heap) <span class="comment"># 2</span></span><br><span class="line">val = flag * heapq.heappop(max_heap) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取堆大小</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(max_heap)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断堆是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="keyword">not</span> max_heap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入列表并建堆</span></span><br><span class="line">min_heap: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">heapq.heapify(min_heap)</span><br></pre></td></tr></table></figure>
<h4 id="2-堆的实现">2.堆的实现</h4>
<p># 若要将大顶堆转换为小顶堆，只需将大小逻辑判断进行逆转（即将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span>替换为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span></p>
<h5 id="1-堆的存储与表示">1.堆的存储与表示</h5>
<ul>
<li>由于完全二叉树适合用数组来表示，所以采用数组来存储堆</li>
<li>当使用数组表示二叉树时，<strong>元素代表节点值，索引代表节点在二叉树中的位置。节点指针通过索引映射公式来实现</strong> 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">left</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 获取左子节点的索引&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">right</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 获取右子节点的索引&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 获取父节点的索引&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) // <span class="number">2</span> <span class="comment"># 向下整除</span></span><br></pre></td></tr></table></figure>
<p># 将映射公式封装成函数</p>
<h5 id="2-访问堆顶元素">2.访问堆顶元素</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 访问堆顶元素&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.max_heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h5 id="3-元素入堆">3.元素入堆</h5>
<ul>
<li>
<p>先将元素加入至堆底，但是加入的元素可能会破坏堆成立的条件，所以要修复插入节点到根节点的路径上的各个节点，这个操作被称为<strong>堆化</strong></p>
</li>
<li>
<p>从入堆节点开始。从<strong>底部至顶部</strong> 执行堆化，<strong>比较插入节点与其父节点的值</strong> ，如果<strong>插入节点更大</strong> ，则将它们<strong>交换</strong> 。然后继续执行此操作，从底至顶修复堆中的各个节点，<strong>直至越过根节点或遇到无须交换的节点时</strong> 结束。</p>
</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 入堆
	direction TB
	9a[9] --&gt; 8a[8]
	9a --&gt; 6a[6]
	8a --&gt; 6b[6]
	6b --&gt; 1a[1]
	6b --&gt; 4a[4]
	8a --&gt; 7a[7]
	7a --&gt; 3a[3]
	7a --&gt; 6c[6]
	6a --&gt; 5a[5]
    6a --&gt; 2a[2]
    5a --&gt; 2b[2]
    5a --&gt; 7b[7]
	end

	subgraph 原堆
	direction TB
	9[9] --&gt; 8[8]
	9 --&gt; 6[6]
	8 --&gt; 6&#x27;[6]
	6&#x27; --&gt; 1[1]
	6&#x27; --&gt; 4[4]
	8 --&gt; 7[7]
	7 --&gt; 3[3]
	7 --&gt; 6&#x27;&#x27;[6]
	6 --&gt; 5[5]
    6 --&gt; 2[2]
    5 --&gt; 2&#x27;[2]
	end
	
	原堆 --&gt; 入堆</code></pre>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 比较
	direction TB
	9a[9] --&gt; 8a[8]
	9a --&gt; 6a[6]
	8a --&gt; 6b[6]
	6b --&gt; 1a[1]
	6b --&gt; 4a[4]
	8a --&gt; 7a[7]
	7a --&gt; 3a[3]
	7a --&gt; 6c[6]
	6a --&gt; 5a[5]
    6a --&gt; 2a[2]
    5a --&gt; 2b[2]
    5a --&gt; 7b[&quot;7
    (与父节点比较)&quot;]
	end

	subgraph 交换
	direction TB
	9[9] --&gt; 8[8]
	9 --&gt; 6[6]
	8 --&gt; 6&#x27;[6]
	6&#x27; --&gt; 1[1]
	6&#x27; --&gt; 4[4]
	8 --&gt; 7[7]
	7 --&gt; 3[3]
	7 --&gt; 6&#x27;&#x27;[6]
	6 --&gt; 7&#x27;[7]
    6 --&gt; 2[2]
    7&#x27; --&gt; 2&#x27;[2]
    subgraph 交换节点
    7&#x27; --&gt; 5[5]
    end
	end
	
	比较 --&gt; 交换
</code></pre>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 比较
	direction TB
	9a[9] --&gt; 8a[8]
	9a --&gt; 6a[6]
	8a --&gt; 6b[6]
	6b --&gt; 1a[1]
	6b --&gt; 4a[4]
	8a --&gt; 7a[7]
	7a --&gt; 3a[3]
	7a --&gt; 6c[6]
	6a --&gt; 7b[&quot;7
	(与父节点比较)&quot;]
    6a --&gt; 2a[2]
    7b --&gt; 2b[2]
    7b --&gt; 5a[5]
	end
	
	subgraph 交换
	direction TB
	9[9] --&gt; 8[8]
	9 --&gt; 7&#x27;[7]
	8 --&gt; 6&#x27;[6]
	6&#x27; --&gt; 1[1]
	6&#x27; --&gt; 4[4]
	8 --&gt; 7[7]
	7 --&gt; 3[3]
	7 --&gt; 6&#x27;&#x27;[6]
	subgraph 交换节点
	7&#x27; --&gt; 6[6]
	end
    6 --&gt; 2[2]
    6 --&gt; 5[5]
    7&#x27; --&gt; 2&#x27;[2]
	end
	
	比较 --&gt; 交换</code></pre>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 比较
	direction TB
	9a[9] --&gt; 8a[8]
	9a --&gt; 7b[&quot;7
	(与父节点比较)&quot;]
	8a --&gt; 6b[6]
	6b --&gt; 1a[1]
	6b --&gt; 4a[4]
	8a --&gt; 7a[7]
	7a --&gt; 3a[3]
	7a --&gt; 6c[6]
	7b --&gt; 6a[6]
    6a --&gt; 2a[2]
    6a --&gt; 5a[5]
    7b --&gt; 2b[2]
	end
	
	subgraph 不执行交换
	direction TB
	9[9] --&gt; 8[8]
	9 --&gt; 7&#x27;[7]
	8 --&gt; 6&#x27;[6]
	6&#x27; --&gt; 1[1]
	6&#x27; --&gt; 4[4]
	8 --&gt; 7[7]
	7 --&gt; 3[3]
	7 --&gt; 6&#x27;&#x27;[6]
	7&#x27; --&gt; 6[6]
    6 --&gt; 2[2]
    6 --&gt; 5[5]
    7&#x27; --&gt; 2&#x27;[2]
	end
	
	比较 --&gt; 不执行交换</code></pre>
<p># 设节点总数为 𝑛 ，则树的高度为 𝑂(log 𝑛) 。由此可知，堆化操作的循环轮数最多为 𝑂(log 𝑛) ，元素入堆操作的时间复杂度为𝑂(log 𝑛)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 元素入堆&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 添加节点</span></span><br><span class="line">    <span class="variable language_">self</span>.max_heap.append(val)</span><br><span class="line">    <span class="comment"># 从底至顶堆化</span></span><br><span class="line">    <span class="variable language_">self</span>.sift_up(<span class="variable language_">self</span>.size() - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sift_up</span>(<span class="params">self, i: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 从节点 i 开始，从底至顶堆化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 获取节点 i 的父节点</span></span><br><span class="line">        p = <span class="variable language_">self</span>.parent(i)</span><br><span class="line">        <span class="comment"># 当“越过根节点”或“节点无须修复”时，结束堆化</span></span><br><span class="line">        <span class="keyword">if</span> p &lt; <span class="number">0</span> <span class="keyword">or</span> <span class="variable language_">self</span>.max_heap[i] &lt;= <span class="variable language_">self</span>.max_heap[p]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 交换两节点</span></span><br><span class="line">        <span class="variable language_">self</span>.swap(i, p)</span><br><span class="line">        <span class="comment"># 循环向上堆化</span></span><br><span class="line">        i = p</span><br></pre></td></tr></table></figure>
<h5 id="4-堆顶元素出堆">4.堆顶元素出堆</h5>
<ul>
<li>堆顶元素是二叉树的根节点，即列表首元素。如果直接从列表中删除首元素，那么二叉树中所有节点的索引都会发生变化，这将使得后续使用堆化进行修复变得困难。为了尽量减少元素索引的变动，所以采用以下操作步骤。
<ul>
<li><strong>交换堆顶元素与堆底元素</strong> （交换根节点与最右叶节点）。</li>
<li>交换完成后，将堆底从列表中删除（注意，由于已经交换，因此实际上删除的是原来的堆顶元素）。</li>
<li>从根节点开始，<strong>从顶至底执行堆化</strong>。</li>
</ul>
</li>
</ul>
<pre><code class="highlight mermaid">flowchart	LR
	subgraph 交换堆顶堆底元素
	5a[5] --&gt; 8a[8]
	5a --&gt; 7b[7]
	8a --&gt; 6b[6]
	6b --&gt; 1a[1]
	6b --&gt; 4a[4]
	8a --&gt; 7a[7]
	7a --&gt; 3a[3]
	7a --&gt; 6c[6]
	7b --&gt; 6a[6]
    6a --&gt; 2a[2]
    6a --&gt; 9a[9]
    7b --&gt; 2b[2]
	end
	style 5a fill:#0ff
	style 9a fill:#0ff
	
	subgraph 原堆
	9[9] --&gt; 8[8]
	9 --&gt; 7&#x27;[7]
	8 --&gt; 6&#x27;[6]
	6&#x27; --&gt; 1[1]
	6&#x27; --&gt; 4[4]
	8 --&gt; 7[7]
	7 --&gt; 3[3]
	7 --&gt; 6&#x27;&#x27;[6]
	7&#x27; --&gt; 6[6]
    6 --&gt; 2[2]
    6 --&gt; 5[5]
    7&#x27; --&gt; 2&#x27;[2]
    end
    style 9 fill:#0ff
    
    原堆 --&gt; 交换堆顶堆底元素</code></pre>
<pre><code class="highlight mermaid">flowchart	LR
	subgraph 删除当前堆底元素
	5a[5] --&gt; 8a[8]
	5a --&gt; 7b[7]
	8a --&gt; 6b[6]
	6b --&gt; 1a[1]
	6b --&gt; 4a[4]
	8a --&gt; 7a[7]
	7a --&gt; 3a[3]
	7a --&gt; 6c[6]
	7b --&gt; 6a[6]
    6a --&gt; 2a[2]
    7b --&gt; 2b[2]
	end
	style 5a fill:#0ff
	
	subgraph 堆化
	subgraph A[与子节点进行比较，与较大的节点交换]
	5&#x27;[5] --&gt; 8&#x27;[8]
	5&#x27; --&gt; 7&#x27;&#x27;[7]
	end
	8&#x27; --&gt; 6&#x27;&#x27;[6]
	6&#x27;&#x27; --&gt; 1&#x27;[1]
	6&#x27;&#x27; --&gt; 4[4]
	8&#x27; --&gt; 7&#x27;[7]
	7&#x27; --&gt; 3&#x27;[3]
	7&#x27; --&gt; 6&#x27;&#x27;&#x27;[6]
	7&#x27;&#x27; --&gt; 6&#x27;[6]
    6&#x27; --&gt; 2&#x27;[2]
    7&#x27;&#x27; --&gt; 2&#x27;&#x27;[2]
	end
	style 5&#x27; fill:#0ff
	
	删除当前堆底元素 --&gt; 堆化</code></pre>
<pre><code class="highlight mermaid">flowchart	LR
	subgraph 交换节点
	subgraph 交换5和8
	8a[8] --&gt; 5a[5]
	end
	8a --&gt; 7b[7]
	5a --&gt; 6b[6]
	6b --&gt; 1a[1]
	6b --&gt; 4a[4]
	5a --&gt; 7a[7]
	7a --&gt; 3a[3]
	7a --&gt; 6c[6]
	7b --&gt; 6a[6]
    6a --&gt; 2a[2]
    7b --&gt; 2b[2]
	end
	style 5a fill:#0ff
	
	subgraph 堆化
	8&#x27;[8] --&gt; 5&#x27;[5]
	8&#x27; --&gt; 7&#x27;&#x27;[7]
	subgraph A[与子节点进行比较，与较大的节点交换]
	5&#x27; --&gt; 6&#x27;&#x27;[6]
	5&#x27; --&gt; 7&#x27;[7]
	end
	6&#x27;&#x27; --&gt; 1&#x27;[1]
	6&#x27;&#x27; --&gt; 4&#x27;[4]
	7&#x27; --&gt; 3&#x27;[3]
	7&#x27; --&gt; 6&#x27;&#x27;&#x27;[6]
	7&#x27;&#x27; --&gt; 6&#x27;[6]
	7&#x27;&#x27; --&gt; 2&#x27;&#x27;[2]
    6&#x27; --&gt; 2&#x27;[2]
    
	end
	style 5&#x27; fill:#0ff
	
	交换节点 --&gt; 堆化</code></pre>
<pre><code class="highlight mermaid">flowchart LR	
	subgraph 交换节点
	8&#x27;[8] --&gt; 7&#x27;[7]
	8&#x27; --&gt; 7&#x27;&#x27;[7]
	7&#x27; --&gt; 6&#x27;&#x27;[6]
	subgraph 交换5和7
	7&#x27; --&gt; 5&#x27;[5]
	end
	6&#x27;&#x27; --&gt; 1&#x27;[1]
	6&#x27;&#x27; --&gt; 4&#x27;[4]
	5&#x27; --&gt; 3&#x27;[3]
	5&#x27; --&gt; 6&#x27;&#x27;&#x27;[6]
	7&#x27;&#x27; --&gt; 6&#x27;[6]
	7&#x27;&#x27; --&gt; 2&#x27;&#x27;[2]
    6&#x27; --&gt; 2&#x27;[2]
	end
	style 5&#x27; fill:#0ff
	
	subgraph 堆化
	8a[8] --&gt; 7a[7]
	8a --&gt; 7b[7]
	7a --&gt; 6b[6]
	7a --&gt; 5a[5]
	6b --&gt; 1a[1]
	6b --&gt; 4a[4]
	subgraph A[与子节点进行比较，与较大的节点交换]
	5a --&gt; 3a[3]
	5a --&gt; 6c[6]
	end
	7b --&gt; 2b[2]
	7b --&gt; 6a[6]
    6a --&gt; 2a[2]
	end
	style 5a fill:#0ff
	
	交换节点 --&gt; 堆化</code></pre>
<pre><code class="highlight mermaid">flowchart LR	
	subgraph 交换节点
	8a[8] --&gt; 7a[7]
	8a --&gt; 7b[7]
	7a --&gt; 6b[6]
	7a --&gt; 6c[6]
	6b --&gt; 1a[1]
	6b --&gt; 4a[4]
	6c --&gt; 3a[3]
	subgraph 交换5和6
	6c --&gt; 5a[5]
	end
	7b --&gt; 6a[6]
	7b --&gt; 2b[2]
    6a --&gt; 2a[2]
	end
	style 5a fill:#0ff
	
	subgraph 完成出堆
	8&#x27;[8] --&gt; 7&#x27;[7]
	8&#x27; --&gt; 7&#x27;&#x27;[7]
	7&#x27; --&gt; 6&#x27;&#x27;[6]
	7&#x27; --&gt; 6&#x27;&#x27;&#x27;[6]
	6&#x27;&#x27; --&gt; 1&#x27;[1]
	6&#x27;&#x27; --&gt; 4&#x27;[4]
	6&#x27;&#x27;&#x27; --&gt; 3&#x27;[3]
	6&#x27;&#x27;&#x27; --&gt; 5&#x27;[5]
	7&#x27;&#x27; --&gt; 6&#x27;[6]
	7&#x27;&#x27; --&gt; 2&#x27;&#x27;[2]
    6&#x27; --&gt; 2&#x27;[2]
	end
	style 5&#x27; fill:#0ff
	
	交换节点 --&gt; 完成出堆</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 元素出堆&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 判空处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&quot; 堆为空&quot;</span>)</span><br><span class="line">    <span class="comment"># 交换根节点与最右叶节点（交换首元素与尾元素）</span></span><br><span class="line">    <span class="variable language_">self</span>.swap(<span class="number">0</span>, <span class="variable language_">self</span>.size() - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 删除节点</span></span><br><span class="line">    val = <span class="variable language_">self</span>.max_heap.pop()</span><br><span class="line">    <span class="comment"># 从顶至底堆化</span></span><br><span class="line">    <span class="variable language_">self</span>.sift_down(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 返回堆顶元素</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sift_down</span>(<span class="params">self, i: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 从节点 i 开始，从顶至底堆化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        l, r, ma = <span class="variable language_">self</span>.left(i), <span class="variable language_">self</span>.right(i), i</span><br><span class="line">        <span class="keyword">if</span> l &lt; <span class="variable language_">self</span>.size() <span class="keyword">and</span> <span class="variable language_">self</span>.max_heap[l] &gt; <span class="variable language_">self</span>.max_heap[ma]:</span><br><span class="line">            ma = l</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="variable language_">self</span>.size() <span class="keyword">and</span> <span class="variable language_">self</span>.max_heap[r] &gt; <span class="variable language_">self</span>.max_heap[ma]:</span><br><span class="line">            ma = r</span><br><span class="line">        <span class="comment"># 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ma == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 交换两节点</span></span><br><span class="line">        <span class="variable language_">self</span>.swap(i, ma)</span><br><span class="line">        <span class="comment"># 循环向下堆化</span></span><br><span class="line">        i = ma</span><br></pre></td></tr></table></figure>
<p># 与元素入堆操作相似，堆顶元素出堆操作的时间复杂度也为 𝑂(log 𝑛)</p>
<h4 id="3-堆的常见应用">3.堆的常见应用</h4>
<ul>
<li><strong>优先队列</strong> ：堆通常作为实现优先队列的首选数据结构，其入队和出队操作的时间复杂度均为 𝑂(log 𝑛)，而建堆操作为 𝑂(𝑛) ，这些操作都非常高效。</li>
<li><strong>堆排序</strong> ：给定一组数据，可以用它们建立一个堆，然后不断地执行元素出堆操作，从而<strong>得到有序数据</strong> 。然而，通常会使用一种更优雅的方式实现堆排序</li>
<li><strong>获取最大的𝑘个元素</strong> ：一个经典的算法问题，同时也是一种典型应用，例如选择热度前 10 的新闻作为微博热搜，选取销量前 10 的商品等。</li>
</ul>
<h3 id="2-建堆操作">2.建堆操作</h3>
<ul>
<li>当需要用一个列表中的元素来构建一个堆的时候，这个过程被称为<strong>建堆操作</strong></li>
</ul>
<h4 id="1-借助入堆操作实现">1.借助入堆操作实现</h4>
<ul>
<li>
<p>首先创建一个<strong>空堆</strong> ，然后<strong>遍历列表</strong> ，依次对每个元素执行<strong>入堆操作</strong> ，即<strong>先将元素添加至堆的尾部</strong> ，再对该元素执行<strong>从底至顶堆化</strong> 。</p>
</li>
<li>
<p>每当一个元素入堆，堆的长度就加一。由于节点是从顶到底依次被添加进二叉树的，因此堆是<strong>自上而下</strong> 构建的。</p>
</li>
<li>
<p>设元素数量为 𝑛 ，每个元素的入堆操作使用 𝑂(log 𝑛) 时间，因此该建堆方法的时间复杂度为 𝑂(𝑛 log 𝑛)。</p>
</li>
</ul>
<h4 id="2-通过遍历堆化实现">2.通过遍历堆化实现</h4>
<ul>
<li>实际上，可以实现一种更为高效的建堆方法，共分为两步。
<ul>
<li>将列表所有元素原封不动地添加到堆中，此时堆的性质尚未得到满足。</li>
<li>倒序遍历堆（层序遍历的倒序），依次对每个非叶节点执行<strong>从顶至底堆化</strong> 。</li>
</ul>
</li>
<li><strong>每当堆化一个节点后，以该节点为根节点的子树就形成一个合法的子堆</strong>。而由于是倒序遍历，因此堆是<strong>自下而上</strong> 构建的。</li>
<li>之所以选择倒序遍历，是因为这样能够保证当前节点之下的子树已经是合法的子堆，这样堆化当前节点才是有效的。</li>
<li><strong>由于叶节点没有子节点，因此它们天然就是合法的子堆，无须堆化</strong> 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 构造方法，根据输入列表建堆&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将列表元素原封不动添加进堆</span></span><br><span class="line">    <span class="variable language_">self</span>.max_heap = nums</span><br><span class="line">    <span class="comment"># 堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.parent(<span class="variable language_">self</span>.size() - <span class="number">1</span>), -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="variable language_">self</span>.sift_down(i)</span><br></pre></td></tr></table></figure>
<h4 id="3-复杂度分析">3.复杂度分析</h4>
<ul>
<li>
<p>计算通过遍历堆化实现的建堆操作的时间复杂度</p>
<ul>
<li>假设完全二叉树的节点数量为 𝑛 ，则叶节点数量为 (𝑛 + 1)/2 ，其中 / 为向下整除。因此需要堆化的节点数量为 (𝑛 − 1)/2 。</li>
<li>在从顶至底堆化的过程中，每个节点最多堆化到叶节点，因此最大迭代次数为二叉树高度 log 𝑛 。</li>
</ul>
</li>
<li>
<p>将两者相乘，可得到建堆过程的时间复杂度为 𝑂(𝑛 log 𝑛) 。<strong>但这个估算结果并不准确，因为没有考虑到二叉树底层节点数量远多于顶层节点的性质</strong>。</p>
</li>
<li>
<p>通过验证完美二叉树来获得其时间复杂度</p>
<ul>
<li>从顶至底堆化的最大迭代次数等于其节点到叶节点的距离，即节点的高度</li>
<li>可以对各层的<strong>节点数量 × 节点高度</strong> 求和，<strong>得到所有节点的堆化迭代次数的总和</strong>。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mn>0</mn></msup><mi>h</mi><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(ℎ) = 2^0ℎ + 2^1 (ℎ − 1) + 2^2 (ℎ − 2) + ⋯ + 2^{(ℎ−1)} × 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9713em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
<li>再错位相加法
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>T</mi><mo>−</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">2T-T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑇</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><msup><mn>2</mn><mn>0</mn></msup><mi>h</mi><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">𝑇(ℎ) = −2^0ℎ + 2^1 + 2^2 + ⋯ + 2^{ℎ−1} + 2^ℎ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>得到的是一个等比数列</li>
<li>直接使用求和公式得到时间复杂度
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mfrac><mrow><mn>1</mn><mo>−</mo><msup><mn>2</mn><mi>h</mi></msup></mrow><mrow><mn>1</mn><mo>−</mo><mn>2</mn></mrow></mfrac><mo>−</mo><mi>h</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mi>h</mi><mo>−</mo><mn>2</mn><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>h</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(h)=2\frac{1-2^h}{1-2}-h=2^{h+1}-h-2=O(2^h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4463em;vertical-align:-0.4033em;"></span><span class="mord">2</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0429em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.927em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>高度为 ℎ 的完美二叉树的节点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">𝑛 = 2^{ℎ+1} − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，易得复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>h</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>𝑂</mi><mo stretchy="false">(</mo><mi>𝑛</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(2^ℎ ) = 𝑂(𝑛)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。以上推算表明，<strong>输入列表并建堆的时间复杂度为</strong> 𝑂(𝑛) <strong>，非常高效</strong>。</li>
</ul>
</li>
</ul>
<h3 id="3-Top-k问题">3.Top-k问题</h3>
<ul>
<li>当给定一个长度为n的无序数组，要求返回最大的k个元素</li>
</ul>
<h4 id="1-遍历选择">1.遍历选择</h4>
<ul>
<li>直接遍历，在每一轮提取出第1，2，3，……，k大的元素</li>
<li>但是这种方法时间复杂度为 𝑂(𝑛𝑘) 。只适用于 𝑘<strong>远小于</strong> 𝑛 的情况，因为当 𝑘 与 𝑛 比较接近时，其时间复杂度趋向于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mo stretchy="false">(</mo><msup><mi>𝑛</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝑂(𝑛^2 )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，非常耗时。</li>
</ul>
<p># 当 𝑘 = 𝑛 时，就是要得到完整的有序序列，此时等价于<strong>选择排序</strong> 算法</p>
<h4 id="2-排序">2.排序</h4>
<ul>
<li>可以先对数组进行排序，再返回最右边的 𝑘 个元素，时间复杂度为 𝑂(𝑛 log 𝑛) 。</li>
</ul>
<h4 id="3-堆">3.堆</h4>
<ul>
<li>
<p>初始化一个<strong>小顶堆</strong> ，即其堆顶元素最小。</p>
</li>
<li>
<p>先将数组的前 𝑘 个元素依次入堆。</p>
</li>
<li>
<p>从第 𝑘 + 1 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。</p>
</li>
<li>
<p>遍历完成后，堆中保存的就是最大的 𝑘 个元素。</p>
</li>
<li>
<p>例：给定数组：1，7，6，3，2</p>
</li>
<li>
<p>k=3</p>
</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	subgraph A[将前k个元素入堆]
	1[1]
	end
	
	subgraph B[将前k个元素入堆]
	1a[1] --&gt; 7a[7]
	end
	
	subgraph C[将前k个元素入堆]
	1&#x27;[1] --&gt; 7&#x27;[7]
	1&#x27; --&gt; 6&#x27;[6]
	end
	
	A --&gt; B --&gt; C</code></pre>
<pre><code class="highlight mermaid">flowchart LR
	subgraph A[判断当前元素即第四个元素大于堆顶元素]
	1[1] --&gt; 7[7]
	1 --&gt; 6&#x27;[6]
	end
	
	subgraph B[将堆顶元素出堆]
	6a[6] --&gt; 7a[7]
	end
	
	subgraph C[将当前元素入堆]
	3&#x27;[3] --&gt; 7&#x27;[7]
	3&#x27; --&gt; 6&#x27;&#x27;[6]
	end
	
	A --&gt; B --&gt; C</code></pre>
<pre><code class="highlight mermaid">flowchart LR
	subgraph A[判断当前元素即第五个元素小于堆顶元素，则跳过]
	3&#x27;[3] --&gt; 7&#x27;[7]
	3&#x27; --&gt; 6&#x27;&#x27;[6]
	end
	
	subgraph B[完成遍历，返回堆这个数组即可]
	3a[3] --&gt; 7[7]
	3a --&gt; 6a[6]
	end
	
	A --&gt; B</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">top_k_heap</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 基于堆查找数组中最大的 k 个元素&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化小顶堆</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="comment"># 将数组的前 k 个元素入堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        heapq.heappush(heap, nums[i])</span><br><span class="line">    <span class="comment"># 从第 k+1 个元素开始，保持堆的长度为 k</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line">            heapq.heappush(heap, nums[i])</span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure>
<ul>
<li>总共执行了 𝑛 轮入堆和出堆，堆的最大长度为 𝑘 ，因此时间复杂度为 𝑂(𝑛 log 𝑘) 。该方法的效率很高，当𝑘 较小时，时间复杂度趋向 𝑂(𝑛) ；当 𝑘 较大时，时间复杂度不会超过 𝑂(𝑛 log 𝑛) 。</li>
<li>另外，该方法适用于动态数据流的使用场景。在不断加入数据时，可以持续维护堆内的元素，从而实现最大的 𝑘 个元素的动态更新。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法1-7</title>
    <url>/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951-7/</url>
    <content><![CDATA[<h1>数据结构与算法</h1>
<h2 id="1-算法">1.算法</h2>
<h3 id="1-算法定义">1.算法定义</h3>
<ul>
<li><strong>算法</strong> （algorithm）是在有限时间内解决特定问题的一组指令或操作步骤</li>
</ul>
<h3 id="2-特性">2.特性</h3>
<ul>
<li>问题是明确的，包含清晰的输入和输出定义。</li>
<li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li>
<li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li>
</ul>
<h3 id="3-与数据结构的关系">3.与数据结构的关系</h3>
<ul>
<li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li>
<li>算法为数据结构注入生命力。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li>
<li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li>
</ul>
<p># 常将数据结构与算法简称为<strong>算法</strong></p>
<h2 id="2-复杂度分析">2.复杂度分析</h2>
<h3 id="1-算法效率评估">1.算法效率评估</h3>
<h4 id="1-算法设计目标">1.算法设计目标</h4>
<h5 id="1-找到问题解法">1.找到问题解法</h5>
<ul>
<li>算法需要在规定的输入范围内可靠地求得问题的正确解。</li>
</ul>
<h5 id="2-寻求最优解法">2.寻求最优解法</h5>
<ul>
<li>同一个问题可能存在多种解法，找到尽可能高效的算法</li>
</ul>
<h4 id="2-算法评估指标">2.算法评估指标</h4>
<h5 id="1-时间效率">1.时间效率</h5>
<ul>
<li>算法运行时间的长短。</li>
</ul>
<h5 id="2-空间效率">2.空间效率</h5>
<ul>
<li>算法占用内存空间的大小</li>
</ul>
<h4 id="3-效率评估方法">3.效率评估方法</h4>
<h5 id="1-实际测试">1.实际测试</h5>
<ul>
<li>在同一台计算机上运行两种不同的算法，监控它们运行的时间和占用的空间</li>
</ul>
<p># 但是存在两种问题：</p>
<p>1.测试环境：在不同的硬件上的测试可能会有不同的结果</p>
<p>2.耗费资源：有时候输入数据量的变化也可能会导致效率不同，而要测试所有规模的数据量会浪费大量计算资源</p>
<h5 id="2-理论估计">2.理论估计</h5>
<ul>
<li>
<p>由于实际测试具有较大的局限性，因此可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为<strong>渐近复杂度分析</strong> （asymptotic complexity analysis），简称<strong>复杂度分析</strong> 。</p>
</li>
<li>
<p>它描述了随着输入数据大小的增加，算法执行所需时间（时间复杂度（time complexity））和空间（空间复杂度（space complexity））的增长趋势</p>
</li>
</ul>
<h3 id="2-迭代与递归">2.迭代与递归</h3>
<h4 id="1-迭代">1.迭代</h4>
<ul>
<li><strong>迭代</strong> （iteration）是一种重复执行某个任务的控制结构。<strong>自下而上</strong> 解决问题</li>
</ul>
<h5 id="1-for循环">1.for循环</h5>
<ul>
<li>适用于预先知道迭代次数时</li>
</ul>
<h5 id="2-while循环">2.while循环</h5>
<ul>
<li>相比于for循环可以自由设计条件变量和更新步骤</li>
</ul>
<p># for循环就是加了语法糖的while循环</p>
<p># <strong>语法糖</strong>：更加便捷的写法</p>
<h5 id="3-嵌套循环">3.嵌套循环</h5>
<ul>
<li>在一个循环结构内嵌套另一个循环结构</li>
</ul>
<h4 id="2-递归">2.递归</h4>
<ul>
<li><strong>递归</strong>（recursion）是一种算法策略，通过函数调用自身来解决问题。<strong>自上而下</strong> 解决问题，将问题分解为子问题，与原问题具有相同的形式，再将子问题分解为更小的子问题。它主要包含两个阶段：
<ul>
<li><strong>递</strong> ：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到<strong>终止条件</strong> 。</li>
<li><strong>归</strong> ：触发<strong>终止条件</strong> 后，程序从最深层的递归函数开始<strong>逐层返回</strong> ，汇聚每一层的结果</li>
</ul>
</li>
</ul>
<p># 例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 终止条件</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 递：递归调用</span></span><br><span class="line">	<span class="type">int</span> res = recur(n - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 归：返回结果</span></span><br><span class="line">	<span class="keyword">return</span> n + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于求累加的函数</p>
<p># 例如求1到5的累加，先调用recur（5），由于n=5，不等于1，所以先暂停计算recur（5）继续调用这个函数recur（4），一直到recur（1）（在recur（1）之前都是<strong>递</strong> 的过程），然后<strong>满足终止条件</strong> 直接返回1，res=1再返回n+res的值=2，计算recur（2）的值返回3，再依次返回到recur（5）得出最终结果</p>
<h5 id="1-调用栈">1.调用栈</h5>
<ul>
<li>
<p>递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。</p>
<ul>
<li>
<p>上下文数据都存储在<strong>栈帧空间</strong> 的内存区域中，因此<strong>递归比迭代更耗费内存空间</strong></p>
</li>
<li>
<p>递归调用函数会产生额外的开销。<strong>因此递归通常比循环的时间效率更低</strong></p>
</li>
</ul>
</li>
<li>
<p>在上述的代码中，在到达recur（1）之前（<strong>触发终止条件之前</strong> ），前面有5-2共4个<strong>未返回的递归函数</strong> ，此时的<strong>递归深度为4</strong> ，通常编程语言允许的递归深度是有限的，过深的递归可能会导致栈溢出错误</p>
</li>
</ul>
<h5 id="2-尾递归">2.尾递归</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tailRecur</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> res)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="comment">// 终止条件</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span> res; <span class="comment">// 尾递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> tailRecur(n - <span class="number">1</span>, res + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 用这段代码求累加，1-5的值，n=5，这里的res设置为0，tailRecur（5，0）未达到终止条件，就会返回tailRecur（4，0+5），依次返回tailRecur（3，（0+5）+4），tailRecur（2，（（0+5）+4）+3），tailRecur（1，（（（0+5）+4）+3）+2），tailRecur（0，（（（0+5）+4）+3）+2）+1）至此到达终止条件，直接返回res的值也就是（（（0+5）+4）+3）+2）+1</p>
<ul>
<li>函数在返回前的<strong>最后一步才进行递归调用</strong> ，<strong>部分</strong> 编译器或解释器会将函数优化，使其在空间效率上与迭代相当，这种情况被称为<strong>尾递归</strong> （tail recursion）</li>
</ul>
<p># 例如python中就不支持尾递归优化，仍然会有栈溢出的问题</p>
<ul>
<li>普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
<ul>
<li>求和操作是在<strong>归</strong> 的过程中执行的，每次返回一层都进行一次求和</li>
</ul>
</li>
<li>尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。
<ul>
<li>求和操作是在<strong>递</strong> 的过程中执行的，<strong>归</strong> 则直接返回结果</li>
</ul>
</li>
</ul>
<h5 id="3-递归树">3.递归树</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)<span class="comment">// 终止条件 f(1) = 0, f(2) = 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> res = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>); <span class="comment">// 递归调用 f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">// 返回结果 f(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 这是一个求斐波拉契数列的递归函数，斐波拉契数列的前两个数是0，1，从第三个数开始是前面两个数的和，所以这里将终止条件设置为1，2，然后返回0，1。例如计算其第5项为几，则fib（5），未到达终止条件就会返回fib（4）和fib（3），分别返回（fib（3），fib（2））和（fib（2），fib（1）），此时fib（2）和fib（1）都已经到达终止条件，返回0，1，而fib（3）继续分解为fib（2），fib（1）再返回值0，1</p>
<p># 每一次调用都生成了两个调用分支，这样就形成了一个类似于树状图的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        fib(5)</span><br><span class="line">        /     \</span><br><span class="line">   fib(4)     fib(3)</span><br><span class="line">   /    \      /    \</span><br><span class="line">fib(3) fib(2) fib(2) fib(1)</span><br><span class="line">/    \</span><br><span class="line">fib(2) fib(1)</span><br></pre></td></tr></table></figure>
<p># 称其为<strong>层数为4的递归树</strong> （recursion tree）</p>
<ul>
<li>从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要
<ul>
<li>从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。</li>
<li>从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。</li>
</ul>
</li>
</ul>
<h4 id="3-对比">3.对比</h4>
<table>
<thead>
<tr>
<th></th>
<th>迭代</th>
<th>递归</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现方式</td>
<td>循环结构</td>
<td>函数调用自身</td>
</tr>
<tr>
<td>时间效率</td>
<td>效率通常较高，无函数调用开销</td>
<td>每次函数调用都会产生开销</td>
</tr>
<tr>
<td>内存使用</td>
<td>通常使用固定大小的内存空间</td>
<td>累积函数调用可能使用大量的栈帧空间</td>
</tr>
<tr>
<td>适用问题</td>
<td>适用于简单循环任务，代码直观、可读性好</td>
<td>适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰</td>
</tr>
</tbody>
</table>
<h4 id="4-联系">4.联系</h4>
<ul>
<li>
<p>从<strong>栈</strong> 的角度来分析</p>
<ul>
<li>递：当函数被<strong>调用时</strong> ，系统会在<strong>调用栈</strong> 上为该函数<strong>分配新的栈帧</strong> ，用于存储函数的局部变量、参数、返回地址等数据</li>
<li>归：当函数<strong>完成执行并返回时</strong> ，对应的栈帧会被从<strong>调用栈</strong> 上<strong>移除</strong> ，恢复之前函数的执行环境。</li>
</ul>
</li>
<li>
<p>尽管迭代和递归在很多情况下可以互相转化，但不一定值得这样做，有以下两点原因。</p>
<ul>
<li>转化后的代码可能更加难以理解，可读性更差。</li>
<li>对于某些复杂问题，模拟系统调用栈的行为可能非常困难</li>
</ul>
</li>
</ul>
<p># 在实际编程中需要权衡两者</p>
<h3 id="3-时间复杂度">3.时间复杂度</h3>
<ul>
<li>通常不会去具体考虑硬件配置，环境等因素，然后将每一步操作的耗时相加，这种做法不合理也不现实</li>
</ul>
<h4 id="1-统计时间增长趋势">1.统计时间增长趋势</h4>
<ul>
<li>统计<strong>算法运行时间随着数据量变大时的增长趋势</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 A 的时间复杂度：常数阶，与n的大小无关</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm_A</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 算法 B 的时间复杂度：线性阶，运行时间随n的增大而增大</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm_B</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 算法 C 的时间复杂度：常数阶，与n的大小无关</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm_C</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这种方法将统计<strong>时间</strong> 转化为统计<strong>操作数量</strong></p>
</li>
<li>
<p>但也存在<strong>局限性</strong> ：A和C因为都是常数阶，所以复杂度相同，但是运行时间肯定不相同。同时B是线性阶但是其运行时间随n的大小而变化，较小时B算法就会优于C算法</p>
</li>
</ul>
<h4 id="2-函数渐近上界">2.函数渐近上界</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>; <span class="comment">// +1</span></span><br><span class="line">	a = a + <span class="number">1</span>; <span class="comment">// +1</span></span><br><span class="line">	a = a * <span class="number">2</span>; <span class="comment">// +1</span></span><br><span class="line">	<span class="comment">// 循环 n 次</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// +1（每轮都执行 i ++）</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>); <span class="comment">// +1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>例如上述代码，先进行三次赋值运算，再进行一次循环，这个循环有两个步骤</p>
</li>
<li>
<p>因此将上述代码的操作数量记为一个与输入数据大小n相关的函数T（n）：T（n）=3+2n</p>
</li>
<li>
<p>T（n）函数是线性函数，复杂度是线性阶</p>
</li>
<li>
<p>将线性阶的时间复杂度记为<strong>𝑂(𝑛)</strong> ，这个数学符号称为<strong>大 𝑂 记号</strong> （big‑𝑂 notation），表示函数 𝑇(𝑛) 的<strong>渐近上界</strong> （asymptotic upper bound）：𝑛 &gt; 𝑛0时 ，均有 𝑇(𝑛) ≤ 𝑐 ⋅ 𝑓(𝑛)，记为 𝑇(𝑛) = 𝑂(𝑓(𝑛))</p>
</li>
<li>
<p>时间复杂度分析<strong>本质</strong> 上是计算“操作数量 𝑇(𝑛)”的渐近上界</p>
</li>
<li>
<p>计算渐近上界就是寻找一个函数 𝑓(𝑛) ，使得当 𝑛 趋向于无穷大时，𝑇(𝑛) 和 𝑓(𝑛) 处于相同的增长级别，仅相差一个常数项 𝑐 的倍数。</p>
</li>
</ul>
<h4 id="3-推算方法">3.推算方法</h4>
<h5 id="1-统计操作数量">1.统计操作数量</h5>
<h6 id="1-忽略-𝑇-𝑛-中的常数项">1.<strong>忽略</strong> 𝑇(𝑛) 中的常数项</h6>
<ul>
<li>与n无关，对时间复杂度不产生影响</li>
</ul>
<h6 id="2-省略所有系数">2.省略所有系数</h6>
<ul>
<li>系数对时间复杂度没有影响</li>
</ul>
<h6 id="3-循环嵌套时使用乘法">3.循环嵌套时使用乘法</h6>
<ul>
<li>总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然遵循前两点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>; <span class="comment">// +0（技巧 1）</span></span><br><span class="line">	a = a + n; <span class="comment">// +0（技巧 1）</span></span><br><span class="line">	<span class="comment">// +n（技巧 2）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> * n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// +n*n（技巧 3）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>T（n）=n^2+n</li>
</ul>
<h5 id="2-判断渐近上界">2.判断渐近上界</h5>
<ul>
<li>时间复杂度由𝑇(𝑛) 中<strong>最高阶的项来决定</strong> 。这是因为在 𝑛 趋于无穷大时，最高阶的项将发挥<strong>主导</strong> 作用，其他</li>
</ul>
<p>项的影响都可以忽略</p>
<h4 id="4-常见类型">4.常见类型</h4>
<ul>
<li>𝑂(1) &lt; 𝑂(log 𝑛) &lt; 𝑂(𝑛) &lt; 𝑂(𝑛 log 𝑛) &lt; 𝑂(𝑛2 ) &lt; 𝑂(2𝑛) &lt; 𝑂(𝑛!）</li>
<li>常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt; 指数阶 &lt; 阶乘阶</li>
</ul>
<h5 id="1-常数阶-𝑂-1）">1.常数阶 𝑂(1）</h5>
<ul>
<li>常数阶的操作数量与输入数据大小 𝑛 无关，即不随着 𝑛 的变化而变化</li>
</ul>
<h5 id="2-线性阶𝑂-n）">2.线性阶𝑂(n）</h5>
<ul>
<li>线性阶的操作数量相对于输入数据大小 𝑛 以线性级别增长。线性阶通常出现在单层循环中</li>
</ul>
<p># 例如遍历数组和链表</p>
<ul>
<li><strong>输入数据大小𝑛需根据输入数据的类型来具体确定</strong>，可以是数据大小，也可以是数组长度</li>
</ul>
<h5 id="3-平方阶𝑂-n-2）">3.平方阶𝑂(n^2）</h5>
<ul>
<li>
<p>平方阶的操作数量相对于输入数据大小 𝑛 以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层</p>
<p>循环的时间复杂度都为 𝑂(𝑛) ，因此总体的时间复杂度为 𝑂(𝑛^2 )</p>
</li>
</ul>
<h5 id="4-指数阶𝑂-2-n）">4.指数阶𝑂(2^n）</h5>
<ul>
<li>
<p>在实际算法中，指数阶常出现于<strong>递归函数</strong> 中</p>
</li>
<li>
<p>例如上述的递归数中的斐波拉契数列，每一次调用都生成了两个调用分支</p>
</li>
</ul>
<p># 对于数据规模较大的问题，指数阶是不可接受的，通常需要使用动态规划或贪心算法等来解决。</p>
<h5 id="5-对数阶𝑂-log-n）">5.对数阶𝑂(log n）</h5>
<ul>
<li>对数阶反映了<strong>每轮缩减到一半</strong> 的情况。</li>
<li>时间复杂度为 𝑂(log2 𝑛) ，简记为 𝑂(log 𝑛)</li>
<li>与指数阶类似，对数阶也常出现于<strong>递归函数</strong> 中。</li>
<li>体现了<strong>一分为多</strong> 和<strong>化繁为简</strong> 的算法思想。</li>
</ul>
<p># 准确来说，<strong>一分为 𝑚</strong> 对应的时间复杂度是 𝑂(log𝑚 𝑛) 。</p>
<p>𝑂(log𝑚 𝑛) = 𝑂(log𝑘 𝑛/ log𝑘  𝑚) = 𝑂(log𝑘 𝑛)</p>
<p>底数 𝑚 可以在不影响复杂度的前提下转换。因此我们通常会省略底数 𝑚 ，将对数阶直接记为 𝑂(log 𝑛) 。</p>
<h5 id="6-线性对数阶𝑂-n-log-n）">6.线性对数阶𝑂(n*log n）</h5>
<ul>
<li>线性对数阶常出现于<strong>嵌套循环</strong> 中，两层循环的时间复杂度分别为<strong>𝑂(log 𝑛)</strong> 和<strong>𝑂(𝑛)</strong> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">linearLogRecur</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> count = linearLogRecur(n / <span class="number">2</span>) + linearLogRecur(n / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>主流排序算法的时间复杂度通常为 𝑂(𝑛*log 𝑛) ，例如快速排序、归并排序、堆排序等</li>
</ul>
<h5 id="7-阶乘阶𝑂-n！）">7.阶乘阶𝑂(n！）</h5>
<ul>
<li>乘阶对应数学上的<strong>全排列</strong> 问题。给定 𝑛 个互不重复的元素，求其所有可能的排列方案，方案数量为:</li>
<li>n! = 𝑛 × (𝑛 − 1) × (𝑛 − 2) × ⋯ × 2 × 1</li>
<li>阶乘通常使用<strong>递归</strong> 实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           *</span><br><span class="line">        /     \</span><br><span class="line">       *       *</span><br><span class="line">   /    \        \</span><br><span class="line">  *      *        *</span><br><span class="line">/    \     \        \</span><br><span class="line">*      *     *        *</span><br><span class="line">|  \     \     \        \</span><br><span class="line">*    *     *     *        *</span><br></pre></td></tr></table></figure>
<p># 形成这样的树状图，每次分裂后其中一个不再分裂</p>
<h4 id="5-最差，最佳，平均时间复杂度">5.最差，最佳，平均时间复杂度</h4>
<ul>
<li><strong>算法的时间效率往往不是固定的，而是与输入数据的分布有关</strong> 。</li>
</ul>
<p># 例如有两个数组，现在要返回数字1的索引</p>
<p>a1=[5,4,3,2,1]，需要遍历整个数组，达到<strong>最差复杂度𝑂(𝑛)</strong> ，其对应函数的渐近上界。</p>
<p>a2=[1,2,3,4,5]，不需要继续遍历后面的数字，达到<strong>最佳时间复杂度Ω(1)</strong> ，其对应函数的渐近下界。</p>
<ul>
<li>
<p>实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。而最差时间复杂度更为实用，因为它给出了一个<strong>效率安全值</strong>，让我们可以放心地使用算法。</p>
</li>
<li>
<p><strong>平均时间复杂度</strong>可以体现算法在随机输入数据下的运行效率，用 Θ（theta） 记号来表示（有时候也会用𝑂(𝑛)表示）</p>
</li>
</ul>
<p># 部分算法较为简单可以直接计算平均时间复杂度，但是对于较为复杂的算法则直接用最差时间复杂度来作为评判标准</p>
<h3 id="4-空间复杂度">4.空间复杂度</h3>
<ul>
<li><strong>空间复杂度</strong> （space complexity）用于衡量算法<strong>占用内存空间</strong> 随着数据量变大时的增长趋势。</li>
</ul>
<h4 id="1-算法相关空间">1.算法相关空间</h4>
<ul>
<li>
<p><strong>输入空间</strong> ：用于存储算法的输入数据。</p>
</li>
<li>
<p><strong>暂存空间</strong> ：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</p>
<ul>
<li><strong>暂存数据</strong> ：用于保存算法运行过程中的各种常量、变量、对象等。</li>
<li><strong>栈帧空间</strong> ：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li>
<li><strong>指令空间</strong> ：用于保存编译后的程序指令，在实际统计中通常忽略不计。</li>
</ul>
</li>
<li>
<p><strong>输出空间</strong> ：用于存储算法的输出数据。</p>
</li>
<li>
<p>在分析一段程序的空间复杂度时，<strong>我们通常统计暂存数据、栈帧空间和输出数据三部分</strong> ，但是一般统计<strong>暂存空间</strong> 加上<strong>输出空间</strong></p>
</li>
</ul>
<h4 id="2-推算方法">2.推算方法</h4>
<ul>
<li>
<p>与时间复杂度类似，将统计<strong>操作数量</strong> 转为<strong>使用空间大小</strong></p>
</li>
<li>
<p>但是不同于时间复杂度的是，通常只关注<strong>最差空间复杂度</strong> ，必须确保在所有输入数据下都有足够的内存空间预留。</p>
</li>
<li>
<p>其中最差的含义：</p>
<ul>
<li><strong>以最差输入数据为准</strong> ：对于不同的数据量会有不同的空间复杂度，以最差的为准</li>
<li><strong>以算法运行中的峰值内存为准</strong></li>
</ul>
</li>
<li>
<p>在递归函数中，需要统计<strong>栈帧空间</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">		func();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">return</span> recur(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 例如在这个代码中，loop函数中虽然在循环，但是每次调用后都会返回，会释放掉栈帧空间，空间复杂度为𝑂(1)</p>
<p>而recur递归函数，在归之前会有n个未返回的递归函数，会占用𝑂(n)的空间复杂度</p>
<h4 id="3-常见类型">3.常见类型</h4>
<ul>
<li>
<p>𝑂(1) &lt; 𝑂(log 𝑛) &lt; 𝑂(𝑛) &lt; 𝑂(𝑛^2 ) &lt; 𝑂(2^𝑛)</p>
</li>
<li>
<p>常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 平方阶 &lt; 指数阶</p>
</li>
</ul>
<h5 id="1-常数阶𝑂-1）">1.常数阶𝑂(1）</h5>
<ul>
<li>常数阶常见于数量与输入数据大小 𝑛 <strong>无关</strong> 的常量、变量、对象</li>
</ul>
<p># 需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 𝑂(1)</p>
<h5 id="2-线性阶𝑂-n）-2">2.线性阶𝑂(n）</h5>
<ul>
<li>线性阶常见于元素数量与 𝑛 成<strong>正比</strong> 的数组、链表、栈、队列等</li>
</ul>
<p># n就是这些表和数组的长度</p>
<ul>
<li>在<strong>递归函数</strong> 中，同时有多个未返回的函数，也使用 𝑂(𝑛) 大小的栈帧空间</li>
</ul>
<h5 id="3-平方阶𝑂-n-2）-2">3.平方阶𝑂(n^2）</h5>
<ul>
<li>
<p>平方阶常见于<strong>矩阵</strong> （二维列表）和<strong>图</strong> （由点（nodes）和线（边（edges））组成），元素数量与 𝑛 成平方关系</p>
</li>
<li>
<p>在<strong>递归函数</strong> 中，如递归深度为n，每个递归中又定义了一个数组，总体也占用 𝑂(𝑛^2 ) 空间</p>
</li>
</ul>
<h5 id="4-指数阶𝑂-2-n）-2">4.指数阶𝑂(2^n）</h5>
<ul>
<li>指数阶常见于二叉树，层数为 𝑛 的“满二叉树”的节点数量为 2^𝑛 − 1,占用 𝑂(2^n ) 空间</li>
</ul>
<h5 id="5-对数阶𝑂-log-n）-2">5.对数阶𝑂(log n）</h5>
<ul>
<li>对数阶常见于分治算法。例如归并排序，输入长度为 𝑛 的数组，每轮递归将数组从中点处划分为两半，形成高度为 log 𝑛 的递归树，使用 𝑂(log 𝑛) 栈帧空间。</li>
</ul>
<h4 id="5-权衡时间与空间">5.权衡时间与空间</h4>
<ul>
<li>理想情况下，我们希望算法的时间复杂度和空间复杂度都能达到最优。然而在实际情况中，同时优化时间复杂度和空间复杂度通常非常困难</li>
<li><strong>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然</strong>。我们将牺牲内存空间来提升算法运行速度的思路称为<strong>以空间换时间</strong> ；反之，则称为<strong>以时间换空间</strong> 。</li>
<li>选择哪种思路取决于我们更看重哪个方面。在<strong>大多数情况下</strong> ，<strong>时间比空间更宝贵</strong> ，因此<strong>以空间换时间</strong> 通常是更常用的策略。当然，在<strong>数据量很大</strong> 的情况下，<strong>控制空间复杂度</strong> 也非常重要</li>
</ul>
<h2 id="3-数据结构">3.数据结构</h2>
<h3 id="1-数据结构定义">1.数据结构定义</h3>
<ul>
<li><strong>数据结构</strong> （data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法</li>
</ul>
<h3 id="2-设计目标">2.设计目标</h3>
<ul>
<li><strong>空间占用</strong> 尽量少，以节省计算机内存。</li>
<li><strong>数据操作</strong> 尽可能快速，涵盖数据访问、添加、删除、更新等。</li>
<li>提供简洁的<strong>数据表示和逻辑信息</strong> ，以便算法高效运行。</li>
</ul>
<p># 通常来说这三者无法同时做到最好，只能<strong>相互权衡</strong></p>
<h3 id="3-与算法的关系">3.与算法的关系</h3>
<ul>
<li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li>
<li>算法为数据结构注入生命力。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li>
<li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li>
</ul>
<h3 id="4-数据结构分类">4.数据结构分类</h3>
<ul>
<li>常见的数据结构包括：
<ul>
<li>数组</li>
<li>链表</li>
<li>栈</li>
<li>队列</li>
<li>哈希表</li>
<li>树</li>
<li>堆</li>
<li>图</li>
</ul>
</li>
<li>可以分为<strong>逻辑结构</strong> 和<strong>物理结构</strong></li>
</ul>
<h4 id="1-逻辑结构">1.逻辑结构</h4>
<ul>
<li>逻辑结构揭示了数据元素之间的<strong>逻辑关系</strong> 。</li>
<li>逻辑结构又可以分为两类
<ul>
<li>线性数据结构
<ul>
<li>数组</li>
<li>链表</li>
<li>栈</li>
<li>队列</li>
<li>哈希表
<ul>
<li>元素之间是一对一的顺序关系</li>
</ul>
</li>
</ul>
</li>
<li>非线性数据结构又可以分为两类
<ul>
<li>树状结构
<ul>
<li>树</li>
<li>堆</li>
<li>哈希表
<ul>
<li>元素之间是一对多的关系</li>
</ul>
</li>
</ul>
</li>
<li>网状结构
<ul>
<li>图
<ul>
<li>元素之间是多对多的关系</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-物理结构">2.物理结构</h4>
<ul>
<li>
<p>算法程序中正在处理的数据主要存储在内存中，系统通过<strong>内存地址</strong> 来访问目标位置的数据</p>
</li>
<li>
<p>每个内存空间都有<strong>唯一</strong> 的内存地址</p>
</li>
<li>
<p>当一块内存被一个程序占用时，通常无法被其他程序同时使用</p>
</li>
<li>
<p>因此，在算法设计中，<strong>内存资源</strong> 是一个重要的考虑因素</p>
</li>
<li>
<p>物理结构反映了数据在计算机内存中的存储方式</p>
</li>
<li>
<p>可以分为</p>
<ul>
<li>连续空间存储（数组）</li>
<li>分散空间存储（链表）</li>
</ul>
</li>
</ul>
<p># 两种结构在<strong>时间效率</strong> 和<strong>空间效率</strong> 方面呈现<strong>互补</strong></p>
<ul>
<li>所有的数据结构都是基于数组，链表或二者的组合实现的
<ul>
<li>基于数组可实现
<ul>
<li>栈</li>
<li>队列</li>
<li>哈希表</li>
<li>树</li>
<li>堆</li>
<li>图</li>
<li>矩阵</li>
<li>张量（维度&gt;=3的数组）</li>
<li>等</li>
</ul>
</li>
<li>基于链表可实现
<ul>
<li>栈</li>
<li>队列</li>
<li>哈希表</li>
<li>树</li>
<li>堆</li>
<li>图</li>
<li>等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-基本数据类型">5.基本数据类型</h3>
<ul>
<li>参考Java中的数据类型</li>
</ul>
<p># 注意不同编程语言的数据类型的定义在占用空间，取值范围和默认值会有所不同</p>
<ul>
<li>基本数据类型提供了数据的<strong>内容类型</strong></li>
<li>数据结构提供了数据的<strong>组织方式</strong></li>
</ul>
<h3 id="6-数字编码">6.数字编码</h3>
<h4 id="1-原码，反码，补码">1.原码，反码，补码</h4>
<h5 id="1-原码">1.原码</h5>
<ul>
<li>十进制数据的二进制表现形式，最左边是符号位，0为正，1为负</li>
<li>八个bit为一个字节</li>
<li>最大值：01111111=127</li>
<li>最小值：11111111=-127</li>
</ul>
<h6 id="1-原码的计算">1.原码的计算</h6>
<ul>
<li>二进制的计算方式，加1，则直接在末位加1，满二进一</li>
</ul>
<h6 id="2-原码的弊端">2.原码的弊端</h6>
<ul>
<li>用原码对正数进行计算是不会有问题的</li>
<li>但如果是负数计算，结果就出错，实际运算的结果与预期的结果是相反的</li>
</ul>
<h5 id="2-反码">2.反码</h5>
<ul>
<li>为了解决<strong>原码不能计算负数</strong> 的问题而出现的</li>
</ul>
<h6 id="1-反码的计算">1.反码的计算</h6>
<ul>
<li>
<p>正数的反码不变，负数的反码在原码的基础上，符号位不变，数字取反，0变1，1变0</p>
</li>
<li>
<p>如果加1，则在末位加1，满二进一，得到的就是加1后的反码</p>
</li>
</ul>
<h6 id="2-反码的弊端">2.反码的弊端</h6>
<ul>
<li>反码的11111111表示-0，如果再加1，则变为00000000=0</li>
<li>同样类似于-4的反码+7，跨0，会比正确结果小1</li>
</ul>
<p># 因为反码中的0有11111111和00000000两种表示方式</p>
<h5 id="3-补码">3.补码</h5>
<ul>
<li>
<p>在负数的反码的基础上加1，这样-0就是00000000，-1就是11111111，反码再依次向后，形成补码</p>
</li>
<li>
<p>-127就是10000001，-128就是10000000，-128只有补码，没有原码</p>
</li>
<li>
<p><strong>计算机中数字的存储计算都是以补码的形式来操作的</strong></p>
</li>
<li>
<p>所以<strong>一个字节</strong> 的范围就是**-128~127**</p>
</li>
</ul>
<h4 id="2-浮点数编码">2.浮点数编码</h4>
<ul>
<li>
<p>在IEEE 754标准中，32bit长度的float类型由三个部分组成</p>
<ul>
<li>符号位：S，占1位</li>
<li>指数位：E，占8位</li>
<li>分数为：N，占23位</li>
</ul>
</li>
<li>
<p>尽管浮点数float<strong>扩展了取值范围</strong> ，但其副作用是<strong>牺牲了精度</strong> 。</p>
</li>
</ul>
<h3 id="7-字符编码">7.字符编码</h3>
<h4 id="1-ASCII字符集">1.ASCII字符集</h4>
<ul>
<li>
<p>用7位二进制数表示一个字符，最多能表示128个不同的字符</p>
</li>
<li>
<p>包含英文字母的大小写，数字，标点，控制字符（换行，制表）</p>
</li>
<li>
<p>字符用一个字节表示</p>
</li>
</ul>
<h4 id="2-GBK字符集">2.GBK字符集</h4>
<ul>
<li>
<p>收录汉字，包含国家标准GB13000-1中的全部中日韩汉字，和BIG5编码中的所有汉字</p>
</li>
<li>
<p>计算机默认编码</p>
</li>
<li>
<p>字符用两个字节表示</p>
</li>
</ul>
<h4 id="3-Unicode字符集（统一码）">3.Unicode字符集（统一码）</h4>
<ul>
<li>
<p>国际标准字符集，将世界各种语言的每个字符定义一个唯一的编码（码点），以满足跨语言，跨平台的文本信息转化</p>
</li>
<li>
<p>但它并没有规定在计算机中如何存储这些字符码点</p>
</li>
<li>
<p>当多种长度的码点同时出现在一个文本时，系统如何解析字符</p>
</li>
<li>
<p>可以将所有字符存储为等长的编码，通过补0，将所有字符的编码都变为2字节长度</p>
</li>
<li>
<p>但是这样非常浪费空间</p>
</li>
</ul>
<h4 id="4-UTF-8编码">4.UTF-8编码</h4>
<ul>
<li>
<p>是国际上使用最广泛的Unicode编码方法</p>
</li>
<li>
<p>它是一种<strong>可变长度</strong> 的编码</p>
</li>
<li>
<p>使用1~4个字节来表示一个字符，根据复杂度而变</p>
</li>
<li>
<p>ASCII字符需要1字节</p>
</li>
<li>
<p>拉丁字母和希腊字母需要2字节</p>
</li>
<li>
<p>常用中文字符需要3字节</p>
</li>
<li>
<p>一些生僻字需要4字节</p>
</li>
<li>
<p>对于长度为1字节的字符，将最高位设置为0，其余7位设置位Unicode编码，ASCII字符在Unicode字符集中占前128个码点，所以<strong>UTF-8编码可以向下兼容ASCII码</strong></p>
</li>
<li>
<p>除了UTF-8以外还有两种常见的编码方式</p>
</li>
<li>
<p><strong>UTF‑16 编码</strong> ：使用 2 或 4 字节来表示一个字符。所有的 ASCII 字符和常用的非英文字符，都用 2 字节表示；少数字符需要用到 4 字节表示。对于 2 字节的字符，UTF‑16 编码与 Unicode 码点相等。</p>
</li>
<li>
<p><strong>UTF‑32 编码</strong> ：每个字符都使用 4 字节。这意味着 UTF‑32 比 UTF‑8 和 UTF‑16 更占用空间，特别是对于 ASCII 字符占比较高的文本</p>
</li>
<li>
<p>从存储空间占用的角度来看，UTF-8的效率非常高，对比UTF-16和UTF-32更加高效</p>
</li>
<li>
<p>从兼容性角度来看，UTF-8的通用性也是最佳</p>
</li>
</ul>
<h4 id="5-编程语言的字符编码">5.编程语言的字符编码</h4>
<ul>
<li>于以往的大多数编程语言，程序运行中的字符串都采用 UTF‑16 或 UTF‑32 这类等长编码。在等长编码下，可以将字符串看作数组来处理，这种做法具有以下优点
<ul>
<li><strong>随机访问</strong>：UTF‑16 编码的字符串可以很容易地进行随机访问。UTF‑8 是一种变长编码，要想找到第 𝑖个字符，我们需要从字符串的开始处遍历到第 𝑖 个字符，这需要 𝑂(𝑛) 的时间。</li>
<li><strong>字符计数</strong>：与随机访问类似，计算 UTF‑16 编码的字符串的长度也是 𝑂(1) 的操作。但是，计算 UTF‑8编码的字符串的长度需要遍历整个字符串。</li>
<li><strong>字符串操作</strong>：在 UTF‑16 编码的字符串上，很多字符串操作（如分割、连接、插入、删除等）更容易进行。</li>
</ul>
</li>
</ul>
<p># 在 UTF‑8 编码的字符串上，进行这些操作通常需要额外的计算，以确保不会产生无效的 UTF‑8 编码</p>
<p># 但是在文件存储和网络传输中通常还是将字符串编码位UTF-8格式，以达到最优的兼容性和空间效率。</p>
<h2 id="4-数组与链表">4.数组与链表</h2>
<h3 id="1-数组">1.数组</h3>
<ul>
<li><strong>数组</strong> （array）是一种<strong>线性数据结构</strong> ，其将<strong>相同类型</strong> 的元素存储在<strong>连续的内存空间</strong> 中。我们将元素在数组中的位置称为该元素的<strong>索引</strong> （index）。</li>
</ul>
<h4 id="1-数组常用操作">1.数组常用操作</h4>
<h5 id="1-初始化数组">1.初始化数组</h5>
<ul>
<li>可以根据需求选用数组的两种初始化方式：<strong>无初始值</strong> 和<strong>给定初始值</strong> 。在<strong>未指定初始值</strong> 的情况下，大多数编程语言会将数组元素初始化为0</li>
</ul>
<h5 id="2-访问元素">2.访问元素</h5>
<ul>
<li>因为被存储在连续的内存空间中，所以只要给定数组的内存地址（首元素的内存地址）和某个元素的索引，就可以计算除该元素的内存地址，从而直接访问该元素</li>
<li>计算公式：<strong>元素内存地址 = 数组内存地址 + 元素长度 * 元素索引</strong></li>
</ul>
<p># 元素长度是又元素的类型决定的</p>
<ul>
<li>索引是从0开始的，因为索引本质上是内存地址的偏移量，第一个元素的地址偏移量是0，因此索引为0</li>
</ul>
<h5 id="3-插入元素">3.插入元素</h5>
<ul>
<li>由于数组是<strong>连续存储</strong> 的，所以要插入元素，就要将该元素后的所有元素都<strong>向后移动一位</strong> ，再将元素赋值给索引</li>
<li>但是数组的长度是确定的，这样会导致<strong>最后一个元素的丢失</strong></li>
</ul>
<h5 id="4-删除元素">4.删除元素</h5>
<ul>
<li>
<p>与插入相同，将删除元素后面的元素都<strong>向前移动一位</strong></p>
</li>
<li>
<p>因此插入和删除会有以下缺点</p>
</li>
<li>
<p><strong>时间复杂度高</strong> ：数组的插入和删除的平均时间复杂度均为 𝑂(𝑛) ，其中 𝑛 为数组长度。</p>
</li>
<li>
<p><strong>丢失元素</strong> ：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。</p>
</li>
<li>
<p><strong>内存浪费</strong> ：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是无意义的，但这样做会造成部分内存空间浪费。</p>
</li>
</ul>
<h5 id="5-遍历数组">5.遍历数组</h5>
<ul>
<li>既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素</li>
</ul>
<h5 id="6-查找元素">6.查找元素</h5>
<ul>
<li>在数组中查找指定元素需要遍历数组，判断是否匹配</li>
<li>因为数组是线性数据结构，所以这种查找操作称为<strong>线性查找</strong></li>
</ul>
<h5 id="7-扩容数组">7.扩容数组</h5>
<ul>
<li>当原本的数组长度不够时，需要扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个𝑂(𝑛) 的操作，在数组很大的情况下非常耗时</li>
</ul>
<h4 id="2-数组的优点与局限性">2.数组的优点与局限性</h4>
<h5 id="1-优点">1.优点</h5>
<ul>
<li><strong>空间效率高</strong> ：数组为数据分配了连续的内存块，无须额外的结构开销。</li>
<li><strong>支持随机访问</strong> ：数组允许在 𝑂(1) 时间内访问任何元素。</li>
<li><strong>缓存局部性</strong> ：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。</li>
</ul>
<h5 id="2-局限性">2.局限性</h5>
<ul>
<li><strong>插入与删除效率低</strong> ：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li>
<li><strong>长度不可变</strong> ：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li>
<li><strong>空间浪费</strong> ：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li>
</ul>
<h3 id="2-链表">2.链表</h3>
<ul>
<li>
<p><strong>链表</strong> （linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过<strong>引用</strong> 相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点</p>
</li>
<li>
<p>因为计算机的内存空间的占用是分散的并不连续，但是数组的存储必须连续，数组过大时，内存不一定能够提供连续空间</p>
</li>
<li>
<p>链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。</p>
</li>
<li>
<p>链表的组成单位是<strong>节点</strong> （node），其中包含数据</p>
<ul>
<li>值</li>
<li>指向下一个节点的引用（在支持指针的语言中，引用就替换为<strong>指针</strong> ）</li>
</ul>
<p># 因此链表在相同数据量下所占用的空间也比数组要大</p>
</li>
<li>
<p>链表的首个节点就叫<strong>头节点</strong> ，最后一个节点就叫<strong>尾节点</strong></p>
</li>
</ul>
<h4 id="1-链表常用操作">1.链表常用操作</h4>
<h5 id="1-初始化链表">1.初始化链表</h5>
<h6 id="1-初始化各个节点对象">1.初始化各个节点对象</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNode* n0 = newListNode(<span class="number">1</span>);</span><br><span class="line">ListNode* n1 = newListNode(<span class="number">3</span>);</span><br><span class="line">ListNode* n2 = newListNode(<span class="number">2</span>);</span><br><span class="line">ListNode* n3 = newListNode(<span class="number">5</span>);</span><br><span class="line">ListNode* n4 = newListNode(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h6 id="2-构建节点之间的引用关系">2.构建节点之间的引用关系</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n0-&gt;next = n1;</span><br><span class="line">n1-&gt;next = n2;</span><br><span class="line">n2-&gt;next = n3;</span><br><span class="line">n3-&gt;next = n4;</span><br></pre></td></tr></table></figure>
<p># 通常将链表头作为链表的代称，上述代码的链表可以称为n0</p>
<h5 id="2-插入节点">2.插入节点</h5>
<ul>
<li>插入一个新的节点，只需要<strong>更改相邻两个节点的引用（指针）</strong> ，时间复杂度为𝑂(1)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(ListNode *n0, ListNode *P)</span> &#123;</span><br><span class="line">	ListNode *n1 = n0-&gt;next;</span><br><span class="line">	P-&gt;next = n1;</span><br><span class="line">	n0-&gt;next = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-删除节点">3.删除节点</h5>
<ul>
<li>删除一个节点，只需要<strong>改变前一个节点的引用（指针）</strong></li>
<li>被删除节点的引用虽然还存在，但因为已经无法被访问到了，所以认为已经被删除</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">removeItem</span><span class="params">(ListNode *n0)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!n0-&gt;next)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// n0 -&gt; P -&gt; n1</span></span><br><span class="line">	ListNode *P = n0-&gt;next;</span><br><span class="line">    ListNode *n1 = P-&gt;next;</span><br><span class="line">	n0-&gt;next = n1;</span><br><span class="line">	<span class="comment">// 释放内存</span></span><br><span class="line">	<span class="built_in">free</span>(P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-访问节点">4.访问节点</h5>
<ul>
<li>链表中访问节点的效率较低，需要从头开始，<strong>逐个向后遍历</strong> ，时间复杂度为 𝑂(𝑛)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNode *<span class="title function_">access</span><span class="params">(ListNode *head, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-查找节点">5.查找节点</h5>
<ul>
<li>查找某一个值的节点，遍历链表，也是<strong>线性查找</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(ListNode *head, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (head) &#123;</span><br><span class="line">		<span class="keyword">if</span> (head-&gt;val == target)</span><br><span class="line">			<span class="keyword">return</span> index;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-数组与节点的对比">2.数组与节点的对比</h4>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储方式</td>
<td>连续内存空间</td>
<td>分散内存空间</td>
</tr>
<tr>
<td>容量扩展</td>
<td>长度不可变</td>
<td>可灵活扩展</td>
</tr>
<tr>
<td>内存效率</td>
<td>元素占用内存少、但可能浪费空间</td>
<td>元素占用内存多</td>
</tr>
<tr>
<td>访问元素</td>
<td>𝑂(1)</td>
<td>𝑂(𝑛)</td>
</tr>
<tr>
<td>添加元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>删除元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<h4 id="3-常见链表类型">3.常见链表类型</h4>
<ul>
<li>
<p><strong>单向链表</strong> ：即普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。</p>
</li>
<li>
<p><strong>环形链表</strong> ：如果令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</p>
</li>
<li>
<p><strong>双向链表</strong> ：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</p>
</li>
</ul>
<h4 id="4-链表典型应用">4.链表典型应用</h4>
<ul>
<li>
<p><strong>单向链表</strong> ：通常用于实现栈、队列、哈希表和图等数据结构。</p>
<ul>
<li>
<p><strong>栈与队列</strong> ：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。</p>
</li>
<li>
<p><strong>哈希表</strong> ：链式地址是<strong>解决哈希冲突</strong> 的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</p>
</li>
<li>
<p><strong>图</strong> ：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素代</p>
<p>表与该顶点相连的其他顶点</p>
</li>
</ul>
</li>
<li>
<p><strong>双向链表</strong> ：常用于需要<strong>快速查找前一个和后一个元素</strong> 的场景。</p>
<ul>
<li><strong>高级数据结构</strong> ：比如在红黑树、B 树中，我们需要访问节点的<strong>父节点</strong> ，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</li>
<li><strong>浏览器历史</strong> ：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</li>
<li><strong>LRU 算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</li>
</ul>
</li>
<li>
<p><strong>环形链表</strong> ：常用于需要<strong>周期性操作</strong> 的场景，比如操作系统的<strong>资源调度</strong> 。</p>
<ul>
<li><strong>时间片轮转调度算法</strong> ：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。</li>
<li><strong>数据缓冲区</strong> ：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在<strong>音频、视频播放器</strong> 中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现<strong>无缝播放</strong> 。</li>
</ul>
</li>
</ul>
<h3 id="3-列表">3.列表</h3>
<ul>
<li>
<p><strong>列表</strong>（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。</p>
</li>
<li>
<p>当使用数组实现列表时，<strong>长度不可变的性质会导致列表的实用性降低</strong></p>
</li>
<li>
<p>可以使用<strong>动态数组</strong> （dynamic array）来实现列表</p>
</li>
<li>
<p>许多语言中提供的列表都是基于动态数组实现的</p>
</li>
<li>
<p>但是<strong>c语言中没有动态数组</strong></p>
</li>
</ul>
<h4 id="1列表常用操作">1列表常用操作</h4>
<h5 id="1-初始化列表">1.初始化列表</h5>
<h6 id="1-无初始值">1.无初始值</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums1: <span class="built_in">list</span>[<span class="built_in">int</span>] = []</span><br></pre></td></tr></table></figure>
<h6 id="2-有初始值">2.有初始值</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h5 id="2-访问元素-2">2.访问元素</h5>
<ul>
<li>列表本质上是数组，因此可以在 𝑂(1) 时间内访问和更新元素，效率很高</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num: <span class="built_in">int</span> = nums[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h5 id="3-插入和删除元素">3.插入和删除元素</h5>
<ul>
<li><strong>在列表尾部添加元素</strong> 的时间复杂度为 𝑂(1) ，但插入和删除元素的效率仍与数组相同，时间复杂度为 𝑂(𝑛) 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums.insert(<span class="number">3</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p># 在索引为3的位置插入数字6</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums.pop(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p># 删除索引为3的元素</p>
<h5 id="4-遍历列表">4.遍历列表</h5>
<ul>
<li>和数组一样，可以根据索引遍历，也可以直接遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line"></span><br><span class="line">	count += nums[i]</span><br></pre></td></tr></table></figure>
<p># 通过索引遍历列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line"></span><br><span class="line">	count += num</span><br></pre></td></tr></table></figure>
<p># 直接遍历列表元素</p>
<h5 id="5-拼接列表">5.拼接列表</h5>
<ul>
<li>将一个列表拼接到另一个列表的尾部</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums1: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>]</span><br><span class="line">nums += nums1</span><br></pre></td></tr></table></figure>
<h5 id="6-排序列表">6.排序列表</h5>
<ul>
<li>将列表元素排序，便于后面的二分查找和双指针</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums.sort()</span><br></pre></td></tr></table></figure>
<h4 id="2-列表实现">2.列表实现</h4>
<ul>
<li>一个简易的列表主要有三个部分
<ul>
<li><strong>初始容量</strong> ：选取一个合理的数组初始容量。</li>
<li><strong>数量记录</strong> ：声明一个变量 size ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。</li>
<li><strong>扩容机制</strong> ：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组</li>
</ul>
</li>
</ul>
<h3 id="4-内存与缓存">4.内存与缓存</h3>
<ul>
<li><strong>物理结构在很大程度上决定了程序对内存和缓存的使用效率</strong> ，影响算法的整体性能</li>
</ul>
<h4 id="1-计算机存储设备">1.计算机存储设备</h4>
<ul>
<li>主要包含硬盘（hard disk）、内存（random‑access memory, RAM）、缓存（cache memory）</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>硬盘</th>
<th>内存</th>
<th>缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td>用途</td>
<td>长期存储数据，包括操作系统、程序、文件等</td>
<td>临时存储当前运行的程序和正在处理的数据</td>
<td>存储经常访问的数据和指令，减少 CPU访问内存的次数</td>
</tr>
<tr>
<td>易失性</td>
<td>断电后数据不会丢失</td>
<td>断电后数据会丢失</td>
<td>断电后数据会丢失</td>
</tr>
<tr>
<td>容量</td>
<td>较大，TB 级别</td>
<td>较小，GB 级别</td>
<td>非常小，MB 级别</td>
</tr>
<tr>
<td>速度</td>
<td>较慢，几百到几千 MB/s</td>
<td>较快，几十 GB/s</td>
<td>非常快，几十到几百 GB/s</td>
</tr>
<tr>
<td>价格</td>
<td>较便宜，几毛到几元 / GB</td>
<td>较贵，几十到几百元 / GB</td>
<td>非常贵，随 CPU 打包计价</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>硬盘难以被内存取代</strong> 。首先，内存中的数据在断电后会丢失，因此它<strong>不适合长期存储数据</strong> ；其次，内存的成本是硬盘的几十倍，这使得它难以在消费者市场普及。</p>
</li>
<li>
<p><strong>缓存的大容量和高速度难以兼得</strong> 。随着L1、L2、L3缓存的容量逐步增大，其<strong>物理尺寸会变大</strong> ，与 CPU核心之间的物理距离会变远，从而导致<strong>数据传输时间增加</strong> ，<strong>元素访问延迟变高</strong> 。在当前技术下，<strong>多层级</strong> 的缓存结构是容量、速度和成本之间的最佳平衡点</p>
</li>
<li>
<p>总的来说，<strong>硬盘用于长期存储大量数据，内存用于临时存储程序运行中正在处理的数据，而缓存则用于存储经常访问的数据和指令</strong>，以提高程序运行效率。三者共同协作，确保计算机系统高效运行</p>
</li>
<li>
<p>在程序运行时，数据会<strong>从硬盘中被读取到内存中</strong> ，供CPU计算使用。缓存可以看作CPU的一部分，<strong>它通过智能地从内存加载数据</strong>，给CPU提供高速的数据读取，从而显著提升程序的执行效率，减少对较慢的内存的依赖</p>
</li>
</ul>
<h4 id="2-数据结构的内存效率">2.数据结构的内存效率</h4>
<ul>
<li>内存是有限的，而且同一块内存只能有一个程序使用
<ul>
<li>数组：需要连续的内存空间，可能导致浪费，而且扩容时也需要时间和空间</li>
<li>链表：以节点为单位，更加灵活</li>
</ul>
</li>
<li>程序运行时，反复申请和释放内存，<strong>空闲的内存碎片化程度变高</strong>
<ul>
<li>数组：连续存储，不容易导致内存碎片化</li>
<li>链表：分散存储，频繁的插入与删除，易导致内存碎片化</li>
</ul>
</li>
</ul>
<h4 id="3-数据结构的缓存效率">3.数据结构的缓存效率</h4>
<ul>
<li>
<p>由于<strong>缓存的容量有限</strong> ，只能存储一小部分<strong>频繁访问的数据</strong> ，因此当CPU尝试访问的数据不在缓存中时，就会发生<strong>缓存未命中</strong> （cache miss），此时CPU不得不<strong>从速度较慢的内存中加载所需数据</strong></p>
</li>
<li>
<p><strong>缓存未命中</strong> 越少，CPU读写数据的效率就越高，将CPU 从缓存中成功获取数据的比例称为<strong>缓存命中率</strong> （cache hit rate），这个指标通常用来衡量缓存效率。</p>
</li>
<li>
<p>为了尽可能达到更高的效率，缓存会采取以下数据加载机制</p>
<ul>
<li><strong>缓存行</strong> ：缓存不是单个字节地存储与加载数据，而是<strong>以缓存行为单位</strong> 。相比于单个字节的传输，缓存行的传输形式<strong>更加高效</strong> 。</li>
<li><strong>预取机制</strong> ：处理器会尝试<strong>预测数据访问模式</strong> （例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。</li>
<li><strong>空间局部性</strong> ：如果一个数据被访问，那么它<strong>附近的数据</strong> 可能近期也会被访问。因此，缓存在加载某一数据时，也会<strong>加载其附近的数据</strong> ，以提高命中率。</li>
<li><strong>时间局部性</strong> ：如果一个数据被访问，那么它<strong>在不久的将来很可能再次被访问</strong> 。缓存利用这一原理，通过<strong>保留最近访问过的数据</strong> 来提高命中率</li>
</ul>
</li>
<li>
<p>数组和链表对缓存的利用效率是不同的：</p>
<ul>
<li><strong>占用空间</strong> ：<strong>链表元素</strong> 比数组元素<strong>占用空间更多</strong> ，导致缓存中<strong>容纳的有效数据量更少</strong> 。</li>
<li><strong>缓存行</strong> ：链表数据<strong>分散</strong> 在内存各处，而缓存是<strong>按行加载</strong> 的，因此<strong>加载到无效数据</strong> 的比例更高。</li>
<li><strong>预取机制</strong> ：<strong>数组</strong> 比链表的数据访问模式更具<strong>可预测性</strong> ，即系统更容易猜出即将被加载的数据。</li>
<li><strong>空间局部性</strong> ：数组被存储在<strong>集中</strong> 的内存空间中，因此被加载数据<strong>附近的数据</strong> 更有可能即将被访问</li>
</ul>
</li>
<li>
<p>总体而言，<strong>数组具有更高的缓存命中率，因此它在操作效率上通常优于链表</strong> 。</p>
</li>
</ul>
<h2 id="5-栈与队列">5.栈与队列</h2>
<h3 id="1-栈">1.栈</h3>
<ul>
<li>
<p><strong>栈</strong> （stack）是一种遵循<strong>先入后出</strong> 逻辑的线性数据结构。</p>
</li>
<li>
<p>可以将栈类比为桌面上的一摞盘子，如果想取出底部的盘子，则需要先将上面的盘子依次移走。</p>
</li>
<li>
<p>将把元素<strong>添加到栈顶</strong> 的操作叫作<strong>入栈</strong> ，<strong>删除栈顶元素</strong> 的操作叫作<strong>出栈</strong> 。</p>
</li>
</ul>
<h4 id="1-栈的常用操作">1.栈的常用操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>push()</td>
<td>元素入栈（添加至栈顶）</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>pop()</td>
<td>栈顶元素出栈</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>peek()</td>
<td>访问栈顶元素</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<p># 不同语言的方法名不一定相同</p>
<p># 通常情况下，可以直接使用编程语言内置的栈类，但是，c语言没有提供</p>
<p># 可以将c语言的数组或者链表当作栈来使用，并在程序逻辑上忽略与栈无关的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> stack.isEmpty();</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化栈</span></span><br><span class="line"><span class="comment"># Python 没有内置的栈类，可以把 list 当作栈来使用</span></span><br><span class="line">stack: <span class="built_in">list</span>[<span class="built_in">int</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入栈</span></span><br><span class="line">stack.append(<span class="number">1</span>)</span><br><span class="line">stack.append(<span class="number">3</span>)</span><br><span class="line">stack.append(<span class="number">2</span>)</span><br><span class="line">stack.append(<span class="number">5</span>)</span><br><span class="line">stack.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问栈顶元素</span></span><br><span class="line">peek: <span class="built_in">int</span> = stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出栈</span></span><br><span class="line">pop: <span class="built_in">int</span> = stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取栈的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(stack)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-栈的实现">2.栈的实现</h4>
<ul>
<li>遵循栈先入后出的原则，只能在栈顶添加删除元素，但数组和链表可以在任意位置添加删除元素</li>
<li>可以将栈视为一种受限制的数组或链表</li>
</ul>
<h5 id="1-基于链表的实现">1.基于链表的实现</h5>
<ul>
<li>将链表的头节点视为栈顶，尾节点视为栈底</li>
<li>对于入栈操作，只需在链表头部插入元素即可，这种节点插入方法被称为<strong>头插法</strong></li>
<li>对于出栈操作，只需将头节点从链表中删除即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的栈 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ListNode *top; <span class="comment">// 将头节点作为栈顶</span></span><br><span class="line">	<span class="type">int</span> size; <span class="comment">// 栈的长度</span></span><br><span class="line">&#125; LinkedListStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">LinkedListStack *<span class="title function_">newLinkedListStack</span><span class="params">()</span> &#123;</span><br><span class="line">	LinkedListStack *s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedListStack));</span><br><span class="line">	s-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delLinkedListStack</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (s-&gt;top) &#123;</span><br><span class="line">		ListNode *n = s-&gt;top-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(s-&gt;top);</span><br><span class="line">		s-&gt;top = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> size(s) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkedListStack *s, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	ListNode *node = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	node-&gt;next = s-&gt;top; <span class="comment">// 更新新加节点指针域</span></span><br><span class="line">	node-&gt;val = num; <span class="comment">// 更新新加节点数据域</span></span><br><span class="line">	s-&gt;top = node; <span class="comment">// 更新栈顶</span></span><br><span class="line">	s-&gt;size++; <span class="comment">// 更新栈大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 栈为空\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s-&gt;top-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">	<span class="type">int</span> val = peek(s);</span><br><span class="line">	ListNode *tmp = s-&gt;top;</span><br><span class="line">	s-&gt;top = s-&gt;top-&gt;next;</span><br><span class="line">	<span class="comment">// 释放内存</span></span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">	s-&gt;size--;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-基于数组的实现">2.基于数组的实现</h5>
<ul>
<li>将数组尾部视为栈顶，入栈和出栈分别对应在数组尾部添加和删除元素</li>
<li>由于入栈的元素可能会一致增加，所以使用动态数组，不需要再去处理数组扩容的问题</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于数组实现的栈 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> *data;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125; ArrayStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">ArrayStack *<span class="title function_">newArrayStack</span><span class="params">()</span> &#123;</span><br><span class="line">	ArrayStack *<span class="built_in">stack</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayStack));</span><br><span class="line">	<span class="comment">// 初始化一个大容量，避免扩容</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * MAX_SIZE);</span><br><span class="line">	<span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delArrayStack</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(ArrayStack *<span class="built_in">stack</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;size == MAX_SIZE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 栈已满\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;size] = num;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 栈为空\n&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> val = peek(<span class="built_in">stack</span>);</span><br><span class="line">	<span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># c语言中没有内置动态数组，所以仅使用一个大容量的数组来避免扩容问题</p>
<h5 id="3-两种实现的对比">3.两种实现的对比</h5>
<ul>
<li>
<p><strong>支持操作</strong></p>
<ul>
<li>两种实现都支持栈定义中的各项操作。<strong>数组</strong> 实现<strong>额外支持随机访问</strong> ，但这已超出了栈的定义范畴，因此一般不会用到。</li>
</ul>
</li>
<li>
<p><strong>时间效率</strong></p>
<ul>
<li>在基于<strong>数组</strong> 的实现中，入栈和出栈操作都在预先分配好的连续内存中进行，具有很好的<strong>缓存本地性</strong> ，因此<strong>效率较高</strong> 。然而，如果<strong>入栈时超出数组容量</strong> ，会<strong>触发扩容机制</strong> ，导致该次<strong>入栈操作的时间复杂度变为𝑂(𝑛)</strong> 。</li>
<li>在基于<strong>链表</strong> 的实现中，链表的<strong>扩容非常灵活</strong> ，不存在上述数组扩容时效率降低的问题。但是，<strong>入栈</strong> 操作<strong>需要初始化节点对象并修改指针</strong> ，因此效率相对较低。不过，<strong>如果入栈元素本身就是节点对象，那么可以省去初始化步骤</strong> ，从而提高效率。</li>
<li>综上所述，当入栈与出栈操作的元素是基本数据类型时，例如 int 或 double ，我们可以得出以下结论
<ul>
<li>基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此<strong>平均效率更高</strong> 。</li>
<li>基于链表实现的栈可以提供<strong>更加稳定</strong> 的效率表现。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>空间效率</strong></p>
<ul>
<li>在初始化列表时，系统会为列表分配<strong>初始容量</strong> ，该容量可能<strong>超出实际需求</strong> ；并且，扩容机制通常是按照特定倍率（例如 2 倍）进行扩容的，<strong>扩容后的容量</strong> 也可能<strong>超出实际需求</strong> 。因此，<strong>基于数组实现的栈可能造成一定的空间浪费</strong>。</li>
<li>然而，由于链表节点需要额外存储指针，<strong>因此链表节点占用的空间相对较大</strong>。</li>
<li>综上，我们不能简单地确定哪种实现更加节省内存，需要针对具体情况进行分析。</li>
</ul>
</li>
</ul>
<h5 id="4-栈的典型应用">4.栈的典型应用</h5>
<ul>
<li><strong>浏览器中的后退与前进、软件中的撤销与反撤销</strong> 。每当打开新的网页，浏览器就会对上一个网页执行入栈，这样我们就可以通过后退操作回到上一个网页。<strong>后退</strong> 操作实际上是在执行<strong>出栈</strong> 。如果要同时支持后退和前进，那么需要两个栈来配合实现。</li>
<li><strong>程序内存管理</strong> 。每次<strong>调用函数</strong> 时，系统都会在栈顶添加一个<strong>栈帧</strong> ，用于记录函数的<strong>上下文信息</strong> 。在递归函数中，<strong>向下递推</strong> 阶段会不断执行<strong>入栈</strong> 操作，而<strong>向上回溯</strong> 阶段则会不断执行<strong>出栈</strong> 操作</li>
</ul>
<h3 id="2-队列">2.队列</h3>
<ul>
<li><strong>队列</strong> （queue）是一种遵循<strong>先入先出</strong> 规则的线性数据结构</li>
<li>将队列头部称为<strong>队首</strong> ，尾部则称为<strong>队尾</strong> ，将元素加入<strong>队尾</strong> 的操作称为<strong>入队</strong> ，删除<strong>队首</strong> 元素则称为<strong>出队</strong></li>
</ul>
<h4 id="1-队列常用操作">1.队列常用操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>push()</td>
<td>元素入队（将元素添加到队尾）</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>pop()</td>
<td>队首元素出队</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>peek()</td>
<td>访问队首元素</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<p># 不同语言的方法名不一定相同</p>
<p># c语言未提供内置队列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化队列</span></span><br><span class="line"><span class="comment"># 在 Python 中，我们一般将双向队列类 deque 当作队列使用</span></span><br><span class="line"><span class="comment"># 虽然 queue.Queue() 是纯正的队列类，但不太好用，因此不推荐</span></span><br><span class="line">que: deque[<span class="built_in">int</span>] = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入队</span></span><br><span class="line">que.append(<span class="number">1</span>)</span><br><span class="line">que.append(<span class="number">3</span>)</span><br><span class="line">que.append(<span class="number">2</span>)</span><br><span class="line">que.append(<span class="number">5</span>)</span><br><span class="line">que.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问队首元素</span></span><br><span class="line">front: <span class="built_in">int</span> = que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出队</span></span><br><span class="line">pop: <span class="built_in">int</span> = que.popleft()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取队列的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(que)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断队列是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(que) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-队列的实现">2.队列的实现</h4>
<h5 id="1-基于链表的实现-2">1.基于链表的实现</h5>
<ul>
<li>将<strong>头节点</strong> 对应<strong>队首</strong> ，<strong>尾节点</strong> 对应<strong>队尾</strong> ，并且队尾只能添加节点，队首只能删除节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的队列 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ListNode *front, *rear;</span><br><span class="line">	<span class="type">int</span> queSize;</span><br><span class="line">&#125; LinkedListQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">LinkedListQueue *<span class="title function_">newLinkedListQueue</span><span class="params">()</span> &#123;</span><br><span class="line">	LinkedListQueue *<span class="built_in">queue</span> = (LinkedListQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedListQueue));</span><br><span class="line">	<span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;queSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">delLinkedListQueue</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 释放所有节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">queue</span>-&gt;front != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			ListNode *tmp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">			<span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放 queue 结构体</span></span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;queSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (size(<span class="built_in">queue</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="comment">// 尾节点处添加 node</span></span><br><span class="line">	ListNode *node = newListNode(num);</span><br><span class="line">	<span class="comment">// 如果队列为空，则令头、尾节点都指向该节点</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">queue</span>-&gt;front = node;</span><br><span class="line">		<span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果队列不为空，则将该节点添加到尾节点后</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">queue</span>-&gt;rear-&gt;next = node;</span><br><span class="line">		<span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;queSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	assert(size(<span class="built_in">queue</span>) &amp;&amp; <span class="built_in">queue</span>-&gt;front);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = peek(<span class="built_in">queue</span>);</span><br><span class="line">	ListNode *tmp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">	<span class="built_in">queue</span>-&gt;queSize--;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印队列 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinkedListQueue</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> *arr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="built_in">queue</span>-&gt;queSize);</span><br><span class="line">	<span class="comment">// 拷贝链表中的数据到数组</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	ListNode *node;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, node = <span class="built_in">queue</span>-&gt;front; i &lt; <span class="built_in">queue</span>-&gt;queSize; i++) &#123;</span><br><span class="line">		arr[i] = node-&gt;val;</span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printArray(arr, <span class="built_in">queue</span>-&gt;queSize);</span><br><span class="line">	<span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-基于数组的实现-2">2.基于数组的实现</h5>
<ul>
<li>
<p>在数组中删除首元素的时间复杂度为 𝑂(𝑛) ，这会导致出队操作效率较低。</p>
</li>
<li>
<p>所以可以用以下方法来解决</p>
</li>
<li>
<p>用一个变量front来指向<strong>队首</strong> 元素，再用一个变量size来记录<strong>队列的长度</strong> ，再定义一个rear=front+size，指向的结果就是队尾元素后的下一个位置</p>
</li>
<li>
<p>那么数组中包含元素的区间就是[front,rear-1]</p>
<ul>
<li>入队：将输入的元素赋值给rear计算出的索引，并且将size+1</li>
<li>出队：将front+1，size-1</li>
</ul>
</li>
<li>
<p>这样就可以将时间复杂度降为 𝑂(1)</p>
</li>
<li>
<p>但是上面入队和出队操作中front和rear都在不断增加，即<strong>向右移动</strong> ，如果到达了队尾就无法再移动了</p>
</li>
<li>
<p>所以可以将数组视为首尾相接的<strong>环形数组</strong></p>
</li>
<li>
<p>即当front和rear将要越过数组的尾部时，通过取余操作，使其回到数组的头部继续遍历</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于环形数组实现的队列 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> *nums; <span class="comment">// 用于存储队列元素的数组</span></span><br><span class="line">	<span class="type">int</span> front; <span class="comment">// 队首指针，指向队首元素</span></span><br><span class="line">	<span class="type">int</span> queSize; <span class="comment">// 尾指针，指向队尾 + 1</span></span><br><span class="line">	<span class="type">int</span> queCapacity; <span class="comment">// 队列容量</span></span><br><span class="line">&#125; ArrayQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">ArrayQueue *<span class="title function_">newArrayQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">	ArrayQueue *<span class="built_in">queue</span> = (ArrayQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayQueue));</span><br><span class="line">	<span class="comment">// 初始化数组</span></span><br><span class="line">	<span class="built_in">queue</span>-&gt;queCapacity = capacity;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;nums = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="built_in">queue</span>-&gt;queCapacity);</span><br><span class="line">	<span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;queSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delArrayQueue</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;nums);</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的容量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">capacity</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;queCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;queSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;queSize == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	assert(size(<span class="built_in">queue</span>) != <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;nums[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (size(<span class="built_in">queue</span>) == capacity(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 队列已满\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算队尾指针，指向队尾索引 + 1</span></span><br><span class="line">	<span class="comment">// 通过取余操作实现 rear 越过数组尾部后回到头部</span></span><br><span class="line">	<span class="type">int</span> rear = (<span class="built_in">queue</span>-&gt;front + <span class="built_in">queue</span>-&gt;queSize) % <span class="built_in">queue</span>-&gt;queCapacity;</span><br><span class="line">	<span class="comment">// 将 num 添加至队尾</span></span><br><span class="line">	<span class="built_in">queue</span>-&gt;nums[rear] = num;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;queSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = peek(<span class="built_in">queue</span>);</span><br><span class="line">	<span class="comment">// 队首指针向后移动一位，若越过尾部，则返回到数组头部</span></span><br><span class="line">	<span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;queCapacity;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;queSize--;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">toArray</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>, <span class="type">int</span> *queSize)</span> &#123;</span><br><span class="line">	*queSize = <span class="built_in">queue</span>-&gt;queSize;</span><br><span class="line">	<span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="built_in">queue</span>-&gt;queSize, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>-&gt;queSize; i++) &#123;</span><br><span class="line">		res[i] = <span class="built_in">queue</span>-&gt;nums[j % <span class="built_in">queue</span>-&gt;queCapacity];</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 这样的队列仍然会受限于数组长度不可变的问题，所以可以再将数组替换为动态数组，加入扩容机制</p>
<h5 id="3-队列的典型应用">3.队列的典型应用</h5>
<ul>
<li><strong>淘宝订单</strong> 。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。</li>
<li><strong>各类待办事项</strong> 。任何需要实现<strong>先来后到</strong> 功能的场景，例如<strong>打印机的任务队列</strong> 、<strong>餐厅的出餐队列</strong> 等，队列在这些场景中可以有效地维护<strong>处理顺序</strong> 。</li>
</ul>
<h3 id="3-双向队列">3.双向队列</h3>
<ul>
<li><strong>双向队列</strong> （double‑ended queue）提供了更高的灵活性，<strong>允许在头部和尾部执行元素的添加或删除操作</strong>。</li>
</ul>
<h4 id="1-双向队列的常用操作">1.双向队列的常用操作</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>push_first()</td>
<td>将元素添加至队首</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>push_last()</td>
<td>将元素添加至队尾</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>pop_first()</td>
<td>删除队首元素</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>pop_last()</td>
<td>删除队尾元素</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>peek_first()</td>
<td>访问队首元素</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>peek_last()</td>
<td>访问队尾元素</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<p># 不同编程语言的方法名不一定相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化双向队列</span></span><br><span class="line">deq: deque[<span class="built_in">int</span>] = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入队</span></span><br><span class="line">deq.append(<span class="number">2</span>) <span class="comment"># 添加至队尾</span></span><br><span class="line">deq.append(<span class="number">5</span>)</span><br><span class="line">deq.append(<span class="number">4</span>)</span><br><span class="line">deq.appendleft(<span class="number">3</span>) <span class="comment"># 添加至队首</span></span><br><span class="line">deq.appendleft(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line">front: <span class="built_in">int</span> = deq[<span class="number">0</span>] <span class="comment"># 队首元素</span></span><br><span class="line">rear: <span class="built_in">int</span> = deq[-<span class="number">1</span>] <span class="comment"># 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出队</span></span><br><span class="line">pop_front: <span class="built_in">int</span> = deq.popleft() <span class="comment"># 队首元素出队</span></span><br><span class="line">pop_rear: <span class="built_in">int</span> = deq.pop() <span class="comment"># 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取双向队列的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(deq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断双向队列是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(deq) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-双向队列实现">2.双向队列实现</h4>
<h5 id="1-基于双向链表的实现">1.基于双向链表的实现</h5>
<ul>
<li>双向链表的头节点和尾节点都可以视为队首和队尾，可以在两端添加和删除节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoublyListNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DoublyListNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后继节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DoublyListNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前驱节点</span></span><br><span class="line">&#125; DoublyListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">DoublyListNode *<span class="title function_">newDoublyListNode</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">	DoublyListNode *new = (DoublyListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoublyListNode));</span><br><span class="line">	new-&gt;val = num;</span><br><span class="line">	new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	new-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delDoublyListNode</span><span class="params">(DoublyListNode *node)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于双向链表实现的双向队列 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	DoublyListNode *front, *rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">	<span class="type">int</span> queSize; <span class="comment">// 双向队列的长度</span></span><br><span class="line">&#125; LinkedListDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">LinkedListDeque *<span class="title function_">newLinkedListDeque</span><span class="params">()</span> &#123;</span><br><span class="line">	LinkedListDeque *<span class="built_in">deque</span> = (LinkedListDeque *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedListDeque));</span><br><span class="line">	<span class="built_in">deque</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delLinkedListdeque</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 释放所有节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">deque</span>-&gt;queSize &amp;&amp; <span class="built_in">deque</span>-&gt;front != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		DoublyListNode *tmp = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">		<span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;front-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放 deque 结构体</span></span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">deque</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;queSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (size(<span class="built_in">deque</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>, <span class="type">int</span> num, <span class="type">bool</span> isFront)</span> &#123;</span><br><span class="line">	DoublyListNode *node = newDoublyListNode(num);</span><br><span class="line">	<span class="comment">// 若链表为空，则令 front 和 rear 都指向 node</span></span><br><span class="line">	<span class="keyword">if</span> (empty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">		<span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 队首入队操作</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">		<span class="comment">// 将 node 添加至链表头部</span></span><br><span class="line">		<span class="built_in">deque</span>-&gt;front-&gt;prev = node;</span><br><span class="line">		node-&gt;next = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">		<span class="built_in">deque</span>-&gt;front = node; <span class="comment">// 更新头节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 队尾入队操作</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 将 node 添加至链表尾部</span></span><br><span class="line">		<span class="built_in">deque</span>-&gt;rear-&gt;next = node;</span><br><span class="line">		node-&gt;prev = <span class="built_in">deque</span>-&gt;rear;</span><br><span class="line">		<span class="built_in">deque</span>-&gt;rear = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize++; <span class="comment">// 更新队列长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队首入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushFirst</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	push(<span class="built_in">deque</span>, num, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队尾入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushLast</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	push(<span class="built_in">deque</span>, num, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekFirst</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	assert(size(<span class="built_in">deque</span>) &amp;&amp; <span class="built_in">deque</span>-&gt;front);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;front-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队尾元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekLast</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	assert(size(<span class="built_in">deque</span>) &amp;&amp; <span class="built_in">deque</span>-&gt;rear);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;rear-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>, <span class="type">bool</span> isFront)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (empty(<span class="built_in">deque</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="comment">// 队首出队操作</span></span><br><span class="line">	<span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">		val = peekFirst(<span class="built_in">deque</span>); <span class="comment">// 暂存头节点值</span></span><br><span class="line">		DoublyListNode *fNext = <span class="built_in">deque</span>-&gt;front-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (fNext) &#123;</span><br><span class="line">			fNext-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="built_in">deque</span>-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		delDoublyListNode(<span class="built_in">deque</span>-&gt;front);</span><br><span class="line">		<span class="built_in">deque</span>-&gt;front = fNext; <span class="comment">// 更新头节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 队尾出队操作</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		val = peekLast(<span class="built_in">deque</span>); <span class="comment">// 暂存尾节点值</span></span><br><span class="line">		DoublyListNode *rPrev = <span class="built_in">deque</span>-&gt;rear-&gt;prev;</span><br><span class="line">		<span class="keyword">if</span> (rPrev) &#123;</span><br><span class="line">			rPrev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="built_in">deque</span>-&gt;rear-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		delDoublyListNode(<span class="built_in">deque</span>-&gt;rear);</span><br><span class="line">		<span class="built_in">deque</span>-&gt;rear = rPrev; <span class="comment">// 更新尾节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize--; <span class="comment">// 更新队列长度</span></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队首出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">popFirst</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pop(<span class="built_in">deque</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队尾出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">popLast</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pop(<span class="built_in">deque</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印队列 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinkedListDeque</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> *arr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="built_in">deque</span>-&gt;queSize);</span><br><span class="line">	<span class="comment">// 拷贝链表中的数据到数组</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	DoublyListNode *node;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, node = <span class="built_in">deque</span>-&gt;front; i &lt; <span class="built_in">deque</span>-&gt;queSize; i++) &#123;</span><br><span class="line">		arr[i] = node-&gt;val;</span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printArray(arr, <span class="built_in">deque</span>-&gt;queSize);</span><br><span class="line">	<span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-基于数组的实现-3">2.基于数组的实现</h5>
<ul>
<li>用环形数组来实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于环形数组实现的双向队列 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> *nums; <span class="comment">// 用于存储队列元素的数组</span></span><br><span class="line">	<span class="type">int</span> front; <span class="comment">// 队首指针，指向队首元素</span></span><br><span class="line">	<span class="type">int</span> queSize; <span class="comment">// 尾指针，指向队尾 + 1</span></span><br><span class="line">	<span class="type">int</span> queCapacity; <span class="comment">// 队列容量</span></span><br><span class="line">&#125; ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">ArrayDeque *<span class="title function_">newArrayDeque</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">	ArrayDeque *<span class="built_in">deque</span> = (ArrayDeque *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayDeque));</span><br><span class="line">	<span class="comment">// 初始化数组</span></span><br><span class="line">	<span class="built_in">deque</span>-&gt;queCapacity = capacity;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;nums = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="built_in">deque</span>-&gt;queCapacity);</span><br><span class="line">	<span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;queSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delArrayDeque</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">deque</span>-&gt;nums);</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">deque</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的容量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">capacity</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;queCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;queSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;queSize == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算环形数组索引 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeIndex</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="comment">// 通过取余操作实现数组首尾相连</span></span><br><span class="line">	<span class="comment">// 当 i 越过数组尾部时，回到头部</span></span><br><span class="line">	<span class="comment">// 当 i 越过数组头部后，回到尾部</span></span><br><span class="line">	<span class="keyword">return</span> ((i + capacity(<span class="built_in">deque</span>)) % capacity(<span class="built_in">deque</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队首入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushFirst</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;queSize == capacity(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 双向队列已满\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 队首指针向左移动一位</span></span><br><span class="line">	<span class="comment">// 通过取余操作实现 front 越过数组头部回到尾部</span></span><br><span class="line">	<span class="built_in">deque</span>-&gt;front = dequeIndex(<span class="built_in">deque</span>, <span class="built_in">deque</span>-&gt;front - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 将 num 添加到队首</span></span><br><span class="line">	<span class="built_in">deque</span>-&gt;nums[<span class="built_in">deque</span>-&gt;front] = num;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队尾入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushLast</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;queSize == capacity(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 双向队列已满\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算队尾指针，指向队尾索引 + 1</span></span><br><span class="line">	<span class="type">int</span> rear = dequeIndex(<span class="built_in">deque</span>, <span class="built_in">deque</span>-&gt;front + <span class="built_in">deque</span>-&gt;queSize);</span><br><span class="line">	<span class="comment">// 将 num 添加至队尾</span></span><br><span class="line">	<span class="built_in">deque</span>-&gt;nums[rear] = num;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekFirst</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 访问异常：双向队列为空</span></span><br><span class="line">	assert(empty(<span class="built_in">deque</span>) == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;nums[<span class="built_in">deque</span>-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队尾元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekLast</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 访问异常：双向队列为空</span></span><br><span class="line">	assert(empty(<span class="built_in">deque</span>) == <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> last = dequeIndex(<span class="built_in">deque</span>, <span class="built_in">deque</span>-&gt;front + <span class="built_in">deque</span>-&gt;queSize - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;nums[last];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队首出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">popFirst</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = peekFirst(<span class="built_in">deque</span>);</span><br><span class="line">	<span class="comment">// 队首指针向后移动一位</span></span><br><span class="line">	<span class="built_in">deque</span>-&gt;front = dequeIndex(<span class="built_in">deque</span>, <span class="built_in">deque</span>-&gt;front + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize--;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队尾出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">popLast</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = peekLast(<span class="built_in">deque</span>);</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize--;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">toArray</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>, <span class="type">int</span> *queSize)</span> &#123;</span><br><span class="line">	*queSize = <span class="built_in">deque</span>-&gt;queSize;</span><br><span class="line">	<span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="built_in">deque</span>-&gt;queSize, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">deque</span>-&gt;queSize; i++) &#123;</span><br><span class="line">		res[i] = <span class="built_in">deque</span>-&gt;nums[j % <span class="built_in">deque</span>-&gt;queCapacity];</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-双向队列的应用">3.双向队列的应用</h5>
<ul>
<li>
<p>双向队列兼具了栈和队列的逻辑，因此它可以实现这两者的所有应用场景，同时提供更高的自由度</p>
</li>
<li>
<p>例如：因为软件限制只能撤销最多50步，（撤销功能就需要栈来实现）当栈中存储超过50步的内容时，所以在长度超过50的时候要<strong>将队首删除</strong> ，（这就需要队列的功能）也就是将50步以前的删除掉，减少占用过多的内存</p>
</li>
<li>
<p>双向队列相当于是给这个栈设置了最大容量</p>
</li>
</ul>
<h2 id="6-哈希表">6.哈希表</h2>
<h3 id="1-哈希表">1.哈希表</h3>
<ul>
<li>
<p><strong>哈希表</strong> （hash table），又称<strong>散列表</strong> ，它通过建立<strong>键key</strong> 与<strong>值value</strong> 之间的<strong>映射</strong> ，实现高效的元素查询。</p>
</li>
<li>
<p>效率对比</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>链表</th>
<th>哈希表</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(𝑛)</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>添加元素</td>
<td>𝑂(1)</td>
<td>𝑂(1)</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>删除元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(𝑛)</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<h4 id="1-哈希表常用操作">1.哈希表常用操作</h4>
<p># c语言没有提供内置哈希表</p>
<ul>
<li>哈希表的常见操作：初始化，查询操作，添加键值对，删除键值对</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化哈希表</span></span><br><span class="line">hmap: <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加操作</span></span><br><span class="line"><span class="comment"># 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">hmap[<span class="number">12836</span>] = <span class="string">&quot; 小哈&quot;</span></span><br><span class="line">hmap[<span class="number">15937</span>] = <span class="string">&quot; 小啰&quot;</span></span><br><span class="line">hmap[<span class="number">16750</span>] = <span class="string">&quot; 小算&quot;</span></span><br><span class="line">hmap[<span class="number">13276</span>] = <span class="string">&quot; 小法&quot;</span></span><br><span class="line">hmap[<span class="number">10583</span>] = <span class="string">&quot; 小鸭&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询操作</span></span><br><span class="line"><span class="comment"># 向哈希表中输入键 key ，得到值 value</span></span><br><span class="line">name: <span class="built_in">str</span> = hmap[<span class="number">15937</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除操作</span></span><br><span class="line"><span class="comment"># 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">hmap.pop(<span class="number">10583</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>常用的遍历方式：遍历键值对，遍历键，遍历值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历哈希表</span></span><br><span class="line"><span class="comment"># 遍历键值对 key-&gt;value</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> hmap.items():</span><br><span class="line">	<span class="built_in">print</span>(key, <span class="string">&quot;-&gt;&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单独遍历键 key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> hmap.keys():</span><br><span class="line">	<span class="built_in">print</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单独遍历值 value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> hmap.values():</span><br><span class="line">	<span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<h4 id="2-哈希表简单实现">2.哈希表简单实现</h4>
<ul>
<li>
<p>考虑最简单的情况，仅用一个<strong>数组来实现哈希表</strong></p>
</li>
<li>
<p>将数组的每个空位称为<strong>桶</strong> ，每个桶中存储一个键值对</p>
</li>
<li>
<p>查询操作就是找到<strong>key对应的桶</strong> ，再在桶中获取<strong>value</strong></p>
</li>
<li>
<p><strong>哈希函数</strong> （hash function）可以通过key来定位到对应的桶</p>
</li>
<li>
<p>此函数可以将一个较大的输入空间映射到一个较小的输出空间</p>
</li>
<li>
<p>即将所有key映射到所有桶（数组索引）</p>
</li>
<li>
<p>哈希函数的计算分为两步：</p>
<ul>
<li>通过哈希算法hash（）计算得到哈希值</li>
<li>将哈希值对桶数量（数组长度）capacity取模，从而获取该key对应的数组索引index</li>
<li>index = hash(key) % capacity</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>:</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 键值对&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">		<span class="variable language_">self</span>.key = key</span><br><span class="line">		<span class="variable language_">self</span>.val = val</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayHashMap</span>:</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 基于数组实现的哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 构造方法&quot;&quot;&quot;</span></span><br><span class="line">	<span class="comment"># 初始化数组，包含 100 个桶</span></span><br><span class="line">	<span class="variable language_">self</span>.buckets: <span class="built_in">list</span>[Pair | <span class="literal">None</span>] = [<span class="literal">None</span>] * <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 哈希函数&quot;&quot;&quot;</span></span><br><span class="line">		index = key % <span class="number">100</span></span><br><span class="line">		<span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 查询操作&quot;&quot;&quot;</span></span><br><span class="line">		index: <span class="built_in">int</span> = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		pair: Pair = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">		<span class="keyword">if</span> pair <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">		<span class="keyword">return</span> pair.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 添加操作&quot;&quot;&quot;</span></span><br><span class="line">		pair = Pair(key, val)</span><br><span class="line">		index: <span class="built_in">int</span> = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		<span class="variable language_">self</span>.buckets[index] = pair</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 删除操作&quot;&quot;&quot;</span></span><br><span class="line">		index: <span class="built_in">int</span> = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		<span class="comment"># 置为 None ，代表删除</span></span><br><span class="line">		<span class="variable language_">self</span>.buckets[index] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">entry_set</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[Pair]:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 获取所有键值对&quot;&quot;&quot;</span></span><br><span class="line">		result: <span class="built_in">list</span>[Pair] = []</span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">			<span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">				result.append(pair)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">key_set</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 获取所有键&quot;&quot;&quot;</span></span><br><span class="line">	result = []</span><br><span class="line">	<span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">		<span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">			result.append(pair.key)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">value_set</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">str</span>]:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 获取所有值&quot;&quot;&quot;</span></span><br><span class="line">		result = []</span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">			<span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">             result.append(pair.val)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">			<span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">				<span class="built_in">print</span>(pair.key, <span class="string">&quot;-&gt;&quot;</span>, pair.val)</span><br></pre></td></tr></table></figure>
<p># 这里设置数组长度 capacity = 100、哈希算法 hash(key) = key ，易得哈希函数为 key % 100</p>
<h4 id="3-哈希冲突与扩容">3.哈希冲突与扩容</h4>
<ul>
<li>
<p>哈希函数可以将一个<strong>较大的</strong> 输入空间映射到一个<strong>较小的</strong> 输出空间</p>
</li>
<li>
<p>所以理论上必定会存在重复的现象</p>
</li>
<li>
<p>即多个输入对应一个输出</p>
</li>
<li>
<p>将这种多个输入对应同一输出的情况称为<strong>哈希冲突</strong> （hash collision）</p>
</li>
<li>
<p>扩容哈希表（数组）可以降低哈希冲突的概率</p>
</li>
<li>
<p>但是扩容就需要用到数组的迁移，所以在一开始就要给哈希表留足够大的容量，防止频繁扩容</p>
</li>
<li>
<p><strong>负载因子</strong> （load factor）是哈希表的一个重要概念，其定义为哈希表的<strong>元素数量除以桶数量</strong> ，用于衡量哈希冲突的<strong>严重程度</strong> ，也常作为<strong>哈希表扩容的触发条件</strong> 。</p>
</li>
<li>
<p>例如在 Java 中，当负载因子超过0.75时，系统会将哈希表扩容至原先的2倍。</p>
</li>
</ul>
<h3 id="2-哈希冲突">2.哈希冲突</h3>
<ul>
<li>理论上哈希冲突是不可避免的</li>
<li>可以通过一直扩容直到哈希冲突消失，但是效率过低</li>
<li>可以采取两种策略
<ul>
<li>改良哈希表的数据结构，使得哈希表可以在出现哈希冲突的时候正常工作</li>
<li>仅在哈希冲突严重的时候才执行扩容操作</li>
</ul>
</li>
</ul>
<h4 id="1-链式地址">1.链式地址</h4>
<ul>
<li>
<p>在原始哈希表中，每个桶仅能存储一个键值对。<strong>链式地址</strong> （separate chaining）<strong>将单个元素转换为链表</strong> ，将键值对作为链表节点，将<strong>所有发生冲突的键值对都存储在同一链表</strong> 中</p>
</li>
<li>
<p>是一个<strong>索引对应数组元素</strong> ，<strong>数组元素再对应一个链表</strong> 的结构</p>
</li>
<li>
<p>其操作方式也就发生了改变</p>
<ul>
<li><strong>查询元素</strong>：输入key，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比key以查找目标键值对。</li>
<li><strong>添加元素</strong>：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。</li>
<li><strong>删除元素</strong>：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。</li>
</ul>
</li>
<li>
<p>因此也就存在了局限性</p>
<ul>
<li><strong>占用空间增大</strong>：链表包含节点指针，它相比数组更加耗费内存空间。</li>
<li><strong>查询效率降低</strong>：因为需要线性遍历链表来查找对应元素。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span>:</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 链式地址哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 构造方法&quot;&quot;&quot;</span></span><br><span class="line">		<span class="variable language_">self</span>.size = <span class="number">0</span> <span class="comment"># 键值对数量</span></span><br><span class="line">		<span class="variable language_">self</span>.capacity = <span class="number">4</span> <span class="comment"># 哈希表容量</span></span><br><span class="line">		<span class="variable language_">self</span>.load_thres = <span class="number">2.0</span> / <span class="number">3.0</span> <span class="comment"># 触发扩容的负载因子阈值</span></span><br><span class="line">		<span class="variable language_">self</span>.extend_ratio = <span class="number">2</span> <span class="comment"># 扩容倍数</span></span><br><span class="line">		<span class="variable language_">self</span>.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.capacity)] <span class="comment"># 桶数组</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 哈希函数&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">return</span> key % <span class="variable language_">self</span>.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_factor</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 负载因子&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">self</span>.size / <span class="variable language_">self</span>.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span> | <span class="literal">None</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 查询操作&quot;&quot;&quot;</span></span><br><span class="line">		index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		bucket = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">		<span class="comment"># 遍历桶，若找到 key ，则返回对应 val</span></span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">			<span class="keyword">if</span> pair.key == key:</span><br><span class="line">				<span class="keyword">return</span> pair.val</span><br><span class="line">		<span class="comment"># 若未找到 key ，则返回 None</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 添加操作&quot;&quot;&quot;</span></span><br><span class="line">		<span class="comment"># 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">		<span class="keyword">if</span> <span class="variable language_">self</span>.load_factor() &gt; <span class="variable language_">self</span>.load_thres:</span><br><span class="line">			<span class="variable language_">self</span>.extend()</span><br><span class="line">		index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		bucket = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">		<span class="comment"># 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">			<span class="keyword">if</span> pair.key == key:</span><br><span class="line">				pair.val = val</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">		<span class="comment"># 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">		pair = Pair(key, val)</span><br><span class="line">		bucket.append(pair)</span><br><span class="line">		<span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 删除操作&quot;&quot;&quot;</span></span><br><span class="line">		index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		bucket = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">		<span class="comment"># 遍历桶，从中删除键值对</span></span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">			<span class="keyword">if</span> pair.key == key:</span><br><span class="line">				bucket.remove(pair)</span><br><span class="line">				<span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 扩容哈希表&quot;&quot;&quot;</span></span><br><span class="line">		<span class="comment"># 暂存原哈希表</span></span><br><span class="line">		buckets = <span class="variable language_">self</span>.buckets</span><br><span class="line">		<span class="comment"># 初始化扩容后的新哈希表</span></span><br><span class="line">		<span class="variable language_">self</span>.capacity *= <span class="variable language_">self</span>.extend_ratio</span><br><span class="line">		<span class="variable language_">self</span>.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.capacity)]</span><br><span class="line">		<span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line">		<span class="comment"># 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">		<span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">			<span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">				<span class="variable language_">self</span>.put(pair.key, pair.val)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> bucket <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">		res = []</span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">			res.append(<span class="built_in">str</span>(pair.key) + <span class="string">&quot; -&gt; &quot;</span> + pair.val)</span><br><span class="line">		<span class="built_in">print</span>(res)                </span><br></pre></td></tr></table></figure>
<p># 使用列表（动态数组）代替链表，从而简化代码。在这种设定下，哈希表（数组）包含多个桶，每个桶都是一个列表。</p>
<p># 这里实现包含哈希表扩容方法。当负载因子超过 2/3 时，将哈希表扩容至原先的 2 倍。</p>
<p># 当链表很长时，查询效率 𝑂(𝑛) 很差。此时可以将链表转换为<strong>AVL 树</strong> 或<strong>红黑树</strong> ，从而将查询操作的时间复杂度优化至 𝑂(log 𝑛) 。</p>
<h4 id="2-开放寻址">2.开放寻址</h4>
<ul>
<li><strong>开放寻址</strong> （open addressing）不引入额外的数据结构，而是通过<strong>多次探测</strong> 来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。</li>
<li><strong>开放</strong> ：即是所有键值对都存储在数组内，而不是数组元素对应的链表</li>
<li><strong>寻址</strong> ：哈希冲突时，按照预定规则，寻址下一个可用的空位置</li>
</ul>
<h5 id="1-线性探测">1.线性探测</h5>
<ul>
<li>
<p>采用固定步长的线性搜索来探测</p>
</li>
<li>
<p>其操作方法与普通哈希表有所不同</p>
<ul>
<li><strong>插入元素</strong> ：通过哈希函数计算桶索引，若发现桶内已有元素（即发生哈希冲突），则从冲突位置向后线性遍历，步长通常为1 ，直至找到空桶，将元素插入其中。
<ul>
<li>所以其插入的一定是第一个空桶，所以下面查找时，遇到第一个空桶，即元素不在表中</li>
<li>因此也导致下面的聚集问题</li>
</ul>
</li>
<li><strong>查找元素</strong> ：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。
<ul>
<li>元素查找时，如果不在其初始的位置，那么就是发生了哈希冲突导致其插入时向后找可用的第一个空桶，查找时是从初始位置开始一直到第一个空桶，因为元素只有可能在这个区间内（直接删除元素的情况除外）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>线性探测容易产生<strong>聚集现象</strong> 。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成<strong>恶性循环</strong> ，最终导致增删查改操作效率劣化。</p>
</li>
<li>
<p>不能在开放寻址哈希表中直接删除元素。这是因为删除元素会在数组内产生一个空桶None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在</p>
</li>
<li>
<p>为了解决该问题，可以采用<strong>懒删除</strong> （lazy deletion）机制：它不直接从哈希表中移除元素，而是利用一个常量 <strong>Tombstone/Deleted来标记</strong>这个桶。在该机制下，None和Tombstone/Deleted都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。</p>
</li>
<li>
<p>但是，懒删除可能会加速哈希表的<strong>性能退化</strong> 。这是因为每次删除操作都会产生一个删除标记，随着 Tombstone/Deleted的增加，搜索时间也会增加，因为线性探测可能需要跳过多个Tombstone/Deleted才能找到目标元素。</p>
</li>
<li>
<p>在线性探测中记录遇到的首个Tombstone/Deleted的索引，并将搜索到的目标元素与该Tombstone/Deleted<strong>交换位置</strong> 。这样做的好处是当每次查询或添加元素时，元素会被移动至<strong>距离理想位置（探测起始点）更近的桶</strong> ，从而优化查询效率。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 开放寻址哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span> <span class="comment"># 键值对数量</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity = <span class="number">4</span> <span class="comment"># 哈希表容量</span></span><br><span class="line">        <span class="variable language_">self</span>.load_thres = <span class="number">2.0</span> / <span class="number">3.0</span> <span class="comment"># 触发扩容的负载因子阈值</span></span><br><span class="line">        <span class="variable language_">self</span>.extend_ratio = <span class="number">2</span> <span class="comment"># 扩容倍数</span></span><br><span class="line">        <span class="variable language_">self</span>.buckets: <span class="built_in">list</span>[Pair | <span class="literal">None</span>] = [<span class="literal">None</span>] * <span class="variable language_">self</span>.capacity <span class="comment"># 桶数组</span></span><br><span class="line">        <span class="variable language_">self</span>.TOMBSTONE = Pair(-<span class="number">1</span>, <span class="string">&quot;-1&quot;</span>) <span class="comment"># 删除标记</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 哈希函数&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">return</span> key % <span class="variable language_">self</span>.capacity</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">load_factor</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 负载因子&quot;&quot;&quot;</span></span><br><span class="line">   	    <span class="keyword">return</span> <span class="variable language_">self</span>.size / <span class="variable language_">self</span>.capacity</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_bucket</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; 搜索 key 对应的桶索引&quot;&quot;&quot;</span></span><br><span class="line">        index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">        first_tombstone = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 线性探测，当遇到空桶时跳出</span></span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 若遇到 key ，返回对应的桶索引</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index].key == key:</span><br><span class="line">                <span class="comment"># 若之前遇到了删除标记，则将键值对移动至该索引处</span></span><br><span class="line">                <span class="keyword">if</span> first_tombstone != -<span class="number">1</span>:</span><br><span class="line">                    <span class="variable language_">self</span>.buckets[first_tombstone] = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">                    <span class="variable language_">self</span>.buckets[index] = <span class="variable language_">self</span>.TOMBSTONE</span><br><span class="line">                    <span class="keyword">return</span> first_tombstone <span class="comment"># 返回移动后的桶索引</span></span><br><span class="line">                <span class="keyword">return</span> index <span class="comment"># 返回桶索引</span></span><br><span class="line">            <span class="comment"># 记录遇到的首个删除标记</span></span><br><span class="line">            <span class="keyword">if</span> first_tombstone == -<span class="number">1</span> <span class="keyword">and</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">is</span> <span class="variable language_">self</span>.TOMBSTONE:</span><br><span class="line">                first_tombstone = index</span><br><span class="line">                <span class="comment"># 计算桶索引，越过尾部则返回头部</span></span><br><span class="line">                index = (index + <span class="number">1</span>) % <span class="variable language_">self</span>.capacity</span><br><span class="line">			<span class="comment"># 若 key 不存在，则返回添加点的索引</span></span><br><span class="line">            <span class="keyword">return</span> index <span class="keyword">if</span> first_tombstone == -<span class="number">1</span> <span class="keyword">else</span> first_tombstone</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot; 查询操作&quot;&quot;&quot;</span></span><br><span class="line">   		    <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">            index = <span class="variable language_">self</span>.find_bucket(key)</span><br><span class="line">            <span class="comment"># 若找到键值对，则返回对应 val</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>.buckets[index].val</span><br><span class="line">            <span class="comment"># 若键值对不存在，则返回 None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot; 添加操作&quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.load_factor() &gt; <span class="variable language_">self</span>.load_thres:</span><br><span class="line">                <span class="variable language_">self</span>.extend()</span><br><span class="line">            <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">   	        index = <span class="variable language_">self</span>.find_bucket(key)</span><br><span class="line">            <span class="comment"># 若找到键值对，则覆盖 val 并返回</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">                <span class="variable language_">self</span>.buckets[index].val = val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 若键值对不存在，则添加该键值对</span></span><br><span class="line">            <span class="variable language_">self</span>.buckets[index] = Pair(key, val)</span><br><span class="line">            <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 删除操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">        index = <span class="variable language_">self</span>.find_bucket(key)</span><br><span class="line">        <span class="comment"># 若找到键值对，则用删除标记覆盖它</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">            <span class="variable language_">self</span>.buckets[index] = <span class="variable language_">self</span>.TOMBSTONE</span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">          </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 扩容哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 暂存原哈希表</span></span><br><span class="line">        buckets_tmp = <span class="variable language_">self</span>.buckets</span><br><span class="line">        <span class="comment"># 初始化扩容后的新哈希表</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity *= <span class="variable language_">self</span>.extend_ratio</span><br><span class="line">        <span class="variable language_">self</span>.buckets = [<span class="literal">None</span>] * <span class="variable language_">self</span>.capacity</span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> buckets_tmp:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">                <span class="variable language_">self</span>.put(pair.key, pair.val)</span><br><span class="line">                </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> pair <span class="keyword">is</span> <span class="variable language_">self</span>.TOMBSTONE:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;TOMBSTONE&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(pair.key, <span class="string">&quot;-&gt;&quot;</span>, pair.val)</span><br></pre></td></tr></table></figure>
<p># 为了更加充分地使用哈希表的空间，将哈希表看作一个<strong>环形数组</strong> ，当越过数组尾部时，回到头部继续遍历。</p>
<h5 id="2-平方探测">2.平方探测</h5>
<ul>
<li>
<p>与线性探测类似，发生冲突时，会跳过<strong>探测次数的平方</strong> 的步数，即 1, 4, 9, … 步</p>
</li>
<li>
<p>平方探测主要具有以下优势：</p>
<ul>
<li>平方探测通过跳过探测次数平方的距离，试图<strong>缓解线性探测的聚集效应</strong> 。</li>
<li>平方探测会跳过更大的距离来寻找空位置，有助于数据<strong>分布得更加均匀</strong> 。</li>
</ul>
</li>
<li>
<p>同样也有局限性：</p>
<ul>
<li>
<p>仍然存在聚集现象，即某些位置比其他位置更容易被占用。</p>
</li>
<li>
<p>由于平方的增长，平方探测可能<strong>不会探测整个哈希表</strong> ，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。</p>
</li>
<li>
<p>同样不能直接删除元素</p>
</li>
</ul>
</li>
</ul>
<h5 id="3-多次哈希">3.多次哈希</h5>
<ul>
<li>
<p>多次哈希方法使用多个哈希函数 𝑓1(𝑥)、𝑓2(𝑥)、𝑓3(𝑥)、… 进行探测</p>
</li>
<li>
<p>插入元素：若哈希函数 𝑓1(𝑥) 出现冲突，则尝试 𝑓2(𝑥) ，以此类推，直到找到空位后插入元素。</p>
</li>
<li>
<p>查找元素：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 None 。</p>
</li>
<li>
<p>同样不能直接删除元素</p>
</li>
</ul>
<h4 id="3-编程语言的选择">3.编程语言的选择</h4>
<ul>
<li>各种编程语言采取了不同的哈希表实现策略
<ul>
<li><strong>Python</strong>  采用<strong>开放寻址</strong> 。<strong>字典 dict</strong>  使用<strong>伪随机数</strong> 进行探测。</li>
<li><strong>Java</strong> 采用<strong>链式地址</strong> 。自 JDK 1.8 以来，当 HashMap 内数组长度达到 64 且链表长度达到 8 时，链表会转换为<strong>红黑树</strong> 以提升查找性能。</li>
<li><strong>Go</strong> 采用<strong>链式地址</strong> 。Go规定每个桶最多存储 8 个键值对，超出容量则连接一个溢出桶；当溢出桶过多时，会<strong>执行一次特殊的等量扩容操作</strong> ，以确保性能。</li>
</ul>
</li>
</ul>
<h3 id="3-哈希算法">3.哈希算法</h3>
<ul>
<li>
<p>无论是开放寻址还是链式地址，它们只能保证哈希表可以在发生冲突时正常工作，而无法减少哈希冲突的发生</p>
</li>
<li>
<p>如果哈希冲突过于频繁，哈希表的性能则会急剧劣化</p>
</li>
<li>
<p><strong>键值对的分布情况由哈希函数决定</strong></p>
</li>
<li>
<p>index = hash(key) % capacity</p>
</li>
<li>
<p>当哈希表容量 capacity 固定时，哈希算法 hash() 决定了输出值</p>
</li>
<li>
<p>所以要降低哈希冲突的概率，就要集中于哈希算法的设计</p>
</li>
</ul>
<h4 id="1-哈希算法的目标">1.哈希算法的目标</h4>
<ul>
<li>
<p>为了实现既<strong>快</strong> 又<strong>稳</strong> 的哈希表数据结构，哈希算法应具备以下特点。</p>
<ul>
<li><strong>确定性</strong> ：对于<strong>相同的输入</strong> ，哈希算法应始终产生<strong>相同的输出</strong> 。这样才能确保哈希表是可靠的。</li>
<li><strong>效率高</strong> ：<strong>计算哈希值的过程应该足够快</strong> 。计算开销越小，哈希表的<strong>实用性越高</strong> 。</li>
<li><strong>均匀分布</strong> ：哈希算法应使得<strong>键值对均匀分布</strong> 在哈希表中。分布越均匀，<strong>哈希冲突的概率就越低</strong> 。</li>
</ul>
</li>
<li>
<p>在其他领域中也有广泛应用</p>
<ul>
<li><strong>密码存储</strong> ：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会<strong>对输入的密码计算哈希值</strong> ，然后<strong>与存储的哈希值进行比较</strong> 。如果两者匹配，那么密码就被视为正确。</li>
<li><strong>数据完整性检查</strong> ：数据发送方可以<strong>计算数据的哈希值</strong> 并将其一同发送；接收方可以重新<strong>计算接收到的数据的哈希值</strong> ，并<strong>与接收到的哈希值进行比较</strong> 。如果<strong>两者匹配</strong> ，那么数据就被视为完整。</li>
</ul>
</li>
<li>
<p>在<strong>密码学</strong> 中，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全特性</p>
<ul>
<li><strong>单向性</strong> ：无法通过哈希值反推出关于输入数据的任何信息。</li>
<li><strong>抗碰撞性</strong> ：应当<strong>极难</strong> 找到两个不同的输入，使得它们的哈希值相同。即哈希冲突（哈希碰撞）</li>
</ul>
<p># 这里不完全等同于均匀分布，均匀分布是均匀导致哈希冲突概率低，但是哈希算法可以较为简单，可以被简单的反推出来，而抗碰撞性是通过计算复杂度使其极难发生哈希冲突</p>
<p># <strong>哈希冲突</strong>就像是“世界上存在两片一模一样的雪花”。我们知道理论上可能存在，但几乎没人见过。</p>
<p># <strong>抗碰撞性</strong>就是“制造一台机器，让它能故意造出两片一模一样的雪花”。密码学哈希函数的设计目标就是，让造出这台机器的难度高到令人绝望。</p>
<ul>
<li><strong>雪崩效应</strong> ：<strong>输入的微小变化</strong> 应当导致<strong>输出的显著且不可预测的变化</strong> 。</li>
</ul>
</li>
</ul>
<h4 id="2-哈希算法的设计">2.哈希算法的设计</h4>
<ul>
<li>对于某些要求不高的场景，可以设计一些简单的哈希算法。</li>
<li><strong>加法哈希</strong> ：对输入的<strong>每个字符的ASCII码</strong> 进行相加，将得到的总和作为哈希值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 加法哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> += <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>乘法哈希</strong> ：利用<strong>乘法的不相关性</strong> ，每轮乘以一个常数，将各个字符的ASCII码累积到哈希值中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mul_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 乘法哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> = <span class="number">31</span> * <span class="built_in">hash</span> + <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>异或哈希</strong> ：将输入数据的每个元素通过<strong>异或操作</strong> 累积到一个哈希值中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 异或哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> ^= <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>旋转哈希</strong> ：将每个<strong>字符的ASCII码</strong> 累积到一个哈希值中，每次累积之前都会对哈希值进行<strong>旋转操作</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rot_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 旋转哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> = (<span class="built_in">hash</span> &lt;&lt; <span class="number">4</span>) ^ (<span class="built_in">hash</span> &gt;&gt; <span class="number">28</span>) ^ <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br></pre></td></tr></table></figure>
<ul>
<li>这些算法的最后都是对大质数1000000007取模，可以确保哈希值在合适的范围内</li>
<li>因为质数不存在公约数，减少出现取模产生的周期性模式，最大程度的保证哈希值均匀分布，避免聚集现象的出现，避免哈希冲突</li>
</ul>
<h4 id="3-常见哈希算法">3.常见哈希算法</h4>
<ul>
<li>以上算法都比较简单</li>
<li>实际中会采用一些标准哈希算法</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>MD5</th>
<th>SHA-1</th>
<th>SHA-2</th>
<th>SHA-3</th>
</tr>
</thead>
<tbody>
<tr>
<td>推出时间</td>
<td>1992</td>
<td>1995</td>
<td>2002</td>
<td>2008</td>
</tr>
<tr>
<td>输出长度</td>
<td>128 bit</td>
<td>160 bit</td>
<td>256/512 bit</td>
<td>224/256/384/512 bit</td>
</tr>
<tr>
<td>哈希冲突</td>
<td>较多</td>
<td>较多</td>
<td>很少</td>
<td>很少</td>
</tr>
<tr>
<td>安全等级</td>
<td>低，已被成功攻击</td>
<td>低，已被成功攻击</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>应用</td>
<td>已被弃用，仍用于数据完整性检查</td>
<td>已被弃用</td>
<td>加密货币交易验证、数字签名等</td>
<td>可用于替代 SHA‑2</td>
</tr>
</tbody>
</table>
<ul>
<li>SHA‑2 系列中的 SHA‑256 是最安全的哈希算法之一，仍未出现成功的攻击案例，因此常用在各类安全应用与协议中。</li>
<li>SHA‑3 相较 SHA‑2 的实现开销更低、计算效率更高，但目前使用覆盖度不如 SHA‑2 系列。</li>
</ul>
<h4 id="4-数据结构的哈希值">4.数据结构的哈希值</h4>
<ul>
<li>
<p>编程语言中通常会为数据类型提供内置的哈希算法</p>
</li>
<li>
<p>在python中，调用hash()来计算各种数据类型的哈希值</p>
<ul>
<li><strong>整数</strong> 和<strong>布尔量</strong> 的哈希值就是<strong>其本身</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">3</span></span><br><span class="line">hash_num = <span class="built_in">hash</span>(num)</span><br><span class="line"><span class="comment"># 整数 3 的哈希值为 3</span></span><br><span class="line"></span><br><span class="line">bol = <span class="literal">True</span></span><br><span class="line">hash_bol = <span class="built_in">hash</span>(bol)</span><br><span class="line"><span class="comment"># 布尔量 True 的哈希值为 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>浮点数</strong> 和<strong>字符串</strong> 的哈希值计算<strong>较为复杂</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dec = <span class="number">3.14159</span></span><br><span class="line">hash_dec = <span class="built_in">hash</span>(dec)</span><br><span class="line"><span class="comment"># 小数 3.14159 的哈希值为 326484311674566659</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hello 算法&quot;</span></span><br><span class="line">hash_str = <span class="built_in">hash</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 字符串“Hello 算法”的哈希值为 4617003410720528961</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>元组</strong> 的哈希值是<strong>对其中每一个元素进行哈希</strong> ，然后将这些<strong>哈希值组合起来</strong> ，<strong>得到单一的哈希值</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">12836</span>, <span class="string">&quot; 小哈&quot;</span>)</span><br><span class="line">hash_tup = <span class="built_in">hash</span>(tup)</span><br><span class="line"><span class="comment"># 元组 (12836, &#x27;小哈&#x27;) 的哈希值为 1029005403108185979</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对象</strong> 的哈希值<strong>基于其内存地址</strong> 生成。通过<strong>重写对象的哈希方法</strong> ，可实现<strong>基于内容生成哈希值</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = ListNode(<span class="number">0</span>)</span><br><span class="line">hash_obj = <span class="built_in">hash</span>(obj)</span><br><span class="line"><span class="comment"># 节点对象 &lt;ListNode object at 0x1058fd810&gt; 的哈希值为 274267521</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p># 不同编程语言的内置哈希值计算函数的定义和方法不同</p>
<ul>
<li>
<p>在许多编程语言中，<strong>只有不可变对象才可作为哈希表的</strong> <strong>key</strong> 。将列表（动态数组）作为key，当列表的内容发生变化时，它的哈希值也随之改变，就无法在哈希表中查询到原先的value了</p>
</li>
<li>
<p>虽然自定义对象（比如链表节点）的成员变量是可变的，但它是可哈希的。<strong>这是因为对象的哈希值通常是基于内存地址生成的</strong>，即使对象的<strong>内容发生了变化</strong> ，但<strong>它的内存地址不变</strong> ，哈希值仍然是不变的</p>
</li>
<li>
<p>在不同控制台中运行程序时，输出的哈希值是不同的。<strong>这是因为 Python 解释器在每次启动时，都会为字符串哈希函数加入一个随机的盐（salt）值</strong>。这种做法可以有效防止 HashDoS 攻击，提升哈希算法的安全性。</p>
</li>
</ul>
<h2 id="7-树">7.树</h2>
<h3 id="1-二叉树">1.二叉树</h3>
<ul>
<li>
<p><strong>二叉树</strong> （binary tree）是一种<strong>非线性</strong> 数据结构，代表<strong>祖先</strong> 与<strong>后代</strong> 之间的<strong>派生关系</strong> ，体现了<strong>一分为二</strong></p>
<p>的分治逻辑。与链表类似，二叉树的<strong>基本单元是节点</strong> ，每个节点包含<strong>值</strong> 、<strong>左子节点引用</strong> 和<strong>右子节点引用</strong> 。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树节点结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    <span class="type">int</span> height; <span class="comment">// 节点高度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span> <span class="comment">// 左子节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span> <span class="comment">// 右子节点指针</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">TreeNode *<span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode *node;</span><br><span class="line">    </span><br><span class="line">    node = (TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;height = <span class="number">0</span>;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code class="highlight mermaid">flowchart TD
	1[&quot;1
	(2和3的父节点)&quot;] --&gt; 2[&quot;2
	(左子节点)&quot;]
	1 --&gt; 3[&quot;3
	(右子节点)&quot;]
	subgraph 右子树
	3 --&gt; 6
	3 --&gt; 7
	end
	subgraph 左子树
	2 --&gt; 4
	2 --&gt; 5
	end
</code></pre>
<ul>
<li>
<p>每个节点都有<strong>两个引用</strong> （指针），分别指向<strong>左子节点</strong> （left‑child node）和<strong>右子节点</strong> （right‑child node），该节点被称为这两个子节点的<strong>父节点</strong> （parent node）。当给定一个二叉树的节点时，将该节点的左子节点及其以下节点形成的树称为该节点的<strong>左子树</strong> （left subtree），同理可得<strong>右子树</strong> （right subtree）</p>
</li>
<li>
<p>在二叉树中，除叶节点外，其他所有节点都包含<strong>子节点</strong> 和<strong>非空子树</strong></p>
</li>
</ul>
<h4 id="1-二叉树常见术语">1.二叉树常见术语</h4>
<ul>
<li><strong>根节点</strong> （root node）：位于二叉树顶层的节点，<strong>没有父节点</strong> 。</li>
<li><strong>叶节点</strong> （leaf node）：<strong>没有子节点</strong> 的节点，其两个指针均<strong>指向None</strong> 。</li>
<li><strong>边</strong> （edge）：<strong>连接两个节点的线段</strong> ，即<strong>节点引用</strong> （指针）。</li>
<li>节点所在的<strong>层</strong> （level）：<strong>从顶至底</strong> 递增，<strong>根节点</strong> 所在层为<strong>1</strong> 。</li>
<li>节点的<strong>度</strong> （degree）：<strong>节点的子节点的数量</strong> 。在二叉树中，度的取值范围是 0、1、2 。</li>
<li>二叉树的<strong>高度</strong> （height）：从<strong>根节点</strong> 到<strong>最远叶节点</strong> 所经过的<strong>边的数量</strong> 。</li>
<li>节点的<strong>深度</strong> （depth）：从<strong>根节点</strong> 到<strong>该节点</strong> 所经过的<strong>边的数量</strong> 。</li>
<li>节点的<strong>高度</strong> （height）：从距离<strong>该节点最远的叶节点</strong> 到<strong>该节点</strong> 所经过的<strong>边的数量</strong> 。</li>
</ul>
<pre><code class="highlight mermaid">flowchart TB
	subgraph 高度为3的二叉树
	direction TB
	1[&quot;1
	(根节点)
	(层为1)
	(度为2)
	(深度为0)
	(高度为3)&quot;] --边--&gt; 2[&quot;2
	(层为2)
	(度为2)
	(深度为1)
	(高度为2)&quot;]
	1 --边--&gt; 3[&quot;3
	(层为2)
	(度为2)
	(深度为1)
	(高度为2)&quot;]
	3 --边--&gt; 6[&quot;6
	(层为3)
	(度为1)
	(深度为2)
	(高度为1)&quot;]
	3 --边--&gt; 7[&quot;7
	(层为3)
	(度为2)
	(深度为2)
	(高度为1)&quot;]
	2 --边--&gt; 4[&quot;4
	(层为3)
	(度为2)
	(深度为2)
	(高度为1)&quot;]
    2 --边--&gt; 5[&quot;5
    (叶节点)
    (层为3)
    (度为0)
    (深度为2)
    (高度为1)&quot;]
    4 --边--&gt; 8[&quot;8
    (叶节点)
    (层为4)
    (度为0)
    (深度为3)
    (高度为0)&quot;]
    4 --边--&gt; 9[&quot;9
    (叶节点)
    (层为4)
    (度为0)
    (深度为3)
    (高度为0)&quot;]
    6 --边--&gt; 12[&quot;12
    (叶节点)
    (层为4)
    (度为0)
    (深度为3)
    (高度为0)&quot;]
    7 --边--&gt; 14[&quot;14
    (叶节点)
    (层为4)
    (度为0)
    (深度为3)
    (高度为0)&quot;]
    7 --边--&gt; 15[&quot;15
    (叶节点)
    (层为4)
    (度为0)
    (深度为3)
    (高度为0)&quot;]   
    end</code></pre>
<h4 id="2-二叉树基本操作">2.二叉树基本操作</h4>
<h5 id="1-初始化二叉树">1.初始化二叉树</h5>
<ul>
<li>与链表相似，先初始化节点，然后构建引用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化二叉树 */</span></span><br><span class="line"><span class="comment">// 初始化节点</span></span><br><span class="line">TreeNode *n1 = newTreeNode(<span class="number">1</span>);</span><br><span class="line">TreeNode *n2 = newTreeNode(<span class="number">2</span>);</span><br><span class="line">TreeNode *n3 = newTreeNode(<span class="number">3</span>);</span><br><span class="line">TreeNode *n4 = newTreeNode(<span class="number">4</span>);</span><br><span class="line">TreeNode *n5 = newTreeNode(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 构建节点之间的引用（指针）</span></span><br><span class="line">n1-&gt;left = n2;</span><br><span class="line">n1-&gt;right = n3;</span><br><span class="line">n2-&gt;left = n4;</span><br><span class="line">n2-&gt;right = n5;</span><br></pre></td></tr></table></figure>
<h5 id="2-插入与删除节点">2.插入与删除节点</h5>
<ul>
<li>与链表相似，都是修改指针</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
    
    subgraph 插入后二叉树
    direction TB
    1&#x27;[&quot;1
    (n1)&quot;] --&gt; 0
	1&#x27; --&gt; 3&#x27;[3]
	0[&quot;0
	(p)&quot;] --&gt; 2&#x27;[&quot;2
	(n2)&quot;]
    2&#x27; --&gt; 4&#x27;[4]
    2&#x27; --&gt; 5&#x27;[5]
    end
    
    subgraph 原二叉树
	direction TB
	1[&quot;1
	(n1)&quot;] --&gt; 2[&quot;2
	(n2)&quot;]
	1 --&gt; 3
	2 --&gt; 4
    2 --&gt; 5
    0&#x27;[&quot;0
	(p)&quot;]
    end
    
    subgraph 删除后二叉树
	direction TB
	1&#x27;&#x27;[&quot;1
	(n1)&quot;] --&gt; 2&#x27;&#x27;[&quot;2
	(n2)&quot;]
	1&#x27;&#x27; --&gt; 3&#x27;&#x27;[3]
	2&#x27;&#x27; --&gt; 4&#x27;&#x27;[4]
    2&#x27;&#x27; --&gt; 5&#x27;&#x27;[5]
    end
    
    
    
    原二叉树 --n1.left = p
    p.left = n2--&gt; 插入后二叉树
    
    插入后二叉树 --n1.left = n2--&gt; 删除后二叉树</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入与删除节点 */</span></span><br><span class="line">TreeNode *P = newTreeNode(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 在 n1 -&gt; n2 中间插入节点 P</span></span><br><span class="line">n1-&gt;left = P;</span><br><span class="line">P-&gt;left = n2;</span><br><span class="line"><span class="comment">// 删除节点 P</span></span><br><span class="line">n1-&gt;left = n2;</span><br></pre></td></tr></table></figure>
<p># 原有的引用不删除，只将插入的节点删除，所以删除后就是原二叉树，如果将原有引用删除后又删除插入的节点则就是删除了整个左子树</p>
<h4 id="3-常见二叉树类型">3.常见二叉树类型</h4>
<h5 id="1-完美二叉树-满二叉树">1.完美二叉树(满二叉树)</h5>
<ul>
<li><strong>完美二叉树</strong> （perfect binary tree）所有层的节点都被完全填满。在完美二叉树中，叶节点的度 为 0 ，其余所有节点的度都为 2 ；若树的高度为 ℎ ，则节点总数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{ℎ+1} − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象</li>
</ul>
<pre><code class="highlight mermaid">flowchart TD
	1 --&gt; 2
	1 --&gt; 3
	3 --&gt; 6
	3 --&gt; 7
	2 --&gt; 4
	2 --&gt; 5
	4 --&gt; 8
	4 --&gt; 9
	5 --&gt; 10
	5 --&gt; 11
	6 --&gt; 12
	6 --&gt; 13
	7 --&gt; 14
	7 --&gt; 15</code></pre>
<h5 id="2-完全二叉树">2.完全二叉树</h5>
<ul>
<li><strong>完全二叉树</strong> （complete binary tree）只有<strong>最底层</strong> 的节点<strong>未被填满</strong> ，且<strong>最底层</strong> 节点<strong>尽量靠左</strong> 填充。</li>
</ul>
<p># 完美二叉树也是一棵完全二叉树。</p>
<pre><code class="highlight mermaid">flowchart TD
	1 --&gt; 2
	1 --&gt; 3
	3 --&gt; 6
	3 --&gt; 7
	2 --&gt; 4
	2 --&gt; 5
	4 --&gt; 8
	4 --&gt; 9
	5 --&gt; 10
	5 --&gt; 11
	6 --&gt; 12</code></pre>
<h5 id="3-完满二叉树">3.完满二叉树</h5>
<ul>
<li><strong>完满二叉树</strong> （full binary tree）除了叶节点之外，其余所有节点都有两个子节点</li>
<li>即所有节点的度都为0或2</li>
</ul>
<pre><code class="highlight mermaid">flowchart TD
	1 --&gt; 2
	1 --&gt; 3
	2 --&gt; 4
	2 --&gt; 5
	5 --&gt; 10
	5 --&gt; 11
</code></pre>
<h5 id="4-平衡二叉树">4.平衡二叉树</h5>
<ul>
<li><strong>平衡二叉树</strong> （balanced binary tree）中<strong>任意节点</strong> 的<strong>左子树</strong> 和<strong>右子树</strong> 的<strong>高度之差</strong> 的绝对值不超过1。</li>
</ul>
<pre><code class="highlight mermaid">flowchart TD
	1 --&gt; 2
	1 --&gt; 3
	3 --&gt; 6
	2 --&gt; 4
	2 --&gt; 5
	5 --&gt; 10
	5 --&gt; 11</code></pre>
<h4 id="4-二叉树的退化">4.二叉树的退化</h4>
<ul>
<li>二叉树的理想结构就是满二叉树</li>
<li>当所有节点都偏向一侧时，二叉树就退化为链表</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 满二叉树
	1 --&gt; 2
	1 --&gt; 3
	3 --&gt; 6
	3 --&gt; 7
	2 --&gt; 4
	2 --&gt; 5
	end
	
	subgraph 链表
	1&#x27;[1] --&gt; 2&#x27;[2]
	2&#x27; --&gt; 3&#x27;[3]
	3&#x27; --&gt; 4&#x27;[4]
	4&#x27; --&gt; 5&#x27;[5]
	5&#x27; --&gt; 6&#x27;[6]
	6&#x27; --&gt; 7&#x27;[7]
	end
	
	满二叉树 --退化--&gt; 链表</code></pre>
<ul>
<li>
<p>在<strong>最佳结构</strong> 和<strong>最差结构</strong> 下，二叉树的叶节点数量、节点总数、高度等达到<strong>极大值</strong> 或<strong>极小值</strong></p>
</li>
<li>
<p>完美二叉树是理想情况，可以充分发挥二叉树<strong>分治</strong> 的优势。</p>
</li>
<li>
<p>链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 𝑂(𝑛)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>完美二叉树</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>第i层的节点数量</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td>1</td>
</tr>
<tr>
<td>高度为h的树的叶节点数量</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></td>
<td>1</td>
</tr>
<tr>
<td>高度为h的树的节点总数</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{h+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td>h+1</td>
</tr>
<tr>
<td>节点总数为n的树的高度</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\log_2(n+1)-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
<td>n-1</td>
</tr>
</tbody>
</table>
<h3 id="2-二叉树遍历">2.二叉树遍历</h3>
<ul>
<li>从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过<strong>指针</strong> 逐个访问节点。然而，树是一种<strong>非线性</strong> 数据结构，这使得遍历树比遍历链表更加复杂，需要借助<strong>搜索算法</strong> 来实现。二叉树常见的遍历方式包括<strong>层序遍历</strong> 、<strong>前序遍历</strong> 、<strong>中序遍历</strong> 和<strong>后序遍历</strong> 等</li>
</ul>
<h4 id="1-层序遍历">1.层序遍历</h4>
<ul>
<li>
<p><strong>层序遍历</strong> （level‑order traversal）<strong>从顶部到底部逐层</strong> 遍历二叉树，并在每一层按照<strong>从左到右</strong> 的顺序访问节点</p>
</li>
<li>
<p>层序遍历本质上属于<strong>广度优先</strong> 遍历（breadth‑first traversal），也称<strong>广度优先搜索</strong> （breadth‑first search,BFS）</p>
</li>
</ul>
<h5 id="1-代码实现">1.代码实现</h5>
<ul>
<li>借助队列来实现，队列的<strong>先进先出</strong> 和广度优先的<strong>逐层推进</strong> 是一致的</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">levelOrder</span><span class="params">(TreeNode *root, <span class="type">int</span> *size)</span> &#123;</span><br><span class="line">    <span class="comment">/* 辅助队列 */</span></span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="type">int</span> index, *arr;</span><br><span class="line">    TreeNode *node;</span><br><span class="line">    TreeNode **<span class="built_in">queue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 辅助队列 */</span></span><br><span class="line">    <span class="built_in">queue</span> = (TreeNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode *) * MAX_SIZE);</span><br><span class="line">    <span class="comment">// 队列指针</span></span><br><span class="line">    front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 加入根节点</span></span><br><span class="line">    <span class="built_in">queue</span>[rear++] = root;</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    <span class="comment">/* 辅助数组 */</span></span><br><span class="line">    arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * MAX_SIZE);</span><br><span class="line">    <span class="comment">// 数组指针</span></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">        <span class="comment">// 队列出队</span></span><br><span class="line">        node = <span class="built_in">queue</span>[front++];</span><br><span class="line">        <span class="comment">// 保存节点值</span></span><br><span class="line">        arr[index++] = node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 左子节点入队</span></span><br><span class="line">            <span class="built_in">queue</span>[rear++] = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 右子节点入队</span></span><br><span class="line">            <span class="built_in">queue</span>[rear++] = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新数组长度的值</span></span><br><span class="line">    *size = index;</span><br><span class="line">    arr = <span class="built_in">realloc</span>(arr, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (*size));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放辅助数组空间</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-复杂度分析-2">2.复杂度分析</h5>
<ul>
<li><strong>时间复杂度为</strong>  𝑂(𝑛) ：所有节点被访问一次，使用 𝑂(𝑛) 时间，其中 𝑛 为节点数量。</li>
<li><strong>空间复杂度为</strong>  𝑂(𝑛) ：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在(𝑛 + 1)/2 个节点，占用 𝑂(𝑛) 空间。</li>
</ul>
<h4 id="2-前序，中序，后序遍历">2.前序，中序，后序遍历</h4>
<ul>
<li>
<p><strong>前序、中序和后序遍历</strong> 都属于<strong>深度优先</strong> 遍历（depth‑first traversal），也称<strong>深度优先</strong> 搜索（depth‑first search, DFS）</p>
</li>
<li>
<p>规定D，L，R分别代表根节点，左子树，右子树</p>
<ul>
<li>DLR–前序遍历（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）
<ul>
<li>1（D）-[2（4，5的D）-4（2的L）-5（2的R）]（L）-[3（6，7的D）-6（3的L）-7（3的R）]（R）</li>
</ul>
</li>
<li>LDR–中序遍历（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）
<ul>
<li>[4（2的L）-2（4，5的D）-5（2的R）]（L）-1（D）-[6（3的L）-3（6，7的D）-7（3的R）]（R）</li>
</ul>
</li>
<li>LRD–后序遍历（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）
<ul>
<li>[4（2的L）-5（2的R）-2（4，5的D）]（L）-[6（3的L）-7（3的R）-3（6，7的D）]（R）-1（D）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p># 每个根都是相对的</p>
<pre><code class="highlight mermaid">flowchart TB
	subgraph D
	1
	end
	1 --&gt; L
	1 --&gt; R
	subgraph R
	direction TB
	3 --&gt; L&#x27;&#x27;
	3 --&gt; R&#x27;&#x27;
	subgraph D&#x27;[D]
	3
	end
	subgraph L&#x27;&#x27;[L]
	6
	end
	subgraph R&#x27;&#x27;[R]
	7
	end
	end
	subgraph L
	direction TB
	2 --&gt; L&#x27;
	2 --&gt; R&#x27;
	subgraph D&#x27;&#x27;[D]
	2
	end
	subgraph L&#x27;[L]
	4
	end
	subgraph R&#x27;[R]
	5
	end
	end</code></pre>
<h5 id="1-代码实现-2">1.代码实现</h5>
<ul>
<li><strong>深度优先</strong> 搜索通常基于<strong>递归</strong> 实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode *root, <span class="type">int</span> *size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    arr[(*size)++] = root-&gt;val;</span><br><span class="line">    preOrder(root-&gt;left, size);</span><br><span class="line">    preOrder(root-&gt;right, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode *root, <span class="type">int</span> *size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    inOrder(root-&gt;left, size);</span><br><span class="line">    arr[(*size)++] = root-&gt;val;</span><br><span class="line">    inOrder(root-&gt;right, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode *root, <span class="type">int</span> *size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    postOrder(root-&gt;left, size);</span><br><span class="line">    postOrder(root-&gt;right, size);</span><br><span class="line">    arr[(*size)++] = root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 也可以基于迭代来实现</p>
<ul>
<li>可以分为两个部分
<ul>
<li><strong>递</strong> 表示开启新方法，程序在此过程中访问下一个节点。</li>
<li><strong>归</strong> 表示函数返回，代表当前节点已经访问完毕</li>
</ul>
</li>
</ul>
<p># 以前序遍历为例</p>
<p>1（递）-2（递）-4（递）-[2（归）]-5（递）-[2（归）]-[1（归）]-3（递）-6（递）-[3（归）]-7（递）-[3（归）]-[1（归）]</p>
<h5 id="2-复杂度分析-3">2.复杂度分析</h5>
<ul>
<li><strong>时间复杂度为</strong> 𝑂(𝑛) ：所有节点被访问一次，使用 𝑂(𝑛) 时间。</li>
<li><strong>空间复杂度为</strong> 𝑂(𝑛) ：在最差情况下，即树退化为链表时，递归深度达到 𝑛 ，系统占用 𝑂(𝑛) 栈帧空间。</li>
</ul>
<h3 id="3-二叉树数组表示">3.二叉树数组表示</h3>
<h4 id="1-表示完美二叉树">1.表示完美二叉树</h4>
<ul>
<li>按照层序遍历的顺序作为索引，即从每一层从左到右</li>
<li>根据层序遍历的特性，可以推导出<strong>父节点索引</strong> 与<strong>子节点索引</strong> 之间的<strong>映射公式</strong> ：若某节点的索引为𝑖 ，则该节点的左子节点索引为2𝑖 + 1，右子节点索引为2𝑖 + 2 。
<ul>
<li>这个公式就相当于是链表里的指针，给定节点索引就可以访问其左右子节点</li>
</ul>
</li>
</ul>
<h4 id="2-表示任意二叉树">2.表示任意二叉树</h4>
<ul>
<li>一般的二叉树中会有许多none，所以在写数组的时候就把none的地方直接标记出来</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 int 最大值标记空位，因此要求节点值不能为 INT_MAX</span></span><br><span class="line"><span class="type">int</span> tree[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, INT_MAX, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, INT_MAX, INT_MAX, <span class="number">12</span>, INT_MAX, INT_MAX, <span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure>
<p># <strong>完全二叉树</strong> 非常适合使用数组来表示。None 只出现在最底层且靠右的位置，因此所有 <strong>None</strong> <strong>一定出现在层序遍历序列的末尾</strong> ，可以省略存储所有 None</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 数组表示下的二叉树结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *tree;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; ArrayBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">ArrayBinaryTree *<span class="title function_">newArrayBinaryTree</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    ArrayBinaryTree *abt = (ArrayBinaryTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayBinaryTree));</span><br><span class="line">    abt-&gt;tree = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * arrSize);</span><br><span class="line">    <span class="built_in">memcpy</span>(abt-&gt;tree, arr, <span class="keyword">sizeof</span>(<span class="type">int</span>) * arrSize);</span><br><span class="line">    abt-&gt;size = arrSize;</span><br><span class="line">    <span class="keyword">return</span> abt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delArrayBinaryTree</span><span class="params">(ArrayBinaryTree *abt)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(abt-&gt;tree);</span><br><span class="line">    <span class="built_in">free</span>(abt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 列表容量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(ArrayBinaryTree *abt)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> abt-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取索引为 i 节点的值 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">val</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 若索引越界，则返回 INT_MAX ，代表空位</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size(abt))</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">return</span> abt-&gt;tree[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">levelOrder</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> *returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size(abt));</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 直接遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size(abt); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val(abt, i) != INT_MAX)</span><br><span class="line">            res[index++] = val(abt, i);</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = index;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> i, <span class="type">char</span> *order, <span class="type">int</span> *res, <span class="type">int</span> *index)</span> &#123;</span><br><span class="line">    <span class="comment">// 若为空位，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (val(abt, i) == INT_MAX)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(order, <span class="string">&quot;pre&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        res[(*index)++] = val(abt, i);</span><br><span class="line">    dfs(abt, left(i), order, res, index);</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(order, <span class="string">&quot;in&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        res[(*index)++] = val(abt, i);</span><br><span class="line">    dfs(abt, right(i), order, res, index);</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(order, <span class="string">&quot;post&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        res[(*index)++] = val(abt, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">preOrder</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> *returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size(abt));</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    dfs(abt, <span class="number">0</span>, <span class="string">&quot;pre&quot;</span>, res, &amp;index);</span><br><span class="line">    *returnSize = index;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">inOrder</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> *returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size(abt));</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    dfs(abt, <span class="number">0</span>, <span class="string">&quot;in&quot;</span>, res, &amp;index);</span><br><span class="line">    *returnSize = index;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">postOrder</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> *returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size(abt));</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    dfs(abt, <span class="number">0</span>, <span class="string">&quot;post&quot;</span>, res, &amp;index);</span><br><span class="line">    *returnSize = index;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>可以实现</p>
<ul>
<li>
<p>给定某节点，获取它的值、左（右）子节点、父节点。</p>
</li>
<li>
<p>获取前序遍历、中序遍历、后序遍历、层序遍历序列</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-优点与局限性">3.优点与局限性</h4>
<ul>
<li>优点
<ul>
<li>数组存储在<strong>连续的内存空间</strong> 中，<strong>对缓存友好</strong> ，访问与遍历<strong>速度较快</strong> 。</li>
<li><strong>不需要存储指针</strong> ，比较<strong>节省空间</strong> 。</li>
<li><strong>允许随机访问节点</strong> 。</li>
</ul>
</li>
<li>局限性
<ul>
<li>数组存储<strong>需要连续内存空间</strong> ，因此<strong>不适合存储数据量过大</strong> 的树。</li>
<li><strong>增删节点</strong> 需要通过数组插入与删除操作实现，<strong>效率较低</strong> 。</li>
<li>当二叉树中<strong>存在大量 None 时</strong> ，数组中包含的<strong>节点数据比重较低</strong> ，<strong>空间利用率较低</strong> 。</li>
</ul>
</li>
</ul>
<h3 id="4-二叉搜索树">4.二叉搜索树</h3>
<ul>
<li><strong>二叉搜索树</strong> （binary search tree）满足以下条件
<ul>
<li>对于根节点，<strong>左子树</strong> 中<strong>所有节点的值</strong> &lt; <strong>根节点的值</strong> &lt; <strong>右子树</strong> 中<strong>所有节点的值</strong> 。</li>
<li><strong>任意节点</strong> 的<strong>左、右子树也是二叉搜索树</strong> ，即同样满足上一个条件 。</li>
</ul>
</li>
</ul>
<h4 id="1-二叉搜索树的操作">1.二叉搜索树的操作</h4>
<ul>
<li>将二叉搜索树封装为一个类 BinarySearchTree ，并声明一个成员变量 root ，指向树的根节点</li>
</ul>
<h5 id="1-查找操作">1.查找操作</h5>
<ul>
<li>给定目标节点值 num ，可以根据二叉搜索树的性质来查找。声明一个节点 cur ，从二叉树的根节点 root 出发，循环比较节点值 cur.val 和 num 之间的大小关系。
<ul>
<li>若 <strong>cur.val &lt; num</strong> ，说明目标节点在 cur 的<strong>右子树</strong> 中，因此<strong>执行 cur = cur.right</strong> 。</li>
<li>若 <strong>cur.val &gt; num</strong> ，说明目标节点在 cur 的<strong>左子树</strong> 中，因此<strong>执行 cur = cur.left</strong> 。</li>
<li>若 <strong>cur.val = num</strong> ，说明<strong>找到目标节点</strong> ，跳出循环并返回该节点。</li>
</ul>
</li>
<li>二叉搜索树的查找操作与<strong>二分查找算法</strong> 的工作原理一致，都是<strong>每轮排除一半</strong> 情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用 𝑂(log 𝑛) 时间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查找节点 */</span></span><br><span class="line">TreeNode *<span class="title function_">search</span><span class="params">(BinarySearchTree *bst, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    TreeNode *cur = bst-&gt;root;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num) &#123;</span><br><span class="line">            <span class="comment">// 目标节点在 cur 的右子树中</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;val &gt; num) &#123;</span><br><span class="line">            <span class="comment">// 目标节点在 cur 的左子树中</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到目标节点，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目标节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-插入节点-2">2.插入节点</h5>
<ul>
<li>
<p>插入元素时需要保证二叉搜索树<strong>左子树 &lt; 根节点 &lt; 右子树</strong> 的性质，流程如下</p>
<ul>
<li>
<p><strong>查找插入位置</strong> ：<strong>与查找操作相似</strong> ，从根节点出发，根据当前节点值和 num 的大小关系循环向下搜索，直到越过叶节点（<strong>遍历至 None</strong> ）时跳出循环。</p>
</li>
<li>
<p><strong>在该位置插入节点</strong> ：初始化节点 num ，将该节点置于 None 的位置。</p>
</li>
</ul>
<p># 因此与查找节点相同，插入节点使用 𝑂(log 𝑛) 时间</p>
</li>
<li>
<p>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若<strong>待插入节点在树中已存在</strong> ，则<strong>不执行插入</strong> ，直接返回。</p>
</li>
<li>
<p>为了实现插入节点，我们需要借助节点 pre <strong>保存上一轮循环的节点</strong> 。这样在遍历至 None 时，我们<strong>可以获取到其父节点</strong> ，从而完成节点插入操作。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BinarySearchTree *bst, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 若树为空，则初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> (bst-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bst-&gt;root = newTreeNode(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *cur = bst-&gt;root, *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到重复节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == num) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num) &#123;</span><br><span class="line">            <span class="comment">// 插入位置在 cur 的右子树中</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入位置在 cur 的左子树中</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    TreeNode *node = newTreeNode(num);</span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;val &lt; num) &#123;</span><br><span class="line">        pre-&gt;right = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pre-&gt;left = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 插入后二叉树
	subgraph A[在None的位置插入节点执行pre.right = 8]
	direction TB
	4&#x27;[4] --&gt; 2&#x27;[2]
	4&#x27; --&gt; 6&#x27;[6]
	6&#x27; --&gt; 5&#x27;[5]
	6&#x27; --&gt; 7&#x27;[7]
	2&#x27; --&gt; 1&#x27;[1]
	2&#x27; --&gt; 3&#x27;[3]
	3&#x27; --&gt; 8&#x27;[8]
	end
	end

	subgraph 原二叉树
	subgraph 查找节点插入位置
	direction TB
	4 --&gt; 2
	4 --&gt; 6
	6 --&gt; 5
	6 --&gt; 7
	2 --&gt; 1
	2 --&gt; 3
	7 --&gt; None
	end
	end
	
	原二叉树 --插入节点8--&gt; 插入后二叉树</code></pre>
<h5 id="3-删除节点-2">3.删除节点</h5>
<ul>
<li>
<p>首先查找相应节点，为了保证删除后仍满足<strong>左子树 &lt; 根节点 &lt; 右子树</strong> 的性质，将要删除的节点的位置分为三种</p>
<ul>
<li>度为0，即叶节点，直接删除</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 删除后二叉树
	subgraph A[直接删除cur即可，执行pre.left = None]
	direction TB
	4&#x27;[4] --&gt; 2&#x27;[2]
	4&#x27; --&gt; 6&#x27;[6]
	2&#x27; --&gt; 3&#x27;[3]
	6&#x27; --&gt; 5&#x27;[5]
	6&#x27; --&gt; 7&#x27;[7]
	end
	end

	subgraph 原二叉树
	subgraph 查找要删除元素的位置
	direction TB
	4 --&gt; 2
	4 --&gt; 6
	6 --&gt; 5
	6 --&gt; 7
	2 --&gt; 1[&quot;1
	(节点cur，子节点的个数为0)&quot;]
	2 --&gt; 3
	end
	end
	
	原二叉树 --删除节点1--&gt; 删除后二叉树</code></pre>
<ul>
<li>度为1，将要删除的节点换位其子节点即可</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 删除后二叉树
	subgraph A[将删除节点替换为其子节点，执行pre.left = pre.right]
	direction TB
	4&#x27;[4] --&gt; 3&#x27;[3]
	4&#x27; --&gt; 6&#x27;[6]
	6&#x27; --&gt; 5&#x27;[5]
	6&#x27; --&gt; 7&#x27;[7]
	end
	end

	subgraph 原二叉树
	subgraph 查找要删除元素的位置
	direction TB
	4 --&gt; 2
	4 --&gt; 6
	6 --&gt; 5
	6 --&gt; 7
	2 --&gt; 3[&quot;3
	(节点cur，子节点的个数为1)&quot;]
	end
	end
	
	原二叉树 --删除节点3--&gt; 删除后二叉树</code></pre>
<ul>
<li>
<p>度为2，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树<strong>左子树 &lt; 根节点 &lt; 右子树</strong> 的性质，因此这个节点可以是<strong>右子树的最小节点（中序遍历该删除节点的下一个节点）或左子树的最大节点（中序遍历该删除节点的上一个节点）</strong> 。</p>
<ul>
<li>先用中序遍历找到要删除节点的下一个（右子树的最小节点）或上一个（左子树的最大节点），记为tmp</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR

	subgraph 查找中序遍历的后继节点nex
	8&#x27;[8] --&gt; 4&#x27;[&quot;4
	(节点cur，子节点的个数为2)&quot;]
	8&#x27; --&gt; 12&#x27;[12]
	4&#x27; --&gt; 3&#x27;[3]
	4&#x27; --&gt; 6&#x27;[6]
	6&#x27; --&gt; 5&#x27;[&quot;5
	(cur在中序遍历中的后继节点nex)&quot;]
	6&#x27; --&gt; 7&#x27;[7]
	12&#x27; --&gt; 10&#x27;[10]
	12&#x27; --&gt; 14&#x27;[14]
	10&#x27; --&gt; 9&#x27;[9]
	10&#x27; --&gt; 11&#x27;[11]
	14&#x27; --&gt; 13&#x27;[13]
	14&#x27; --&gt; 15&#x27;[15]
	end
	
	subgraph 原二叉树
	8 --&gt; 4[&quot;4
	(节点cur，子节点的个数为2)&quot;]
	8 --&gt; 12
	4 --&gt; 3
	4 --&gt; 6
	6 --&gt; 7
	6 --&gt; 5
	12 --&gt; 10
	12 --&gt; 14
	10 --&gt; 9
	10 --&gt; 11
	14 --&gt; 13
	14 --&gt; 15
	end
	

	原二叉树 --&gt; 查找中序遍历的后继节点nex</code></pre>
<ul>
<li>删除tmp，然后将要删除的节点替换为tmp</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 将节点nex的值赋给cur
	8&#x27;&#x27;&#x27;[8] --&gt; 5&#x27;&#x27;&#x27;[5]
	8&#x27;&#x27;&#x27; --&gt; 12&#x27;&#x27;&#x27;[12]
	5&#x27;&#x27;&#x27; --&gt; 3&#x27;&#x27;&#x27;[3]
	5&#x27;&#x27;&#x27; --&gt; 6&#x27;&#x27;&#x27;
	6&#x27;&#x27;&#x27;[6] --&gt; 7&#x27;&#x27;&#x27;[7]
	12&#x27;&#x27;&#x27; --&gt; 10&#x27;&#x27;&#x27;[10]
	12&#x27;&#x27;&#x27; --&gt; 14&#x27;&#x27;&#x27;[14]
	10&#x27;&#x27;&#x27; --&gt; 9&#x27;&#x27;&#x27;[9]
	10&#x27;&#x27;&#x27; --&gt; 11&#x27;&#x27;&#x27;[11]
	14&#x27;&#x27;&#x27; --&gt; 13&#x27;&#x27;&#x27;[13]
	14&#x27;&#x27;&#x27; --&gt; 15&#x27;&#x27;&#x27;[15]
	end

	subgraph 删除nex
	8&#x27;&#x27;[8] --&gt; 4&#x27;&#x27;[&quot;4
	(节点cur，子节点的个数为2)&quot;]
	8&#x27;&#x27; --&gt; 12&#x27;&#x27;[12]
	4&#x27;&#x27; --&gt; 3&#x27;&#x27;[3]
	4&#x27;&#x27; --&gt; 6&#x27;&#x27;[6]
	6&#x27;&#x27; --&gt; 7&#x27;&#x27;[7]
	12&#x27;&#x27; --&gt; 10&#x27;&#x27;[10]
	12&#x27;&#x27; --&gt; 14&#x27;&#x27;[14]
	10&#x27;&#x27; --&gt; 9&#x27;&#x27;[9]
	10&#x27;&#x27; --&gt; 11&#x27;&#x27;[11]
	14&#x27;&#x27; --&gt; 13&#x27;&#x27;[13]
	14&#x27;&#x27; --&gt; 15&#x27;&#x27;[15]
	end
	
	删除nex --&gt; 将节点nex的值赋给cur</code></pre>
</li>
</ul>
<p># 因为与查找类似，所以删除节点操作同样使用 𝑂(log 𝑛) 时间，其中查找待删除节点需要 𝑂(log 𝑛) 时间，获取中序遍历后继节点需要 𝑂(log 𝑛) 时间</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="comment">// 由于引入了 stdio.h ，此处无法使用 remove 关键词</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeItem</span><span class="params">(BinarySearchTree *bst, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> (bst-&gt;root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TreeNode *cur = bst-&gt;root, *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到待删除节点，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num) &#123;</span><br><span class="line">            <span class="comment">// 待删除节点在 root 的右子树中</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 待删除节点在 root 的左子树中</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若无待删除节点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 判断待删除节点是否存在子节点</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> || cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* 子节点数量 = 0 or 1 */</span></span><br><span class="line">        <span class="comment">// 当子节点数量 = 0 / 1 时， child = nullptr / 该子节点</span></span><br><span class="line">        TreeNode *child = cur-&gt;left != <span class="literal">NULL</span> ? cur-&gt;left : cur-&gt;right;</span><br><span class="line">        <span class="comment">// 删除节点 cur</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;left == cur) &#123;</span><br><span class="line">            pre-&gt;left = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre-&gt;right = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 子节点数量 = 2 */</span></span><br><span class="line">        <span class="comment">// 获取中序遍历中 cur 的下一个节点</span></span><br><span class="line">        TreeNode *tmp = cur-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmpVal = tmp-&gt;val;</span><br><span class="line">        <span class="comment">// 递归删除节点 tmp</span></span><br><span class="line">        removeItem(bst, tmp-&gt;val);</span><br><span class="line">        <span class="comment">// 用 tmp 覆盖 cur</span></span><br><span class="line">        cur-&gt;val = tmpVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-中序遍历有序">4.中序遍历有序</h5>
<ul>
<li>中序遍历遵循<strong>LDR</strong> ，且二叉搜索树满足<strong>左子节点&lt;根节点&lt;右子节点</strong></li>
<li>所以二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：</li>
<li><strong>二叉搜索树的中序遍历序列是升序的</strong> 。</li>
<li>利用中序遍历升序的性质，在二叉搜索树中获取有序数据仅需 𝑂(𝑛) 时间，无须进行额外的排序操作</li>
</ul>
<h4 id="2-二叉搜索树的效率">2.二叉搜索树的效率</h4>
<table>
<thead>
<tr>
<th></th>
<th>无序数组</th>
<th>二叉搜索树</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(log 𝑛)</td>
</tr>
<tr>
<td>插入元素</td>
<td>𝑂(1)</td>
<td>𝑂(log 𝑛)</td>
</tr>
<tr>
<td>删除元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(log 𝑛)</td>
</tr>
</tbody>
</table>
<ul>
<li>二叉搜索树的各项操作的时间复杂度都是对数阶，具有<strong>稳定</strong> 且<strong>高效</strong> 的性能。</li>
<li>只有在<strong>高频添加</strong> 、<strong>低频查找删除数据</strong> 的场景下，数组比二叉搜索树的效率更高。</li>
</ul>
<p># 理想状态下的二叉树是平衡的，此时可以在 log 𝑛 轮循环内查找任意节点</p>
<p># 但在使用后可能会退化为链表，此时各操作的时间复杂度也会退化为 𝑂(𝑛) 。</p>
<h4 id="3-二叉搜索树常见应用">3.二叉搜索树常见应用</h4>
<ul>
<li>用作系统中的多级索引，实现高效的查找、插入、删除操作。</li>
<li>作为某些搜索算法的底层数据结构。</li>
<li>用于存储数据流，以保持其有序状态。</li>
</ul>
<h3 id="5-AVL树">5.AVL树</h3>
<ul>
<li>二叉搜索树在多次删除和插入后都会严重退化</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR

	subgraph 链表
	4&#x27;&#x27;[4] --&gt; 2&#x27;&#x27;[2]
	2&#x27;&#x27; --&gt; 1&#x27;&#x27;[1]
	end
	
	subgraph 普通二叉树
	4&#x27;[4] --&gt; 2&#x27;[2]
	2&#x27; --&gt; 1&#x27;[1]
	2&#x27; --&gt; 3&#x27;[3]
	end
	
	subgraph 平衡二叉树
	4[4] --&gt; 2[2]
	4 --&gt; 5[5]
	2 --&gt; 1[1]
	2 --&gt; 3[3]
	end
	
	平衡二叉树 --删除节点5--&gt; 普通二叉树
	普通二叉树 --删除节点3--&gt; 链表
</code></pre>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 普通二叉树
	4&#x27;&#x27;[4] --&gt; 3&#x27;&#x27;[3]
	4&#x27;&#x27; --&gt; 5&#x27;&#x27;[5]
	3&#x27;&#x27; --&gt; 2&#x27;&#x27;[2]
	2&#x27;&#x27; --&gt; 1&#x27;&#x27;[1]
	end


	subgraph 平衡二叉树
	4&#x27;[4] --&gt; 3&#x27;[3]
	4&#x27; --&gt; 5&#x27;[5]
	3&#x27; --&gt; 2&#x27;[2]
	end
	

	subgraph 完美二叉树
	4[4] --&gt; 3[3]
	4 --&gt; 5[5]
	end
	
	完美二叉树 --插入节点2--&gt; 平衡二叉树
	平衡二叉树 --插入节点1--&gt; 普通二叉树</code></pre>
<ul>
<li>1962 年 G. M. Adelson‑Velsky 和 E. M. Landis 在 论 文 “An algorithm for the organization of information”中提出了 <strong>AVL 树</strong> 。论文中详细描述了一系列操作，确保<strong>在持续添加和删除节点后</strong> ，AVL 树不会退化，从而使得各种操作的<strong>时间复杂度保持在 𝑂(log 𝑛) 级别</strong> 。</li>
</ul>
<h4 id="1-AVL树常见术语">1.AVL树常见术语</h4>
<ul>
<li>AVL 树既是二叉搜索树，也是平衡二叉树，同时满足这两类二叉树的所有性质，因此是一种<strong>平衡二叉搜索树</strong> （balanced binary search tree）</li>
</ul>
<h5 id="1-节点高度">1.节点高度</h5>
<ul>
<li>由于 AVL 树的相关操作需要获取节点高度，因此需要为节点类添加 height 变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* AVL 树节点结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">TreeNode *<span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode *node;</span><br><span class="line">    </span><br><span class="line">    node = (TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;height = <span class="number">0</span>;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>节点高度：该节点到它的最远叶节点的距离，即所经过的<strong>边</strong> 的数量</li>
</ul>
<p># 叶节点的高度为0</p>
<p># 空节点的高度为-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取节点高度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 空节点高度为 -1 ，叶节点高度为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新节点高度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateHeight</span><span class="params">(TreeNode *node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> lh = height(node-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = height(node-&gt;right);</span><br><span class="line">    <span class="comment">// 节点高度等于最高子树高度 + 1</span></span><br><span class="line">    <span class="keyword">if</span> (lh &gt; rh) &#123;</span><br><span class="line">        node-&gt;height = lh + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;height = rh + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-节点平衡因子">2.节点平衡因子</h5>
<ul>
<li>节点的<strong>平衡因子</strong> （balance factor）：节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为 0 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取平衡因子 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">balanceFactor</span><span class="params">(TreeNode *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 空节点平衡因子为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> height(node-&gt;left) - height(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 设平衡因子为 𝑓 ，则一棵 AVL 树的任意节点的平衡因子皆满足 −1 ≤ 𝑓 ≤ 1 。</p>
<h4 id="2-AVL树旋转">2.AVL树旋转</h4>
<ul>
<li>
<p>AVL 树的特点在于<strong>旋转</strong> 操作，它能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，<strong>旋转操作既能保持二叉搜索树的性质，也能使树重新变为平衡二叉树</strong></p>
</li>
<li>
<p>将平衡因子绝对值 &gt; 1 的节点称为<strong>失衡节点</strong> 。根据节点失衡情况的不同，旋转操作分为四种：</p>
<ul>
<li>右旋</li>
<li>左旋</li>
<li>先右旋后左旋</li>
<li>先左旋后右旋。</li>
</ul>
</li>
</ul>
<h5 id="1-右旋">1.右旋</h5>
<pre><code class="highlight mermaid">flowchart LR
	subgraph B[将该节点记为node，其左节点记为child]
	4&#x27;[4] --&gt; 3&#x27;[&quot;3
	(node)&quot;]
	4&#x27; --&gt; 5&#x27;[5]
	3&#x27; --&gt; 1&#x27;[&quot;1
	(child)&quot;]
	1&#x27; --&gt; 0&#x27;[0]
	end

	subgraph A[失衡的树]
	4[4] --&gt; 3[3]
	4 --&gt; 5[5]
	3 --&gt; 1[1]
	1 --&gt; 0[0]
	end
	
	A --关注失衡节点为根节点的子树--&gt; B</code></pre>
<pre><code class="highlight mermaid">flowchart LR
	subgraph B[恢复平衡]
	4&#x27; --&gt; 1&#x27;
	1&#x27;[1] --&gt; 3&#x27;[3]
	1&#x27; --&gt; 0&#x27;[0]
	4&#x27;[4] --&gt; 5&#x27;[5]
	end


	subgraph A[将失衡节点以child为原点右旋]
	4[4] --&gt; 5[5]
	1[1] --&gt; 3
	1 --&gt; 0[0]
	end
	
	A --用child代替原来node的位置--&gt; B</code></pre>
<ul>
<li><strong>向右旋转</strong> 是一种形象化的说法，实际上需要通过<strong>修改节点指针</strong> 来实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line">TreeNode *<span class="title function_">rightRotate</span><span class="params">(TreeNode *node)</span> &#123;</span><br><span class="line">    TreeNode *child, *grandChild;</span><br><span class="line">    child = node-&gt;left;</span><br><span class="line">    grandChild = child-&gt;right;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    updateHeight(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-左旋">2.左旋</h5>
<ul>
<li>与右旋类似</li>
<li>在逻辑上和右旋是镜像对称的，它们分别解决的两种失衡情况也是对称的</li>
<li>所以只要把上述右旋代码中的left替换为right，right替换为left即可</li>
</ul>
<h5 id="3-先左旋后右旋">3.先左旋后右旋</h5>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 原失衡树
	4[4] --&gt; 3[&quot;3
	(失衡节点)&quot;]
	4 --&gt; 5[5]
	3 --&gt; 1[1]
	1 --&gt; 2[2]
	end
	subgraph 先左旋
	4&#x27;[4] --&gt; 3&#x27;[3]
	4&#x27; --&gt; 5&#x27;[5]
	3&#x27; --&gt; 1&#x27;[1]
	1&#x27; --&gt; 2&#x27;[2]
	end	
	subgraph 再右旋
	4&#x27;&#x27;[4] --&gt; 3&#x27;&#x27;[3]
	4&#x27;&#x27; --&gt; 5&#x27;&#x27;[5]
	3&#x27;&#x27; --&gt; 1&#x27;&#x27;[1]
	1&#x27;&#x27; --&gt; 2&#x27;&#x27;[2]
	end	
	原失衡树 --&gt; 先左旋 --&gt; 再右旋</code></pre>
<h5 id="4-先右旋后左旋">4.先右旋后左旋</h5>
<ul>
<li>和上述同理</li>
</ul>
<h5 id="5-旋转的选择">5.旋转的选择</h5>
<ul>
<li>根据失衡节点的平衡因子已经较高一侧的平衡因子的正负号来确定</li>
</ul>
<table>
<thead>
<tr>
<th>失衡节点的平衡因子</th>
<th>子节点的平衡因子</th>
<th>应采用的旋转方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;1（左偏树）</td>
<td>$\geq$0</td>
<td>右旋</td>
</tr>
<tr>
<td>&gt;1（左偏树）</td>
<td>&lt;0</td>
<td>先左旋后右旋</td>
</tr>
<tr>
<td>&lt;-1（右偏树）</td>
<td>$\leq$0</td>
<td>左旋</td>
</tr>
<tr>
<td>&lt;-1（右偏树）</td>
<td>&gt;0</td>
<td>先右旋后左旋</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">TreeNode *<span class="title function_">rotate</span><span class="params">(TreeNode *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取节点 node 的平衡因子</span></span><br><span class="line">    <span class="type">int</span> bf = balanceFactor(node);</span><br><span class="line">    <span class="comment">// 左偏树</span></span><br><span class="line">    <span class="keyword">if</span> (bf &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor(node-&gt;left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 右旋</span></span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先左旋后右旋</span></span><br><span class="line">            node-&gt;left = leftRotate(node-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右偏树</span></span><br><span class="line">    <span class="keyword">if</span> (bf &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor(node-&gt;right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左旋</span></span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先右旋后左旋</span></span><br><span class="line">            node-&gt;right = rightRotate(node-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平衡树，无须旋转，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 这个函数就可以应对各种失衡情况</p>
<h4 id="3-AVL树常见操作">3.AVL树常见操作</h4>
<h5 id="1-插入节点">1.插入节点</h5>
<ul>
<li>与二叉搜索树类似，但是在插入后可能会导致失衡，所以需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(AVLTree *tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    tree-&gt;root = insertHelper(tree-&gt;root, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 递归插入节点（辅助函数） */</span></span><br><span class="line">TreeNode *<span class="title function_">insertHelper</span><span class="params">(TreeNode *node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newTreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 1. 查找插入位置并插入节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node-&gt;val) &#123;</span><br><span class="line">        node-&gt;left = insertHelper(node-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val) &#123;</span><br><span class="line">        node-&gt;right = insertHelper(node-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 重复节点不插入，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = rotate(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-删除节点">2.删除节点</h5>
<ul>
<li>在二叉搜索树的基础上，需要从底部至顶部执行旋转操作，使所有失衡节点恢复平衡</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="comment">// 由于引入了 stdio.h ，此处无法使用 remove 关键词</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeItem</span><span class="params">(AVLTree *tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode *root = removeHelper(tree-&gt;root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归删除节点（辅助函数） */</span></span><br><span class="line">TreeNode *<span class="title function_">removeHelper</span><span class="params">(TreeNode *node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode *child, *grandChild;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 1. 查找节点并删除 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node-&gt;val) &#123;</span><br><span class="line">        node-&gt;left = removeHelper(node-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val) &#123;</span><br><span class="line">        node-&gt;right = removeHelper(node-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> || node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            child = node-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                child = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点数量 = 0 ，直接删除 node 并返回</span></span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 子节点数量 = 1 ，直接删除 node</span></span><br><span class="line">                node = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点</span></span><br><span class="line">            TreeNode *temp = node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (temp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> tempVal = temp-&gt;val;</span><br><span class="line">            node-&gt;right = removeHelper(node-&gt;right, temp-&gt;val);</span><br><span class="line">            node-&gt;val = tempVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = rotate(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-查找节点">3.查找节点</h5>
<ul>
<li>与二叉搜索树相同</li>
</ul>
<h4 id="4-AVL树典型应用">4.AVL树典型应用</h4>
<ul>
<li>组织和存储大型数据，适用于<strong>高频查找、低频增删</strong> 的场景。</li>
<li>用于构建数据库中的<strong>索引系统</strong> 。</li>
<li><strong>红黑树</strong> 也是一种常见的平衡二叉搜索树。相较于 AVL 树，红黑树的平衡条件更宽松，插入与删除节点所需的旋转操作更少，节点增删操作的平均效率更高。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>

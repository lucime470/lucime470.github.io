<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | 不做花看</title><meta name="author" content="余"><meta name="copyright" content="余"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文系统梳理了Java核心基础，包括基本语法、程序结构（判断、循环、数组）、方法以及面向对象三大特性（封装、继承、多态），并介绍了字符串、集合等常用工具类。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/2025/10/07/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="不做花看">
<meta property="og:description" content="本文系统梳理了Java核心基础，包括基本语法、程序结构（判断、循环、数组）、方法以及面向对象三大特性（封装、继承、多态），并介绍了字符串、集合等常用工具类。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.webp">
<meta property="article:published_time" content="2025-10-07T08:30:44.422Z">
<meta property="article:modified_time" content="2025-10-07T09:06:54.669Z">
<meta property="article:author" content="余">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基础",
  "url": "http://example.com/2025/10/07/Java%E5%9F%BA%E7%A1%80/",
  "image": "http://example.com/img/avatar.webp",
  "datePublished": "2025-10-07T08:30:44.422Z",
  "dateModified": "2025-10-07T09:06:54.669Z",
  "author": [
    {
      "@type": "Person",
      "name": "余",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/10/07/Java%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><style> .post-content h1 { font-size:2.5rem !important; } .post-content h2 { font-size:2rem !important; } .post-content h3 { font-size:1.75rem !important; } .post-content h4 { font-size:1.5rem !important; } .post-content h5 { font-size:1.25rem !important; } .post-content h6 { font-size:1.1rem !important; } </style><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/poems/"><i class="fa-fw fas fa-book"></i><span> 诗句库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">不做花看</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/poems/"><i class="fa-fw fas fa-book"></i><span> 诗句库</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-07T08:30:44.422Z" title="发表于 2025-10-07 16:30:44">2025-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-07T09:06:54.669Z" title="更新于 2025-10-07 17:06:54">2025-10-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Java基础</h1>
<h2 id="1-基础概念">1.基础概念</h2>
<h3 id="1-注释">1.注释</h3>
<h4 id="1-单行注释">1.单行注释</h4>
<ul>
<li>//注释</li>
</ul>
<h4 id="2-多行注释">2.多行注释</h4>
<ul>
<li>/*注释*/</li>
</ul>
<h4 id="3-文档注释">3.文档注释</h4>
<ul>
<li>/**注释*/</li>
</ul>
<h3 id="2-关键字">2.关键字</h3>
<h4 id="1-关键字特点">1.关键字特点</h4>
<ul>
<li>关键字的字母全部<strong>小写</strong></li>
</ul>
<h4 id="2-class">2.class</h4>
<ul>
<li>用于<strong>创建/定义</strong> 一个类
<ul>
<li>类是Java最基本的<strong>组成单元</strong></li>
</ul>
</li>
</ul>
<h3 id="3-字面量">3.字面量</h3>
<table>
<thead>
<tr>
<th>字面量类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数类型</td>
<td>不带小数点的数字</td>
</tr>
<tr>
<td>小数类型</td>
<td>带小数点的数字</td>
</tr>
<tr>
<td>字符串类型</td>
<td>用双引号括起来的内容（即使没有内容）</td>
</tr>
<tr>
<td>字符类型</td>
<td>用单引号括起来的，且内容只能有一个</td>
</tr>
<tr>
<td>布尔类型</td>
<td>布尔值：true/false，表示真假</td>
</tr>
<tr>
<td>空类型</td>
<td>一个特殊的值：null，空值，需要用字符串的形式打印出来，不能直接打印</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>特殊字面量</p>
</li>
<li>
<p>\t 制表符</p>
<ul>
<li>打印的时候，会把前面的字符串的长度去补齐到8，或者是8的整数倍，最少补一个空格，最多补8个空格</li>
<li>在两个字符串中间**+‘\t’+**，可以使中间补齐</li>
</ul>
</li>
</ul>
<h3 id="4-变量">4.变量</h3>
<ul>
<li>在程序执行过程中，其值有可能发生<strong>改变</strong> 的量（数据）</li>
</ul>
<h4 id="基本用法">基本用法</h4>
<h5 id="1-使用场景">1.使用场景</h5>
<ul>
<li>当某个数据经常发生改变时，可以用变量存储，当数据变化时，只要修改变量里面记录的值即可</li>
</ul>
<h5 id="2-定义格式">2.定义格式</h5>
<ul>
<li><strong>数据类型 变量名=数据值；</strong></li>
</ul>
<h5 id="3-使用方式">3.使用方式</h5>
<ul>
<li>
<p>输出打印</p>
</li>
<li>
<p>参与计算</p>
</li>
<li>
<p>修改记录的值</p>
</li>
</ul>
<h5 id="4-注意事项">4.注意事项</h5>
<ul>
<li>只能存一个值</li>
<li>变量名不允许重复定义</li>
<li>一条语句可以定义多个变量</li>
<li>变量在使用之前一定要进行赋值</li>
<li>变量的作用域范围</li>
<li>使用前必须赋值</li>
</ul>
<h3 id="5-计算机中的数据存储">5.计算机中的数据存储</h3>
<ul>
<li>任意数据都是以二进制的形式来存储的</li>
</ul>
<h4 id="1-文本数据">1.文本数据</h4>
<h5 id="1-常见进制">1.常见进制</h5>
<ul>
<li>二进制（bin）：由0和1组成，Java中以0b开头，如果用了0b开头，后面的数字中又有0和以外的数字则报错</li>
<li>十进制（oct）：由0-9组成，不加前缀</li>
<li>八进制（dec）：由0-7组成，以0开头</li>
<li>十六进制（hex）：由0-9和a-f组成，以0x开头</li>
</ul>
<p># 在jdk7后加前缀</p>
<h5 id="2-任意进制转为十进制">2.任意进制转为十进制</h5>
<ul>
<li><strong>每个系数*基数的权次幂 相加</strong>
<ul>
<li>系数：每一位上的数</li>
<li>基数：当前进制数</li>
<li>权：从右向左，依次为0，1，2，3，……</li>
</ul>
</li>
</ul>
<h5 id="3-十进制转为其他进制">3.十进制转为其他进制</h5>
<ul>
<li><strong>除基取余法</strong>：不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来</li>
</ul>
<h5 id="4-ASCII表">4.ASCII表</h5>
<ul>
<li>用7位二进制数字对应字母和符号</li>
<li>可以将字母转化为二进制存储</li>
</ul>
<h5 id="5-编码">5.编码</h5>
<h6 id="1-GB2312编码">1.GB2312编码</h6>
<ul>
<li>简体中文</li>
</ul>
<h6 id="2-BIG5编码">2.BIG5编码</h6>
<ul>
<li>繁体中文</li>
</ul>
<h6 id="3-GBK编码">3.GBK编码</h6>
<ul>
<li>收录汉字，包含国家标准GB13000-1中的全部中日韩汉字，和BIG5编码中的所有汉字</li>
<li>计算机默认编码</li>
</ul>
<h6 id="4-Unicode编码">4.Unicode编码</h6>
<ul>
<li>国际标准字符集，将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言，跨平台的文本信息转化</li>
</ul>
<h4 id="2-图片数据">2.图片数据</h4>
<h5 id="1-黑白图">1.黑白图</h5>
<ul>
<li>每个像素点，0为黑，1为白</li>
</ul>
<h5 id="2-灰度图">2.灰度图</h5>
<ul>
<li>每个像素点，0为黑，255为白，中间数字为不同程度的灰</li>
</ul>
<h5 id="3-彩色图">3.彩色图</h5>
<ul>
<li>
<p>由光学三原色（红绿蓝，rgb）作为一个整体来作为一个像素点，可以通过设置一个像素点中的三原色的深浅来调整颜色</p>
</li>
<li>
<p>每个原色的取值范围都是0-255</p>
</li>
<li>
<p>可以写成十进制（255，120，156）</p>
</li>
<li>
<p>也可以写成十六进制</p>
</li>
</ul>
<h4 id="3-声音数据">3.声音数据</h4>
<ul>
<li>对声波采样，形成波形图，波形图中的每个点会数字对应，采样的点多则还原度高（无损），采样点少则还原度低（全损）</li>
</ul>
<h3 id="6-数据类型">6.数据类型</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>关键字</th>
<th>取值范围</th>
<th>内存占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>byte</td>
<td>-128~127</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>-32768~32767</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>int</td>
<td>十位数</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>十九位数</td>
<td>8</td>
</tr>
<tr>
<td>浮点数</td>
<td>float</td>
<td>-3.401298e-38~3.402823e+38</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>-4.9000000e-324~1.797693e+308</td>
<td>8</td>
</tr>
<tr>
<td>字符</td>
<td>char</td>
<td>0~65535</td>
<td>2</td>
</tr>
<tr>
<td>布尔</td>
<td>boolean</td>
<td>true,false</td>
<td>1</td>
</tr>
</tbody>
</table>
<p># 定义<strong>long类型</strong> 的变量，在数字的后面要<strong>加一个L作为后缀</strong></p>
<p># 同理<strong>float类型</strong> 的变量。数字后<strong>加F作为后缀</strong></p>
<h3 id="7-标识符">7.标识符</h3>
<ul>
<li>标识符：给类，方法，变量等起的名字</li>
</ul>
<h4 id="标识符命名规则">标识符命名规则</h4>
<h5 id="1-硬性要求">1.硬性要求</h5>
<ul>
<li>由数字，字母，下划线，美元符号组成</li>
<li>不能以数字开头</li>
<li>不能是关键字</li>
<li>区分大小写</li>
</ul>
<h5 id="2-软性建议">2.软性建议</h5>
<ul>
<li>
<p>小驼峰命名法（适合方法和变量）</p>
<ul>
<li>
<p>标识符是<strong>一个单词</strong> 的时候，<strong>全部小写</strong>：name</p>
</li>
<li>
<p>标识符由<strong>多个单词</strong> 组成时，<strong>第一个单词的首字母小写</strong>，<strong>其他单词首字母大写</strong>：firstName</p>
</li>
</ul>
</li>
<li>
<p>大驼峰命名法（适合类名）</p>
<ul>
<li>标识符是<strong>一个单词</strong> 的时候，<strong>首字母大写</strong>：Student</li>
<li>标识符由<strong>多个单词</strong> 组成的时候，<strong>每个单词的首字母大写</strong>：GoodStudent</li>
</ul>
</li>
</ul>
<h3 id="8-键盘录入">8.键盘录入</h3>
<h4 id="1-概述">1.概述</h4>
<ul>
<li>java中有一个写好的类叫Scanner，可以接收键盘输入的数据</li>
<li>步骤：
<ul>
<li>导包：在java.util.Scanner这个包</li>
<li>创建对象</li>
<li>接收数据</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">//导包要写在类定义的上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//创建对象，这里只有变量名可以改变</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>sc.nextInt(); <span class="comment">//接收整数类型的数据</span></span><br><span class="line">        System.out.println(i); <span class="comment">//输出数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 两个变量都要接收数据，就要写两遍接收数据的一行，不能在同一行两个变量接收数据</p>
<p># Java中没有提供直接接收字符数据的方法，要先接收字符串数据，再进行转化，用charAct()来获取输入的字符串中的某个字符</p>
<h3 id="9-IDEA">9.IDEA</h3>
<h4 id="1-概述-2">1.概述</h4>
<ul>
<li>结构
<ul>
<li>项目
<ul>
<li>模块
<ul>
<li>包
<ul>
<li>类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-快捷键">2.快捷键</h4>
<ul>
<li>ctrl+alt+L，自动格式代码</li>
<li>ctrl+alt+M，自动抽取方法</li>
<li>alt+insert/alt+Fn+insert，生成构造方法，可以用shift多选</li>
</ul>
<p># PTG插件也可以更快速的实现</p>
<ul>
<li>ctrl+alt+v，快速在调用的方法前生成一个对应数据类型以及变量来接收</li>
</ul>
<p># 例如：sc.nextDouble()，ctrl+alt+v，则生成double v = sc.nextDouble();</p>
<ul>
<li>
<p>ctrl+b，查看源码</p>
</li>
<li>
<p>选中一段代码后ctrl+alt+t，选择被哪种代码包裹，如for，if，while等</p>
</li>
<li>
<p>shift+alt+方向键，将代码移动</p>
</li>
<li>
<p>对报错的地方alt+enter会给出解决方法</p>
</li>
<li>
<p>选中后ctrl+shift+u，全部大写/小写</p>
</li>
</ul>
<h4 id="3-快捷功能">3.快捷功能</h4>
<ul>
<li>
<p>psvm</p>
<ul>
<li>快速生成main方法</li>
</ul>
</li>
<li>
<p>鼠标滚轮/alt</p>
<ul>
<li>竖列选中</li>
</ul>
</li>
<li>
<p>fori</p>
<ul>
<li>快速生成一个for循环其中变量为i</li>
<li>如果在fori前加上数字.则会生成i&lt;这个数字的循环</li>
</ul>
</li>
<li>
<p>数组名.fori</p>
<ul>
<li>快速生成数组的遍历</li>
</ul>
</li>
<li>
<p>集合名.fori</p>
<ul>
<li>快速生成集合的遍历</li>
</ul>
</li>
</ul>
<h2 id="2-运算符">2.运算符</h2>
<ul>
<li>运算符：对字面量或者变量进行操作的符号</li>
<li>表达式：用运算符把字面量或者变量连接起来，<strong>符合java语法</strong> 的句子</li>
</ul>
<h3 id="1-算术运算符">1.算术运算符</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
</tr>
<tr>
<td>%</td>
<td>取模：取余数</td>
</tr>
</tbody>
</table>
<p># 如果有小数参与运算，则结果不一定准确</p>
<p># 如果都是整数参与运算，结果为整数</p>
<h4 id="1-数字相加">1.数字相加</h4>
<h5 id="类型转换">类型转换</h5>
<h6 id="1-隐式转换（自动类型提升）（默认）">1.隐式转换（自动类型提升）（默认）</h6>
<ul>
<li>
<p>把一个取值范围小的数值，转成取值范围大的数据，再进行计算</p>
</li>
<li>
<p>byte，short，char三种类型，在运算时，都会先提升为int再进行运算</p>
</li>
</ul>
<h6 id="2-强制转换">2.强制转换</h6>
<ul>
<li>把一个取值范围大的数值，赋值给取值范围小的变量</li>
<li><strong>目标数据类型 变量名=（目标数据类型）被强转的数据</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a=<span class="number">12.3</span>;</span><br><span class="line"><span class="type">int</span> b=(<span class="type">int</span>)a;</span><br></pre></td></tr></table></figure>
<p># 可能会发生数据错误，可以用<strong>补码</strong> 来解释为什么会出错，以及会转为什么数据</p>
<p># 如果要强转的是变量相加，需要把变量相加<strong>加括号</strong></p>
<h4 id="2-字符串相加">2.字符串相加</h4>
<ul>
<li>当相加操作中出现字符串时，+就是字符串连接符，会将前后的数据进行拼接，产生一个新的字符串</li>
<li><strong>连续进行相加操作时</strong>，<strong>从左到右逐个执行</strong></li>
<li>例如1+2+“人”，从左到右，先1+2没有字符串出现，则进行计算=3，3再余后面的&quot;人&quot;进行拼接，得到3人</li>
</ul>
<h4 id="3-字符相加">3.字符相加</h4>
<ul>
<li>字符加字符/数字时，会先从ASCII中查询相应字符对应的数字，再进行计算</li>
</ul>
<h3 id="2-自增自减运算符">2.自增自减运算符</h3>
<h4 id="1-自增">1.自增</h4>
<ul>
<li>++，变量的值加1</li>
</ul>
<p># 既可以写在变量前，也可以写在变量后</p>
<h4 id="2-自减">2.自减</h4>
<ul>
<li>–，变量的值减1</li>
</ul>
<p># 既可以写在变量前，也可以写在变量后</p>
<h4 id="3-参与计算">3.参与计算</h4>
<ul>
<li>写在变量后，则先用后增/减</li>
<li>写在变量后，则先增/减后用</li>
</ul>
<h3 id="3-赋值运算符">3.赋值运算符</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值</td>
</tr>
<tr>
<td>+=</td>
<td>加后赋值</td>
</tr>
<tr>
<td>-=</td>
<td>减后赋值</td>
</tr>
<tr>
<td>*=</td>
<td>乘后赋值</td>
</tr>
<tr>
<td>/=</td>
<td>除后赋值</td>
</tr>
<tr>
<td>%=</td>
<td>取余后赋值（是两个整数相除的余数）</td>
</tr>
</tbody>
</table>
<p># 除了=，其他都会进行强制转换，转换为前面的变量的类型</p>
<h3 id="4-关系运算符（比较运算符）">4.关系运算符（比较运算符）</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>判断两个变量是否相等，成立为true，否则false</td>
</tr>
<tr>
<td>!=</td>
<td>判断是否不等</td>
</tr>
<tr>
<td>&gt;</td>
<td>判断是否大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>判断是否大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>判断是否小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>判断是否小于等于</td>
</tr>
</tbody>
</table>
<p># 结果都是boolean类型，只有true和false</p>
<h3 id="5-逻辑运算符">5.逻辑运算符</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>逻辑与（且）</td>
<td>并且，两边都为真，结果才为真，1为true，0为false</td>
</tr>
<tr>
<td>|</td>
<td>逻辑或</td>
<td>或者，两边都为假，结果才是假，1为true，0为false</td>
</tr>
<tr>
<td>^</td>
<td>逻辑异或</td>
<td>相同为false，不同为true</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非</td>
<td>取反，真值取反就是假值</td>
</tr>
</tbody>
</table>
<p># &amp;和|可以用<strong>补码</strong> 来解释</p>
<ul>
<li>短路逻辑运算符</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>短路与</td>
<td>结果和&amp;相同，但是有短路效果</td>
</tr>
<tr>
<td>||</td>
<td>短路或</td>
<td>结果和|相同，但是有短路效果</td>
</tr>
</tbody>
</table>
<p># 如果<strong>左边能确定整个表达式的结果</strong>，则右边不执行</p>
<h3 id="6-三元运算符">6.三元运算符</h3>
<ul>
<li>
<p><strong>关系表达式?表达式1:表达式2;</strong></p>
</li>
<li>
<p>先计算关系表达式，如果结果为真，则执行表达式1，为假则执行表达式2</p>
</li>
</ul>
<p># 三元运算符的结果<strong>必须要被使用</strong></p>
<h3 id="7-运算符优先级">7.运算符优先级</h3>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>. () {}</td>
</tr>
<tr>
<td>2</td>
<td>!、~、++、–</td>
</tr>
<tr>
<td>3</td>
<td>*、/、%</td>
</tr>
<tr>
<td>4</td>
<td>+、-</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td>
</tr>
<tr>
<td>6</td>
<td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
</tr>
<tr>
<td>7</td>
<td>==、!=</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
</tr>
<tr>
<td>13</td>
<td>?  :</td>
</tr>
<tr>
<td>14</td>
<td>=、+=、-=、*=、/=、%=、&amp;=</td>
</tr>
</tbody>
</table>
<p># &lt;&lt;左移，补码向左移动，右边就会空出，在这个低位补0，同理右移高位正数补0负数1</p>
<p># &gt;&gt;&gt;无符号右移，向右移动，高位补0</p>
<h3 id="8-原码，反码，补码">8.原码，反码，补码</h3>
<h4 id="1-原码">1.原码</h4>
<ul>
<li>十进制数据的二进制表现形式，最左边是符号位，0为正，1为负</li>
<li>八个bit为一个字节</li>
<li>最大值：01111111=127</li>
<li>最小值：11111111=-127</li>
</ul>
<h5 id="1-原码的计算">1.原码的计算</h5>
<ul>
<li>二进制的计算方式，加1，则直接在末位加1，满二进一</li>
</ul>
<h5 id="2-原码的弊端">2.原码的弊端</h5>
<ul>
<li>用原码对正数进行计算是不会有问题的</li>
<li>但如果是负数计算，结果就出错，实际运算的结果与预期的结果是相反的</li>
</ul>
<h4 id="2-反码">2.反码</h4>
<ul>
<li>为了解决<strong>原码不能计算负数</strong> 的问题而出现的</li>
</ul>
<h5 id="1-反码的计算">1.反码的计算</h5>
<ul>
<li>
<p>正数的反码不变，负数的反码在原码的基础上，符号位不变，数字取反，0变1，1变0</p>
</li>
<li>
<p>如果加1，则在末位加1，满二进一，得到的就是加1后的反码</p>
</li>
</ul>
<h5 id="2-反码的弊端">2.反码的弊端</h5>
<ul>
<li>反码的11111111表示-0，如果再加1，则变为00000000=0</li>
<li>同样类似于-4的反码+7，跨0，会比正确结果小1</li>
</ul>
<p># 因为反码中的0有11111111和00000000两种表示方式</p>
<h4 id="3-补码">3.补码</h4>
<ul>
<li>
<p>在负数的反码的基础上加1，这样-0就是00000000，-1就是11111111，反码再依次向后，形成补码</p>
</li>
<li>
<p>-127就是10000001，-128就是10000000，-128只有补码，没有原码</p>
</li>
<li>
<p><strong>计算机中数字的存储计算都是以补码的形式来操作的</strong></p>
</li>
<li>
<p>所以<strong>一个字节</strong> 的范围就是**-128~127**</p>
</li>
</ul>
<h2 id="3-判断与循环">3.判断与循环</h2>
<h3 id="1-顺序结构">1.顺序结构</h3>
<ul>
<li>java程序默认的执行流程，按照代码的先后顺序，从上到下依次执行</li>
</ul>
<h3 id="2-分支结构">2.分支结构</h3>
<h4 id="1-if语句">1.if语句</h4>
<h5 id="1-第一种格式">1.第一种格式</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算关系表达式的值</li>
<li>如果关系表达式的值为true就执行语句体</li>
<li>如果关系式的值为false就不执行语句体</li>
<li>继续执行后面的其他语句</li>
</ul>
</li>
</ul>
<p># 只有一条语句的时候可以省略，但是尽量不要省略，如定义并初始化一个变量的语句，写成一句，但是是两句，不加{}会报错</p>
<h5 id="2-第二种格式">2.第二种格式</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算关系表达式的值</li>
<li>如果关系表达式的值为true就执行语句1</li>
<li>如果关系表达式的值为false就执行语句2</li>
<li>继续执行后面的语句</li>
</ul>
</li>
</ul>
<h5 id="3-第三种格式">3.第三种格式</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式<span class="number">1</span>)&#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(关系表达式<span class="number">2</span>)&#123;</span><br><span class="line">	语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算关系表达式1的值</li>
<li>如果为true就执行语句体1；如果为false就计算关系表达式2的值</li>
<li>如果为true就执行语句体2；如果为false就计算关系表达式3的值</li>
<li>……</li>
<li>如果所有关系表达式结果都为false，就执行else后的语句</li>
</ul>
</li>
</ul>
<h4 id="2-switch语句">2.switch语句</h4>
<h5 id="1-格式">1.格式</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>;</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span>;</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句体;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>首先计算表达式的值</li>
<li>依次和case后面的值进行比较，如果有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束</li>
<li>如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后结束整个switch语句</li>
</ul>
</li>
</ul>
<p># case后面的值只能是字面量，<strong>不能写变量</strong></p>
<h5 id="2-case穿透">2.case穿透</h5>
<ul>
<li><strong>没有加break</strong>，正常有break就会结束整个switch，如果没有就会一直向下执行，直到有break或者}</li>
</ul>
<p># default也是特殊的case</p>
<ul>
<li>可以在case后面的多个语句重复的时候，利用case穿透</li>
</ul>
<p># 将前面case后面的语句删除，只保留最后一个重复的语句，这样就会一直穿透到最后一个重复语句，然后break</p>
<p># 同时可以将重复的语句的几个值都写在一个，case1，2，3，4，5</p>
<p># 同样也可以用下面的写法优化</p>
<h5 id="3-写法优化">3.写法优化</h5>
<ul>
<li>在jdk12以后</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span> -&gt;&#123;</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span> -&gt;&#123;</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">default</span> -&gt;&#123;</span><br><span class="line">		语句体;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 如果{}中只有一个语句，还能把{}省略，把case/default和语句体写在同一行</p>
<h3 id="3-循环结构">3.循环结构</h3>
<h4 id="1-for循环">1.for循环</h4>
<h5 id="1-格式-2">1.格式</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句;条件判断语句;条件控制语句)&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程
<ul>
<li>执行初始化语句</li>
<li>执行条件判断语句，看其结果是true还是false
<ul>
<li>如果是false，循环结束</li>
<li>如果是true，执行循环体语句</li>
</ul>
</li>
<li>执行条件控制语句</li>
<li>回到第二步继续执行条件判断语句</li>
</ul>
</li>
</ul>
<h5 id="2-注意">2.注意</h5>
<ul>
<li>不要在循环语句中写定义赋值语句，然后在语句外使用，变量只在循环中有效</li>
<li>变量定义在循环中，变量只能在本次循环中有效</li>
</ul>
<h4 id="2-while循环">2.while循环</h4>
<h5 id="1-格式-3">1.格式</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line">while(条件判断语句)&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-和for循环的对比">2.和for循环的对比</h5>
<h6 id="1-相同点">1.相同点</h6>
<ul>
<li>运行规则是一样的</li>
</ul>
<h6 id="2-区别">2.区别</h6>
<ul>
<li>for循环中，控制循环的变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了
<ul>
<li>知道循环次数或者循环的范围</li>
</ul>
</li>
<li>while循环中，控制循环的变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用
<ul>
<li>不知道循环的次数和范围，只知道循环的结束条件</li>
</ul>
</li>
</ul>
<h4 id="3-do……while循环"><a target="_blank" rel="noopener" href="http://3.do">3.do</a>……while循环</h4>
<h5 id="格式">格式</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句);</span><br></pre></td></tr></table></figure>
<ul>
<li>先执行后判断</li>
</ul>
<h4 id="4-无限循环">4.无限循环</h4>
<ul>
<li>for循环中不写条件</li>
<li>while/do……while循环中条件写true</li>
</ul>
<p># 无限循环下面就不能再写代码了，会报错无法达到的代码</p>
<h4 id="5-跳转控制语句">5.跳转控制语句</h4>
<ul>
<li>
<p>continue，用于结束<strong>本次循环</strong>，开始下一次循环</p>
</li>
<li>
<p>break，结束<strong>整个循环</strong></p>
</li>
</ul>
<h2 id="4-数组">4.数组</h2>
<h3 id="1-数组介绍">1.数组介绍</h3>
<ul>
<li>数组指的是一种容器，可以用来存储<strong>同种数据类型</strong> 的多个值</li>
</ul>
<p># 并不一定是完全一样的数组类型，要结合隐式转化</p>
<h3 id="2-数组的定义与静态初始化">2.数组的定义与静态初始化</h3>
<h4 id="1-定义">1.定义</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[];</span><br></pre></td></tr></table></figure>
<h4 id="2-静态初始化">2.静态初始化</h4>
<ul>
<li>
<p>初始化：在内存中，为数组开辟空间，并将数据存入容器中的过程</p>
</li>
<li>
<p>完整格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>简写格式</p>
</li>
<li>
<pre><code>数据类型[] 数组名 = &#123;元素&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\# 初始化后长度不可变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.数组元素访问</span><br><span class="line"></span><br><span class="line">#### 1.数组的地址值</span><br><span class="line"></span><br><span class="line">* 直接打印数组名，会显示数组的地址值，而不是数组里面的元素</span><br><span class="line">* 地址值的格式</span><br><span class="line">  * [：表示当前是一个数组</span><br><span class="line">  * D，I：表示数组里面元素的类型</span><br><span class="line">  * @：间隔符号，固定格式</span><br><span class="line">  * 数字加字母：十六进制，真正的地址值</span><br><span class="line">  * 一般将这些统称为地址值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.索引</span><br><span class="line"></span><br><span class="line">* 索引：也称下标，角标</span><br><span class="line">* **从0开始**，逐个+1，连续不间断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4.数组遍历</span><br><span class="line"></span><br><span class="line">* 数组遍历：将数组中所有的内容取出</span><br><span class="line">* **遍历是指取出数据的过程**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 可以使用循环来遍历数组</span><br><span class="line"></span><br><span class="line">* 数组过长时为了获取数组的长度可以使用**length**</span><br><span class="line"></span><br><span class="line">* 调用方法：</span><br><span class="line"></span><br><span class="line">  * 数组名.length</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 5.数组动态初始化</span><br><span class="line"></span><br><span class="line">* 动态初始化：初始化时只指定数组的长度，由系统分配初始值</span><br><span class="line"></span><br><span class="line">* 格式</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">数据类型[] 数组名 = new 数据类型[数组长度]</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
<li>
<p>默认初始化值</p>
<ul>
<li>整数：0</li>
<li>小数：0.0</li>
<li>字符：/u0000，即空格</li>
<li>布尔：false</li>
<li>引用：null</li>
</ul>
</li>
</ul>
<h4 id="动态与静态的区别">动态与静态的区别</h4>
<ul>
<li>动态：手动指定数组长度，系统给出默认初始化值
<ul>
<li>只明确元素个数，不明确具体数组</li>
</ul>
</li>
<li>静态：手动指定数组元素，系统根据元素个数，计算出数组的长度
<ul>
<li>已经明确了要操作的具体数据，直接静态初始化</li>
</ul>
</li>
</ul>
<h3 id="6-数组内存图">6.数组内存图</h3>
<h4 id="1-内存分配">1.内存分配</h4>
<ul>
<li>
<p>JVM虚拟机，将其内存空间分为五个部分</p>
<ul>
<li>栈：方法运行时使用的空间，如main方法运行，进入方法栈中执行</li>
<li>堆：存储对象或者数组，new来创建的，都存储在堆内存</li>
<li>方法区：存储可以运行的class文件</li>
<li>本地方法栈：JVM在使用操作系统功能的时候使用</li>
<li>寄存器：给cpu使用</li>
</ul>
<p># jdk8后将方法区取消，改为元空间，原方法区的功能放在了堆和元空间中</p>
</li>
</ul>
<h4 id="2-数组的内存">2.数组的内存</h4>
<ul>
<li>main方法进入栈内存
<ul>
<li>定义数组进入栈内存</li>
<li>定义的同时new在堆内存中开辟空间</li>
<li>堆中的空间地址值赋值给栈内存中的数组
<ul>
<li>调用时，先通过栈内存中的数组变量的地址值，找到堆内存中的数据，再通过索引找到对应数据</li>
<li>赋值也同理，覆盖原来索引上的元素
<ul>
<li>创建第二个数组也同理，在堆内存中开辟一个新的独立空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-两个数组指向同一个空间">3.两个数组指向同一个空间</h4>
<ul>
<li>定义完第一个数组后，第二个数组定义并直接将第一个数组赋值给第二个数组，这时候就没有new</li>
<li>堆内存中是同一个空间，两个数组变量的地址值也是相同</li>
<li>修改任意一个数组中的数据，另一个数组也会被修改</li>
</ul>
<h3 id="7-数组常见问题">7.数组常见问题</h3>
<ul>
<li>索引越界异常：访问了数组中不存在的索引</li>
</ul>
<h3 id="8-数组常见操作">8.数组常见操作</h3>
<h4 id="1-求最值">1.求最值</h4>
<ul>
<li>先定义一个变量记录最值（变量初始化的值必须是数组中的一个值）
<ul>
<li>遍历数组获取每一个元素
<ul>
<li>让每一个元素和最值比较，比最值更大/更小，就让变量记录新的元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<p># 遍历输出可以使用print使其输出在同一行</p>
<h4 id="2-求和">2.求和</h4>
<ul>
<li>先定义一个求和变量
<ul>
<li>再循环得到每一个元素
<ul>
<li>加到变量中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-交换数据">3.交换数据</h4>
<ul>
<li>和两个变量交换数据一样
<ul>
<li>将两个索引的数据交换，需要一个空的变量</li>
</ul>
</li>
</ul>
<p># 可以使用循环实现数组首尾交换</p>
<h4 id="4-打乱数据">4.打乱数据</h4>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br></pre></td></tr></table></figure>
<p># 需要先导入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random 变量 = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>构造函数使用当前时间作为种子值</p>
<ul>
<li>
<pre><code class="language-java">变量.nextInt(整数)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    \# 这是Random类中的一个方法，可以返回一个0~整数（不包含）的一个随机数</span><br><span class="line"></span><br><span class="line">  * 再赋值给一个新的变量</span><br><span class="line"></span><br><span class="line">    * 循环遍历数组</span><br><span class="line">      * 从第一个元素开始，和随机数元素交换</span><br><span class="line">        * 获取随机数写在循环中，所以每次生成的随机数不同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5.方法</span><br><span class="line"></span><br><span class="line">### 1.方法的介绍</span><br><span class="line"></span><br><span class="line">#### 1.定义</span><br><span class="line"></span><br><span class="line">* **方法**（method）是程序当中**最小** 的执行单元</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.使用场景</span><br><span class="line"></span><br><span class="line">* 将重复的代码，具有独立功能的代码抽取到方法中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.方法的格式</span><br><span class="line"></span><br><span class="line">#### 1.最简单的</span><br><span class="line"></span><br><span class="line">##### 1.定义</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void 方法名()&#123;</span><br><span class="line">	方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="2-调用">2.调用</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名();</span><br></pre></td></tr></table></figure>
<h4 id="2-带参数的">2.带参数的</h4>
<h5 id="1-定义-2">1.定义</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名(参数<span class="number">1</span>,参数<span class="number">2</span>,……)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-调用-2">2.调用</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名(参数<span class="number">1</span>,参数<span class="number">2</span>,……)</span><br></pre></td></tr></table></figure>
<p># 参数个数必须和方法中的一样</p>
<h5 id="3-形参和实参">3.形参和实参</h5>
<ul>
<li>形参：形式参数，是指方法定义中的参数</li>
<li>实参：实际参数，方法调用中的参数</li>
</ul>
<h4 id="3-带返回值的">3.带返回值的</h4>
<h5 id="1-定义-3">1.定义</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 方法名(参数<span class="number">1</span>,参数<span class="number">2</span>,……)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>return表示<strong>结束方法</strong>，return后就不能再写了</li>
</ul>
<p># 返回类型[]表示返回一个此数据类型的数组</p>
<h5 id="2-调用-3">2.调用</h5>
<h6 id="1-直接调用">1.直接调用</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名(实参);</span><br></pre></td></tr></table></figure>
<h6 id="2-赋值调用">2.赋值调用</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 方法名(实参);</span><br></pre></td></tr></table></figure>
<h6 id="3-输出调用">3.输出调用</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(方法名(实参));</span><br></pre></td></tr></table></figure>
<h3 id="3-方法的重载">3.方法的重载</h3>
<ul>
<li>在<strong>同一个类</strong> 中，定义了<strong>多个同名</strong> 的方法，这些同名的方法具有<strong>同种的功能</strong></li>
<li>每个方法具有不同的参数类型和参数个数，这些同名的方法，就构成了重载关系</li>
<li>参数不同
<ul>
<li>个数不同</li>
<li>类型不同</li>
<li>顺序不同：定义的形参的类型的顺序</li>
</ul>
</li>
</ul>
<p># Java虚拟机会通过参数的不同来区分同名的方法</p>
<h3 id="4-方法的内存">4.方法的内存</h3>
<h4 id="1-方法调用的基本内存原理">1.方法调用的基本内存原理</h4>
<ul>
<li>被调用则入栈，方法中调用了其他的方法则会再将其他的方法入栈，当栈顶的方法使用完后，出栈，再接着运行下面一个方法</li>
</ul>
<h4 id="2-方法传递基本数据类型的内存原理">2.方法传递基本数据类型的内存原理</h4>
<h5 id="基本数据类型">基本数据类型</h5>
<ul>
<li>
<p>变量中存储的是真实的数据</p>
</li>
<li>
<p>数据值是存储在自己的空间中</p>
</li>
<li>
<p>赋值给其他变量，也是赋的真实的值</p>
</li>
<li>
<p>传递基本数据类型时，传递的是真实的数据，形参的改变不会影响实际参数的值</p>
</li>
</ul>
<p># 例如先定义一个变量并赋值为1，再方法中将变量赋值为2，调用方法传入定义的变量，输出变量，此时显示的值仍为1</p>
<p>定义并赋值时，先入栈，然后调用的方法再入栈，给变量赋值为2，然后方法出栈，但是<strong>先入栈的变量并没有被修改值</strong>，所以再打印变量，输出的仍然是原来的值</p>
<p>要解决这个问题，可以在方法中返回修改后的变量，同时使用方法格式中的带返回值的格式中的赋值调用，再赋给一个新的变量，再将这个变量输出</p>
<h4 id="3-方法传递引用数据类型的内存原理">3.方法传递引用数据类型的内存原理</h4>
<h5 id="引用数据类型">引用数据类型</h5>
<ul>
<li>
<p>变量中存储的是地址值，即使用其他空间中的数据，自己空间中存储的是地址值</p>
</li>
<li>
<p>传递引用数据类型，传递的是地址值，形参的改变会影响到实际参数的值</p>
</li>
</ul>
<p># 和数组的内存相同</p>
<h2 id="6-面向对象">6.面向对象</h2>
<h3 id="1-设计对象并使用">1.设计对象并使用</h3>
<h4 id="1-类和对象">1.类和对象</h4>
<ul>
<li>类：是对象共同特征的描述</li>
<li>对象：是真实存在的东西</li>
</ul>
<p># java中必须先设计类，才能获得对象</p>
<h5 id="1-如何定义类">1.如何定义类</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">	<span class="number">1.</span>成员变量（属性）</span><br><span class="line">    <span class="number">2.</span>成员方法（行为）</span><br><span class="line">    <span class="number">3.</span>构造器</span><br><span class="line">    <span class="number">4.</span>代码块</span><br><span class="line">    <span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-如何获得类的对象">2.如何获得类的对象</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>
<h5 id="3-如何使用对象">3.如何使用对象</h5>
<ul>
<li>访问属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.成员变量</span><br></pre></td></tr></table></figure>
<ul>
<li>访问行为</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名(……)</span><br></pre></td></tr></table></figure>
<h4 id="2-类的补充">2.类的补充</h4>
<h5 id="1-定义类的补充事项">1.定义类的补充事项</h5>
<ul>
<li>
<p>用来描述一类事物的类，叫做：Jvavbean类</p>
</li>
<li>
<p>在Jvavbean类中，是不写main方法的</p>
</li>
<li>
<p>编写的main方法的类，叫做测试类</p>
</li>
<li>
<p>测试类中可以创建javabean类的对象并进行赋值调用</p>
</li>
<li>
<p>一个java文件中可以定义多个类，且只能有一个类是public修饰</p>
</li>
<li>
<p>public修饰的类名必须成为代码文件名</p>
</li>
</ul>
<p># 实际开放中一个文件定义一个class类</p>
<ul>
<li>成员变量的完整定义格式是</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 数据类型 变量名 = 初始化值;</span><br></pre></td></tr></table></figure>
<p># 一般无需指定初始化值，存在默认值</p>
<h5 id="2-开发中类的设计">2.开发中类的设计</h5>
<ul>
<li>根据需求，从中提取名词，作为属性</li>
<li>根据需求，从中提取动词，作为行为</li>
</ul>
<h3 id="2-封装">2.封装</h3>
<ul>
<li>封装：如何正确设计对象的属性和方法</li>
</ul>
<p># 面向对象三大特征之一</p>
<h4 id="1-原则">1.原则</h4>
<ul>
<li><strong>对象代表什么，就得到封装对应的数据，并提供数据对应的行为</strong></li>
</ul>
<h4 id="2-private关键字">2.private关键字</h4>
<ul>
<li>
<p>是一个<strong>权限修饰符</strong></p>
</li>
<li>
<p>可以修饰成员（成员变量和成员方法）</p>
</li>
<li>
<p>被private修饰的成员<strong>只能在本类中才能访问</strong></p>
</li>
<li>
<p>保证数据安全性</p>
</li>
</ul>
<p># 与public相反</p>
<ul>
<li>如果要使其他类能够使用，可以提供两个方法
<ul>
<li>set：给成员赋值</li>
<li>get：对外提供成员变量的值</li>
</ul>
</li>
</ul>
<p># 这两个需要用public修饰</p>
<h3 id="3-this关键字">3.this关键字</h3>
<h4 id="1-成员变量和局部变量">1.成员变量和局部变量</h4>
<h5 id="1-局部变量">1.局部变量</h5>
<ul>
<li>定义在方法内</li>
</ul>
<h5 id="2-成员变量">2.成员变量</h5>
<ul>
<li>定义在类内，方法外</li>
</ul>
<h5 id="3-就近原则">3.就近原则</h5>
<ul>
<li>
<p>局部变量和成员变量重名时</p>
</li>
<li>
<p>使用本方法的变量</p>
</li>
</ul>
<h4 id="2-this">2.this</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.变量名</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用成员变量</li>
</ul>
<h3 id="4-构造方法">4.构造方法</h3>
<h4 id="1-概述-3">1.概述</h4>
<ul>
<li>构造方法：也叫构造器，构造函数</li>
<li>作用：在创建对象的时候给成员变量进行赋值的</li>
</ul>
<h4 id="2-构造方法的格式">2.构造方法的格式</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">	修饰符 类名(参数)&#123;</span><br><span class="line">		方法体;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>特点</p>
<ul>
<li>
<p>方法名与类名相同</p>
</li>
<li>
<p>没有返回值类型，void也没有</p>
</li>
<li>
<p>没有具体的返回值（不能由return带回结果数据）</p>
</li>
</ul>
</li>
<li>
<p>执行时机</p>
<ul>
<li>创建对象的时候由虚拟机调用，不能手动调用构造方法</li>
<li>每创建一次对象，就会调用一次构造方法</li>
</ul>
</li>
</ul>
<h4 id="3-构造方法注意事项">3.构造方法注意事项</h4>
<ul>
<li>
<p>定义</p>
<ul>
<li>如果没有定义构造方法，系统将给出一个默认的无参数构造方法</li>
<li>如果定义了构造方法，系统将不再提供默认的构造方法</li>
</ul>
</li>
<li>
<p>重载</p>
<ul>
<li>带参构造方法，和无参数构造方法，两者方法名相同，但是参数不同，这就叫构造方法的重载</li>
</ul>
</li>
<li>
<p>推荐使用方式</p>
<ul>
<li>无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法</li>
</ul>
</li>
</ul>
<h3 id="5-标准JavaBean">5.标准JavaBean</h3>
<ul>
<li>标准的JavaBean类
<ul>
<li>类名要<strong>见名知意</strong></li>
<li>成员变量使用<strong>private修饰</strong></li>
<li>提供至少<strong>两个构造方法</strong>
<ul>
<li>无参构造方法</li>
<li>带全部参数的构造方法</li>
</ul>
</li>
<li>成员方法
<ul>
<li>提供每一个成员变量<strong>对应的set/get</strong></li>
<li>如果还有其他行为，也需要写上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-对象内存图">6.对象内存图</h3>
<h4 id="1-一个对象的内存图">1.一个对象的内存图</h4>
<ul>
<li>例如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>1.加载class文件到<strong>方法区</strong>
<ul>
<li>main（）同时临时存储到方法区</li>
<li>再加载JavaBean类的class文件
<ul>
<li>包含所有成员变量和成员方法等</li>
</ul>
</li>
</ul>
</li>
<li>2.申明局部变量
<ul>
<li>在栈内存中，main方法进栈后，在方法中开辟一个空间即s</li>
</ul>
</li>
<li>3.在堆内存中开辟一个空间
<ul>
<li>new的Student
<ul>
<li>其中存储所有成员变量</li>
<li>还有成员方法的地址
<ul>
<li>指向方法区的方法</li>
<li>用对象调用方法时可以找到对应方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>4.默认初始化
<ul>
<li>给堆内存中的成员变量默认初始化</li>
</ul>
</li>
<li>5.显示初始化
<ul>
<li>如果一开始赋值了，堆内存中的成员变量就按赋的值初始化</li>
</ul>
</li>
<li>6.构造方法初始化
<ul>
<li>空参构造或者有参构造</li>
</ul>
</li>
<li>7.将堆内存中的地址赋值给左边的局部变量
<ul>
<li>堆内存中的地址值赋值给栈内存中的s</li>
</ul>
</li>
<li>8.方法进栈
<ul>
<li>调用方法</li>
</ul>
</li>
<li>9.方法出栈
<ul>
<li>main方法中调用的方法使用完后先出栈</li>
<li>main方法再出栈
<ul>
<li>其中的变量也消失
<ul>
<li>变量指向的堆内存中的空间也消失</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-多个对象的内存图">2.多个对象的内存图</h4>
<ul>
<li>和一个对象的内存图相似</li>
<li>但是JavaBean类的class文件只需要加载一次</li>
<li>堆内存中的两个方法地址都指向方法区的同一个方法</li>
</ul>
<h4 id="3-两个变量指向同一个对象内存图">3.两个变量指向同一个对象内存图</h4>
<ul>
<li>
<p>和前面的两个数组指向同一个空间相似</p>
</li>
<li>
<p>如果将第一个变量赋值null，表示不存在的空间</p>
<ul>
<li>则这个变量就会和堆内存中的空间的连接断开</li>
<li>输出时就会显示NullPointerException报错</li>
</ul>
</li>
<li>
<p>但是第二个变量和堆内存中的空间并没有断开，所以还能正常输出变量</p>
</li>
<li>
<p>如果两个变量都赋值null则和堆内存的连接都断开，堆内存中的空间就变成会垃圾消失</p>
</li>
</ul>
<h4 id="4-this的内存原理">4.this的内存原理</h4>
<ul>
<li>this的本质：代表方法<strong>调用者的地址值</strong></li>
</ul>
<h4 id="5-基本数据类型和引用数据类型的区别">5.基本数据类型和引用数据类型的区别</h4>
<h5 id="1-基本数据类型">1.基本数据类型</h5>
<ul>
<li>数据直接存储在栈内存中</li>
</ul>
<p># 赋值给其他变量，也是赋的真实的值</p>
<h5 id="2-引用数据类型">2.引用数据类型</h5>
<ul>
<li>栈内存中记录的是其他空间的地址值</li>
</ul>
<p># 赋值给其他变量，赋的<strong>地址值</strong></p>
<h4 id="6-局部变量和成员变量的区别">6.局部变量和成员变量的区别</h4>
<table>
<thead>
<tr>
<th>区别</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>类中的位置不同</td>
<td>类中，方法外</td>
<td>方法内，方法申明上</td>
</tr>
<tr>
<td>初始化值不同</td>
<td>有默认初始化值</td>
<td>没有，使用之前需要完成赋值</td>
</tr>
<tr>
<td>内存位置不同</td>
<td>堆内存</td>
<td>栈内存</td>
</tr>
<tr>
<td>生命周期不同</td>
<td>随着对象的创建而存在，随着对象的消失而消失</td>
<td>随着方法的调用而存在，随着方法的运行结束而消失</td>
</tr>
<tr>
<td>作用域</td>
<td>整个类中有效</td>
<td>当前方法中有效</td>
</tr>
</tbody>
</table>
<h2 id="7-字符串">7.字符串</h2>
<h3 id="1-API">1.API</h3>
<ul>
<li>API（Application Programming Interface）：应用程序编程接口</li>
</ul>
<h3 id="2-String">2.String</h3>
<h4 id="1-概述-4">1.概述</h4>
<ul>
<li>
<p>java.lang.String类代表字符串，java程序中的所有字符串文字都为此类的对象</p>
</li>
<li>
<p>字符串的内容是不会发生改变的，它的对象在创建后不能被改变</p>
</li>
</ul>
<p># 要修改就要先对原字符串，创建一个数组，里面存储每个字符，再修改对应的字符</p>
<h4 id="2-创建String对象的两种方式">2.创建String对象的两种方式</h4>
<h5 id="1-直接赋值">1.直接赋值</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sting</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-new">2.new</h5>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String()</td>
<td>创建空白字符串，不含任何内容</td>
</tr>
<tr>
<td>public String(String original)</td>
<td>根据传入的字符串，创建字符串对象</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符数组，创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] chs)</td>
<td>根据字节数组，创建字符串对象</td>
</tr>
</tbody>
</table>
<p># 后两个都要先创建一个对应的数组即char[] chs和byte[] chs</p>
<h5 id="3-内存分析">3.内存分析</h5>
<ul>
<li>有一个单独的串池（StringTable）</li>
</ul>
<p># 7以前在方法区，后在堆内存中</p>
<ul>
<li>
<p><strong>直接创建</strong> 的，在赋值时，系统先在串池观察是否有这个字符串，如果没有则创建，然后将地址赋值到栈内存中的变量，如果有则直接赋值到栈内存中的变量（复用）</p>
</li>
<li>
<p>new的，不会涉及到串池，直接在堆内存中开辟空间，直接把地址值赋值到栈内存中，不会有复用现象，占用更多空间</p>
</li>
</ul>
<p># 键盘录入的也是new的</p>
<h3 id="3-String的比较">3.String的比较</h3>
<h4 id="1-号">1.==号</h4>
<h5 id="1-基本数据类型-2">1.基本数据类型</h5>
<ul>
<li>比较的是具体的数据值</li>
</ul>
<h5 id="2-引用数据类型-2">2.引用数据类型</h5>
<ul>
<li>比较的是数据的的地址值</li>
</ul>
<h4 id="2-bolean-equals方法">2.bolean equals方法</h4>
<ul>
<li>变量名.equals(要比较的字符串)：完全一样结果才是true，否则为false</li>
</ul>
<h4 id="3-bolean-equalslgnoreCase方法">3.bolean equalslgnoreCase方法</h4>
<ul>
<li>变量名.equalslgnoreCase(要比较的字符串)：忽略大小写的比较</li>
</ul>
<h3 id="4-StringBuilder">4.StringBuilder</h3>
<h4 id="1-概述-5">1.概述</h4>
<ul>
<li>StringBuilder可以看作一个容器，创建后里面的内容是可变的</li>
<li>作用：提高字符串的操作效率</li>
</ul>
<h4 id="2-构造方法">2.构造方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringBuilder()</td>
<td>创建一个空白可变字符串对象，不含任何内容</td>
</tr>
<tr>
<td>public StringBuilder(String str)</td>
<td>根据字符串的内容，来创建可变字符串对象</td>
</tr>
</tbody>
</table>
<h4 id="3-常用方法">3.常用方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringBuilder append(任意类型)</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>public StringBuilder reverse()</td>
<td>反转容器中的内容</td>
</tr>
<tr>
<td>public int length()</td>
<td>返回长度（字符出现的个数）</td>
</tr>
<tr>
<td>public String toString()</td>
<td>通过toString()就可以实现把StringBuilder转换为String</td>
</tr>
</tbody>
</table>
<h3 id="5-StringJoiner">5.StringJoiner</h3>
<ul>
<li>StringJoiner和StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的</li>
<li>作用：提高字符串的操作效率，而且代码编写更加简洁</li>
</ul>
<p># 因为在jdk8后才出现，所以使用较少</p>
<h4 id="1-构造方法">1.构造方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringJoiner （间隔符号）</td>
<td>创建一个StringJoiner对象，指定拼接时的间隔符号</td>
</tr>
<tr>
<td>public StringJoiner（间隔符号，开始符号，结束符号）</td>
<td>创建一个StringJoiner对象，指定拼接时的间隔符号，开始符号，结束符号</td>
</tr>
</tbody>
</table>
<h4 id="2-成员方法">2.成员方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public StringJoiner add（添加的内容）</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>public int length（）</td>
<td>返回长度（字符出现的个数）</td>
</tr>
<tr>
<td>public String toString（）</td>
<td>返回一个字符串（该字符串就是拼接之后的结果）</td>
</tr>
</tbody>
</table>
<h3 id="6-字符串原理">6.字符串原理</h3>
<h4 id="1-字符串存储的内存原理">1.字符串存储的内存原理</h4>
<ul>
<li>直接赋值的
<ul>
<li>会<strong>复用</strong> 字符串常量池中的</li>
</ul>
</li>
<li>new出来的
<ul>
<li>不会复用，而是<strong>开辟一个新的空间</strong></li>
</ul>
</li>
</ul>
<h4 id="2-比较的原理">2.==比较的原理</h4>
<ul>
<li><strong>基本数据类型</strong> 比较<strong>数据值</strong></li>
<li><strong>引用数据类型</strong> 比较<strong>地址值</strong></li>
</ul>
<h4 id="3-字符串拼接的底层原理">3.字符串拼接的底层原理</h4>
<ul>
<li>
<p>拼接的时候没有变量，都是字符串</p>
<ul>
<li>触发字符串的优化机制</li>
<li>在编译的时候就已经是最终的结果了</li>
</ul>
</li>
<li>
<p>有变量和字符参与拼接</p>
<ul>
<li>jdk8前使用StringBuilder
<ul>
<li>main方法进栈</li>
<li>变量直接赋值，并且在串池生成一个对应字符串</li>
<li>在堆内存中创建一个StringBuilder的方法，通过append方法将参与的变量和字符放到StringBuilder中</li>
<li>再用toString将其变回字符串，字符串就变成了拼接好的
<ul>
<li>toString中使用了一个名为newString的方法，这个方法在返回的时候是new了一个新的字符串</li>
</ul>
</li>
</ul>
</li>
<li>jdk8
<ul>
<li>先预估最终字符串的长度并创建该长度的数组</li>
<li>把字符存进去后，再把数组整体变成一个字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-StringBuilder提高效率原理图">4.StringBuilder提高效率原理图</h4>
<ul>
<li>main方法进栈</li>
<li>StringBuilder方法进栈，同时在堆内存中开辟空间</li>
<li>调用append方法把字符全部添加到堆内存中的空间中</li>
</ul>
<h4 id="5-StringBuilder原码分析">5.StringBuilder原码分析</h4>
<ul>
<li>在创建的时候会创建一个字节数组，默认<strong>容量</strong> 16，表示最多能存储16</li>
<li>向其中添加字符串时，添加的是ASCII码
<ul>
<li>当添加的字符串大于16，就会扩容，创建一个新的数组，容量=老容量*2+2</li>
<li>如果添加的数据超出了扩容后的容量，则会创建一个当前数据量的容量的数组</li>
</ul>
</li>
</ul>
<h2 id="8-ArrayList">8.ArrayList</h2>
<h3 id="1-集合介绍">1.集合介绍</h3>
<ul>
<li>与数组类似，用于存储元素，但区别于数组的是可以自动扩容</li>
<li>但是集合只能存储引用数据类型
<ul>
<li>如果要存储基本数据类型就要包装类</li>
<li>基本数据类型中int对应Integer，char对应Character，其余数据类型都将首字母大写</li>
</ul>
</li>
</ul>
<h3 id="2-集合">2.集合</h3>
<h4 id="ArrayList">ArrayList</h4>
<ul>
<li>
<p>ArrayList是Java中写好的一个类</p>
</li>
<li>
<p>需要导包：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure>
<h5 id="1-泛型">1.泛型</h5>
<ul>
<li>限定集合中存储数据的类型</li>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;类型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;类型&gt;();</span><br></pre></td></tr></table></figure>
<p># jdk7前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;类型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p># jdk7后</p>
<h5 id="2-成员方法-2">2.成员方法</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(E e)</td>
<td>添加元素，返回值表示是否添加成功</td>
</tr>
<tr>
<td>boolean remove(E e)</td>
<td>删除指定元素，返回值表示是否删除成功</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定索引的元素，返回被删除元素</td>
</tr>
<tr>
<td>E set(int index,E e)</td>
<td>修改指定索引下的元素，返回原来的元素</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>获取指定索引的元素</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中元素的个数</td>
</tr>
</tbody>
</table>
<h2 id="9-面向对象进阶">9.面向对象进阶</h2>
<h3 id="1-static">1.static</h3>
<h4 id="1-static-2">1.static</h4>
<ul>
<li>static表示静态，是Java中的一个修饰符，可以修饰成员方法，成员变量</li>
</ul>
<h5 id="1-静态变量">1.静态变量</h5>
<ul>
<li>
<p>特点：</p>
<ul>
<li>被该类所有对象<strong>共享</strong></li>
<li>不属于对象，属于类</li>
<li><strong>静态变量是随着类的加载而加载的，优先于对象出现</strong></li>
</ul>
</li>
<li>
<p>调用方式：</p>
<ul>
<li>类名调用（推荐）</li>
<li>对象名调用</li>
</ul>
</li>
<li>
<p>内存图</p>
<ul>
<li>
<p>main方法进栈</p>
</li>
<li>
<p>用类名调用静态变量</p>
<ul>
<li>类名的字节码会加载到方法区</li>
<li>在堆内存中会创建一个静态存储位置（静态区）</li>
</ul>
<p># jdk8前静态区在方法区</p>
<ul>
<li>在静态区存入静态变量
<ul>
<li><strong>静态变量是随着类的加载而加载的，优先于对象出现</strong></li>
</ul>
</li>
<li>给变量赋值</li>
</ul>
</li>
<li>
<p>创建一个对象</p>
</li>
<li>
<p>在堆内存中为非静态变量开辟空间</p>
</li>
<li>
<p>给对象的属性赋值</p>
</li>
</ul>
</li>
</ul>
<h5 id="2-静态方法">2.静态方法</h5>
<ul>
<li>
<p>特点：</p>
<ul>
<li>多用于<strong>测试类</strong> 和<strong>工具类</strong>
<ul>
<li>工具类：
<ul>
<li>不描述任何事物的类
<ul>
<li>类名见名知意</li>
<li>私有化构造方法</li>
<li>方法定义为静态便于调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>JavaBean类中很少使用</li>
</ul>
</li>
<li>
<p>调用方式：</p>
<ul>
<li>类名调用（推荐）</li>
<li>对象名调用</li>
</ul>
</li>
</ul>
<h4 id="2-注意事项">2.注意事项</h4>
<ul>
<li>
<p>静态方法只能访问静态变量和静态方法</p>
</li>
<li>
<p>非静态方法可以访问静态变量或静态方法，也可以访问非静态的成员变量和非静态的成员方法</p>
</li>
<li>
<p>静态方法中没有this关键字</p>
</li>
<li>
<p>内存图</p>
<ul>
<li>静态：
<ul>
<li>随着类的加载而加载</li>
</ul>
</li>
<li>非静态：
<ul>
<li>跟对象有关</li>
</ul>
</li>
<li>静态方法不能访问非静态变量（实例变量）：
<ul>
<li>main方法进栈</li>
<li>将对象的字节码文件加载到方法区
<ul>
<li>包含对象的属性变量和方法</li>
</ul>
</li>
<li>将静态的变量存到堆内存中的静态区</li>
<li>静态方法进栈</li>
<li>方法调用变量会到静态区调用
<ul>
<li>但是静态区中只有静态的变量，非静态的在方法区</li>
</ul>
</li>
</ul>
</li>
<li>非静态可以访问所有：
<ul>
<li>main方法进栈</li>
<li>将对象的字节码文件加载到方法区
<ul>
<li>包含对象的属性变量和方法</li>
</ul>
</li>
<li>将静态的变量存到堆内存中的静态区</li>
<li>有new在堆内存中开辟空间
<ul>
<li>存储对象的属性变量</li>
<li>空间关联静态区</li>
</ul>
</li>
<li>空间的地址赋值给栈内存中的变量</li>
<li>非静态方法调用到堆内存中访问开辟的空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-继承">2.继承</h3>
<h4 id="1-概述-6">1.概述</h4>
<ul>
<li>
<p>面向对象的三大特点之一</p>
</li>
<li>
<p>Java中提供一个关键字extends，用这个关键字，可以让一个类和另一个类建立起继承关系</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Student称为<strong>子类（派生类）</strong>，Person称为<strong>父类（基类或超类）</strong></p>
</li>
<li>
<p>将多个子类中重复的代码抽取到父类中，提高了代码的复用性</p>
</li>
<li>
<p>子类可以在父类的基础上，增加其他功能，使子类更强大</p>
</li>
</ul>
<h4 id="2-什么时候使用继承">2.什么时候使用继承</h4>
<ul>
<li>在类与类之间，存在相同的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码</li>
</ul>
<h4 id="3-特点">3.特点</h4>
<ul>
<li>Java只支持单继承，不支持多继承，但支持多层继承，子类只能<strong>访问</strong> 父类中非私有的成员</li>
<li>只支持单继承：
<ul>
<li>一个子类只能继承一个父类</li>
</ul>
</li>
<li>不支持多继承：
<ul>
<li>子类不能同时继承多个父类</li>
</ul>
</li>
<li>支持多层继承：
<ul>
<li>子类的父类可以有父类
<ul>
<li>父类的父类就是子类的<strong>间接父类</strong></li>
<li>所有类都直接或间接继承<strong>Object</strong>
<ul>
<li>默认继承于<strong>Object</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-子类能继承的">4.子类能继承的</h4>
<table>
<thead>
<tr>
<th>父类中的</th>
<th>非私有</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造方法</td>
<td>不能</td>
<td>不能</td>
</tr>
<tr>
<td>成员变量</td>
<td>能</td>
<td>能</td>
</tr>
<tr>
<td>成员方法</td>
<td>能</td>
<td>不能</td>
</tr>
</tbody>
</table>
<h5 id="1-构造方法-2">1.构造方法</h5>
<ul>
<li>如果继承父类的构造方法则构造方法的名字和父类相同，但是构造方法的特点是方法名和类名相同</li>
</ul>
<h5 id="2-成员变量-2">2.成员变量</h5>
<ul>
<li>
<p>内存图</p>
<ul>
<li>
<p>main方法进栈</p>
</li>
<li>
<p>字节码加载进方法区</p>
</li>
<li>
<p>将子类的字节码文件加载到方法区</p>
</li>
<li>
<p>将子类的父类的字节码文件加载到方法区</p>
</li>
<li>
<p>在栈内存中声明变量</p>
<ul>
<li>在堆内存中开辟空间
<ul>
<li>把这个空间一分为二</li>
<li>存储子类和父类的成员</li>
</ul>
</li>
</ul>
</li>
<li>
<p>赋值时，先在堆内存的子类中找是否有对应的成员，没有则在父类中找，再赋值</p>
</li>
</ul>
</li>
</ul>
<p># 但是如果父类中的变量private了，则不能赋值</p>
<h5 id="3-成员方法">3.成员方法</h5>
<ul>
<li>不会直接继承方法</li>
<li>而是会有一个<strong>虚方法表</strong>
<ul>
<li>虚方法：
<ul>
<li>非private</li>
<li>非static</li>
<li>非final</li>
</ul>
</li>
</ul>
</li>
<li>每个子类中继承父类的虚方法表的同时再加上自己的虚方法，然后给其子类继承</li>
</ul>
<h4 id="5-继承中的访问特点">5.继承中的访问特点</h4>
<h5 id="1-成员变量">1.成员变量</h5>
<ul>
<li>就近原则：逐级查找最近的变量</li>
<li>如果几个类中的变量重名：
<ul>
<li>不加关键字：从局部开始向上找</li>
<li>加this关键字：从本类中开始向上找</li>
<li>加super关键字：从父类中开始向上找</li>
</ul>
</li>
</ul>
<h5 id="2-成员方法-3">2.成员方法</h5>
<ul>
<li>
<p>与成员变量的特点相同</p>
</li>
<li>
<p>方法的重写：当父类的方法不能满足子类现在的需求时，需要进行方法重写</p>
<ul>
<li>
<p>书写格式：在继承体系中，子类出现了和父类一样的方法声明，则这个子类的方法就是重写的方法</p>
</li>
<li>
<p>@Override重写注解：@Override写在重写后的方法上，校验子类重写时语法是否正确</p>
</li>
<li>
<p>本质：将原来继承的虚方法表中的方法覆盖为当前类的方法，其子类继承的虚方法表也就是覆盖后的虚方法表</p>
</li>
</ul>
</li>
<li>
<p>注意事项</p>
<ul>
<li>重写方法的名称和形参列表必须和父类中的一致</li>
<li>子类重写父类方法时，访问权限子类必须大于等于父类</li>
<li>子类重写父类方法时，返回值类型子类必须小于等于父类</li>
<li>只有被添加到虚方法表中的方法才能被重写</li>
</ul>
</li>
</ul>
<h5 id="3-构造方法">3.构造方法</h5>
<ul>
<li>
<p>父类中的构造方法不会被子类继承</p>
</li>
<li>
<p>子类中所有的构造方法默认先访问父类中的无参构造，再执行自己</p>
<ul>
<li>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类就无法使用</li>
<li>子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化</li>
</ul>
</li>
<li>
<p>子类的构造方法第一行语句默认都是super();（不写也是默认存在的），第二行才可以写构造方法</p>
</li>
<li>
<p>如果要调用父类的有参构造，则需要加上super(父类中带参构造的变量名);</p>
</li>
</ul>
<h4 id="6-this，super使用总结">6.this，super使用总结</h4>
<h5 id="1-this">1.this</h5>
<ul>
<li>可以理解为一个变量，表示当前方法调用者的地址值</li>
</ul>
<h5 id="2-super">2.super</h5>
<ul>
<li>代表父类存储空间</li>
</ul>
<h3 id="3-多态">3.多态</h3>
<ul>
<li>面向对象三大特点之一</li>
</ul>
<h4 id="1-概述-7">1.概述</h4>
<ul>
<li>同类型的对象，表现出的不同形态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类类型 对象名称 = 子类对象;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>前提：</p>
<ul>
<li>有继承关系</li>
<li>有父类引用指向子类对象</li>
<li>有方法重写</li>
</ul>
</li>
<li>
<p>好处：</p>
<ul>
<li>使用父类型作为参数，可以接收所有子类的对象</li>
</ul>
</li>
</ul>
<h4 id="2-调用成员的特点">2.调用成员的特点</h4>
<h5 id="1-变量调用">1.变量调用</h5>
<ul>
<li>编译看左边，运行看左边</li>
</ul>
<p># javac在编译的时候看左边的父类中有没有这个变量，有则能编译成功</p>
<p># 运行时，实际获取的就是左边父类中成员变量的值</p>
<h5 id="2-方法调用">2.方法调用</h5>
<ul>
<li>编译看左边，运行看右边</li>
</ul>
<p># javac在编译的时候看左边的父类中有没有这个方法，有则能编译成功</p>
<p># 运行时，实际运行的是子类中的方法</p>
<h4 id="3-优势">3.优势</h4>
<ul>
<li>在多态形式下，右边对象可以实现解耦合，便于扩展和维护</li>
<li>定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性和便利</li>
</ul>
<h4 id="4-弊端">4.弊端</h4>
<ul>
<li>不能使用子类的特有功能</li>
<li>如果要使用就要转换类型</li>
</ul>
<p># 就可以将其转换为真正的子类类型，从而调用子类的特有功能</p>
<p># 转换类型与真实对象类型不一致会报错</p>
<h5 id="判断是否为某一类型并且强制转换">判断是否为某一类型并且强制转换</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名<span class="number">1</span> <span class="keyword">instanceof</span> 类型<span class="number">1</span> 变量名<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p># 如果变量名1是类型1则强转为类型1，转换后变量名为变量名2</p>
<p># 如果不是则不强转，结果返回false</p>
<p># 在jdk14后</p>
<h3 id="4-包，final，权限修饰符，代码块">4.包，final，权限修饰符，代码块</h3>
<h5 id="1-包">1.包</h5>
<ul>
<li>
<p>文件夹，用于管理不同功能的Java类，便于后期代码维护</p>
</li>
<li>
<p>包名规则：</p>
<ul>
<li>公司域名反写+包的作用，全部英文小写，见名知意</li>
</ul>
</li>
<li>
<p>全类名（全限定名）：</p>
<ul>
<li>
<p>包名+类名</p>
</li>
<li>
<p>使用其他类时就要使用全类名</p>
</li>
<li>
<p>或者直接导包：</p>
<ul>
<li>import 全类名</li>
</ul>
</li>
<li>
<p>使用同一个包中的类时，不需要导包</p>
</li>
<li>
<p>java.lang包中的类不需要导包</p>
</li>
<li>
<p>如果同时使用两个包中的同名类，需要用全类名</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-final">2.final</h4>
<h5 id="1-修饰方法">1.修饰方法</h5>
<ul>
<li>表示该方法是最终方法，不能被重写</li>
</ul>
<h5 id="2-修饰类">2.修饰类</h5>
<ul>
<li>表示该类是最终类，不能被继承</li>
</ul>
<h5 id="3-修饰变量">3.修饰变量</h5>
<ul>
<li>
<p>叫做常量，只能被赋值一次</p>
<ul>
<li>常量的命名：
<ul>
<li>单个单词：全部大写</li>
<li>多个单词：全部大写，中间用下划线连接</li>
</ul>
</li>
</ul>
</li>
<li>
<p>修饰的变量是基本数据类型：</p>
<ul>
<li>变量存储的数据值不能发生改变</li>
</ul>
</li>
<li>
<p>修饰的变量是引用数据类型：</p>
<ul>
<li>变量存储的地址值不能发生改变，对象内部的可以改变</li>
</ul>
<p># 例如数组中的值可以变，但是数组的地址值是不能变的</p>
</li>
</ul>
<h4 id="3-权限修饰符">3.权限修饰符</h4>
<h5 id="作用范围">作用范围</h5>
<ul>
<li>private&lt;空&lt;protected&lt;public</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类</th>
<th>同一个包中的其他类</th>
<th>不同包下的子类</th>
<th>不同包下的无关类</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody>
</table>
<p># 如果方法中的代码抽取其他方法中共性的代码，这个方法一般也私有</p>
<h4 id="4-代码块">4.代码块</h4>
<h5 id="1-局部代码块">1.局部代码块</h5>
<ul>
<li>{}中的内容，可以其他结束代码块中的变量的生命周期</li>
</ul>
<p># 但是现在已经不需要节省变量的一点空间了</p>
<h5 id="2-构造代码块">2.构造代码块</h5>
<ul>
<li>把构造方法中重复的内容写在成员位置的代码块</li>
<li>执行时机：
<ul>
<li>在创建本类对象的时候会先执行构造代码块再执行构造方法</li>
</ul>
</li>
</ul>
<p># 使用也较少，因为不够灵活</p>
<h5 id="3-静态代码块">3.静态代码块</h5>
<ul>
<li>格式：
<ul>
<li>static{}</li>
</ul>
</li>
<li>特点：
<ul>
<li>需要通过static关键字修饰，随着类的加载而加载，并且自动触发，只执行一次</li>
</ul>
</li>
<li>使用场景：
<ul>
<li>在类加载的时候，做一些数据初始化的时候使用</li>
</ul>
</li>
</ul>
<h3 id="5-抽象类">5.抽象类</h3>
<h4 id="1-抽象方法">1.抽象方法</h4>
<ul>
<li>
<p>一个方法抽取到父类中，但是子类的具体写法不同，这时候就可以写一个抽象方法，起所在的类就是抽象类</p>
</li>
<li>
<p>抽象方法的定义格式：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象类的定义格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-注意事项-2">2.注意事项</h4>
<ul>
<li>抽象类不能实例化
<ul>
<li>即不能创建对象</li>
</ul>
</li>
<li>抽象类不一定有抽象方法，有抽象方法一定是抽象类</li>
<li>抽象类可以有构造方法
<ul>
<li>当创建子类对象时，给属性进行赋值</li>
</ul>
</li>
<li>抽象类的子类
<ul>
<li>重写抽象类中的所有抽象方法</li>
<li>或者是抽象类</li>
</ul>
</li>
</ul>
<h4 id="3-意义">3.意义</h4>
<ul>
<li>强制子类按照格式重写这个抽象方法</li>
<li>在开发时可以更加统一</li>
</ul>
<h3 id="6-接口">6.接口</h3>
<ul>
<li>一个父类下的几个子类，其他几个可以共享一个方法，但也有不能使用这个方法的，这样就不能写在父类中</li>
<li>这时候就需要接口，只给几个子类使用</li>
<li>和抽象类很像
<ul>
<li>但是一般只表示行为</li>
<li>一般不像抽象类表示一种事物</li>
</ul>
</li>
</ul>
<h4 id="1-定义接口并使用接口">1.定义接口并使用接口</h4>
<ul>
<li>接口用关键字interface来定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口不能实例化</li>
<li>接口和类之间是实现关系，通过implements关键字表示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口的子类（实现类）
<ul>
<li>重写接口中的所有抽象方法</li>
<li>或者是抽象类</li>
</ul>
</li>
</ul>
<h4 id="2-接口中的成员特点">2.接口中的成员特点</h4>
<h5 id="1-成员变量-2">1.成员变量</h5>
<ul>
<li>只能是常量</li>
<li>默认修饰符：public static final</li>
</ul>
<h5 id="2-构造方法-2">2.构造方法</h5>
<ul>
<li>无</li>
</ul>
<h5 id="3-成员方法-2">3.成员方法</h5>
<ul>
<li>只能是抽象方法</li>
<li>默认修饰符：public abstract</li>
</ul>
<p># jdk7前接口中只能定义抽象方法</p>
<h4 id="3-接口和类之间的关系">3.接口和类之间的关系</h4>
<h5 id="1-类和类">1.类和类</h5>
<ul>
<li>继承关系，只能单继承，不能多继承，但是可以多层继承</li>
</ul>
<h5 id="2-类和接口">2.类和接口</h5>
<ul>
<li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li>
</ul>
<p># 在多个接口中有重名的方法，重写的时候所有方法只需要重写一次即可</p>
<h5 id="3-接口和接口">3.接口和接口</h5>
<ul>
<li>继承关系，可以单继承，也可以多继承</li>
</ul>
<p># 实现类在实现的时候就要把接口的继承体系中的所有方法都重写</p>
<h4 id="4-JDK8后的接口">4.JDK8后的接口</h4>
<ul>
<li>
<p>可以定义有方法体的方法，即默认方法</p>
<ul>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以不强制重写，但是重写的时候就要把default去掉</li>
<li>当多个接口中有相同名字的默认方法，子类必须对该方法重写</li>
</ul>
</li>
<li>
<p>允许在接口中定义静态方法，用static修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只能通过接口名调用，不能通过实现类名或者对象名调用</li>
</ul>
</li>
<li>
<p>可以定义私有的方法</p>
<ul>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于静态的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于抽取出方法中重复的代码，再给方法调用，但是不让其他方法调用</li>
</ul>
</li>
</ul>
<p># 私有方法在jdk9后</p>
<h4 id="5-接口的应用">5.接口的应用</h4>
<ul>
<li>
<p>接口代表规则，是行为的抽象，要让一个类拥有这个行为，就让这个类实现对应接口</p>
</li>
<li>
<p>当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方法称之为接口多态</p>
</li>
</ul>
<h4 id="6-适配器设计模式">6.适配器设计模式</h4>
<ul>
<li>
<p><strong>设计模式</strong> ：</p>
<ul>
<li>是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结，使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性，程序的重用性</li>
</ul>
</li>
<li>
<p><strong>适配器设计模式</strong> ：</p>
<ul>
<li>解决接口与接口实现类之间的矛盾问题</li>
<li>当一个接口中有很多抽象方法，但有时候只需要用到其中一部分的时候
<ul>
<li>先编写一个中间类，实现对应接口，对接口中的抽象方法进行空实现，即不写方法体</li>
<li>让真正的实现类继承中间类，并重写需要用到的方法</li>
<li>为了避免其他类创建适配器类的对象，中间类用abstract修饰</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-内部类">7.内部类</h3>
<ul>
<li>
<p>类的五大成员之一</p>
</li>
<li>
<p>在一个类中，再定义一个类</p>
</li>
<li>
<p>内部类表示的事物是外部类的一部分</p>
</li>
<li>
<p>内部类单独出现没有任何意义</p>
</li>
<li>
<p>访问特点：</p>
<ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类要访问内部类的成员，必须创建对象</li>
</ul>
</li>
</ul>
<h4 id="1-成员内部类">1.成员内部类</h4>
<ul>
<li>写在成员位置的，属于外部类的成员</li>
</ul>
<h5 id="1-如何书写">1.如何书写</h5>
<ul>
<li>可以被一些修饰符修饰</li>
<li>成员内部类中的成员，在jdk16后可以定义静态变量</li>
</ul>
<h5 id="2-创建成员内部类">2.创建成员内部类</h5>
<ul>
<li>在外部类中编写方法，对外提供内部类的对象</li>
</ul>
<p># 在内部类私有的时候使用</p>
<p>或</p>
<ul>
<li>直接创建：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = 外部类对象.内部类对象;</span><br></pre></td></tr></table></figure>
<h5 id="3-成员内部类如何获取外部类的成员变量">3.成员内部类如何获取外部类的成员变量</h5>
<ul>
<li>
<p>没有重名的时候可以直接调用</p>
</li>
<li>
<p>有重名时则会<strong>就近原则</strong></p>
</li>
<li>
<p>用this可以调用内部类的方法外的变量</p>
</li>
<li>
<p>要调用外部类的变量则要用<strong>外部类名.this.变量名</strong></p>
</li>
<li>
<p>内存图</p>
<ul>
<li>内部类和外部类是两个字节码加载到方法区</li>
<li>堆内存中开辟两个空间
<ul>
<li>一个是外部类</li>
<li>一个是内部类
<ul>
<li>内部类中除了其本身的成员，还有一个隐藏的this记录外部类对象的地址值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-静态内部类">2.静态内部类</h4>
<ul>
<li>
<p>成员内部类的一种特殊情况</p>
</li>
<li>
<p>被用static修饰</p>
</li>
<li>
<p>创建静态内部类对象的格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.内部类名;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>调用非静态方法的格式</p>
<ul>
<li>先创建对象，用对象调用</li>
</ul>
</li>
<li>
<p>调用静态方法的格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名.方法名();</span><br></pre></td></tr></table></figure>
<h4 id="3-局部内部类">3.局部内部类</h4>
<ul>
<li>将内部类定义在方法里面，类似于方法里面的局部变量</li>
<li>外界是无法直接使用的，需要在方法内部创建对象并使用</li>
<li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li>
</ul>
<h4 id="4-匿名内部类">4.匿名内部类</h4>
<ul>
<li>本质就是隐藏了名字的内部类</li>
<li>可以写在成员位置，也可以写在局部位置</li>
<li>格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名()&#123;</span><br><span class="line">	重写方法;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>其实际名字：外部类名$序号</li>
<li>这个整体就是一个类的子类对象或者是一个接口的实现类对象</li>
<li>应用场景
<ul>
<li>当方法的参数是接口或者类时</li>
<li>可以传递这个接口的实现类对象</li>
<li>但是如果这个实现类对象只使用一次，就没必要定义，可以用匿名内部类简化代码</li>
</ul>
</li>
</ul>
<h2 id="10-常用API">10.常用API</h2>
<h3 id="1-Math">1.Math</h3>
<ul>
<li>用于进行数学计算的工具类</li>
<li><strong>私有化构造方法，所有方法都是静态的</strong></li>
<li>用<strong>Math.方法名</strong> 调用</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public static int abs(int a)</td>
<td>获取参数绝对值</td>
</tr>
<tr>
<td style="text-align:left">public static double ceil(double a)</td>
<td>向上取整</td>
</tr>
<tr>
<td style="text-align:left">public static double floor(float a)</td>
<td>向下取整</td>
</tr>
<tr>
<td style="text-align:left">public static int round(float a)</td>
<td>四舍五入</td>
</tr>
<tr>
<td style="text-align:left">public static int max(int a, int b)</td>
<td>获取两个int值中的较大值</td>
</tr>
<tr>
<td style="text-align:left">public static double pow(double a,double b)</td>
<td>返回a的b次幂的值</td>
</tr>
<tr>
<td style="text-align:left">public static double random()</td>
<td>返回值为double的随机值，0.0-1.0，包含0.0，不包含1.0</td>
</tr>
</tbody>
</table>
<p># 在int类型中的最小值-2147483648没有绝对值</p>
<h3 id="2-System">2.System</h3>
<ul>
<li>工具类，提供了一些于系统相关的方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static void exit(int status)</td>
<td>终止当前运行的Java虚拟机，其中0为正常停止，非0为异常停止</td>
</tr>
<tr>
<td>public static long currentTimeMills()</td>
<td>返回当前系统的时间毫秒值形式</td>
</tr>
<tr>
<td>public static void arraycopy(数据源数组，起始索引，目的地数组，起始索引，拷贝个数)</td>
<td>数组拷贝</td>
</tr>
</tbody>
</table>
<p># 数组拷贝时如果是基本数据类型则数据类型要一致，如果是引用数据类型则子类类型可以赋值给父类类型也不能超过数组长度</p>
<h3 id="3-Runtime">3.Runtime</h3>
<ul>
<li>表示当前虚拟机的运行环境</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static Runtime grtRuntime()</td>
<td>当前系统的运行环境对象</td>
</tr>
<tr>
<td>public void exit(int status)</td>
<td>停止虚拟机</td>
</tr>
<tr>
<td>public int availableProcessors()</td>
<td>获得CPU的线程数</td>
</tr>
<tr>
<td>public long maxMemory()</td>
<td>JVM能从系统中获取总内存大小（单位byte）</td>
</tr>
<tr>
<td>public long totalMemory()</td>
<td>JVM已经从系统中获取总内存大小（单位byte）</td>
</tr>
<tr>
<td>public long freeMemory()</td>
<td>JVM剩余内存大小（单位byte）</td>
</tr>
<tr>
<td>public Process exec(String command)</td>
<td>运行cmd命令</td>
</tr>
</tbody>
</table>
<h3 id="4-Object和Objects">4.Object和Objects</h3>
<ul>
<li>Java中的父类，所有类都直接或简洁的继承于Object类</li>
</ul>
<h4 id="1-Object的构造方法">1.Object的构造方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Object()</td>
<td>空参构造</td>
</tr>
</tbody>
</table>
<h4 id="2-Object的成员方法">2.Object的成员方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String toString()</td>
<td>返回对象的字符串表示形式</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>比较两个对象是否相等</td>
</tr>
<tr>
<td>protected Object clone(int a)</td>
<td>对象克隆</td>
</tr>
</tbody>
</table>
<p># Object中的equals比较的是地址值，一般需要重写用alt+insert选择自动重写，可以比较具体的属性</p>
<p># toString一般也会重写，打印对象时打印属性</p>
<h4 id="3-对象克隆">3.对象克隆</h4>
<ul>
<li>把A对象的属性值完全拷贝给B对象，也叫对象拷贝，对象复制</li>
<li>要重写Object中的clone方法</li>
<li>在JavaBean类中实现接口</li>
</ul>
<h5 id="1-浅克隆">1.浅克隆</h5>
<ul>
<li>基本数据类型直接拷贝数据</li>
<li>引用数据类型直接拷贝地址值</li>
</ul>
<h5 id="2-深克隆">2.深克隆</h5>
<ul>
<li>基本数据类型直接拷贝数据</li>
<li>字符串复用串池的</li>
<li>引用数据类型
<ul>
<li>例如数组</li>
<li>先创建一个新的数组</li>
<li>把原来数组的数据拷贝到新的数组中</li>
<li>再把新的数组的地址值给对象</li>
</ul>
</li>
</ul>
<h4 id="4-Objects">4.Objects</h4>
<ul>
<li>一个工具类，提供一些方法去完成一些功能</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static boolean equals(Object a,Object b)</td>
<td>先做非空判断，比较两个对象</td>
</tr>
<tr>
<td>public static boolean isNull(Object obj)</td>
<td>判断对象是否为null，为null返回true，反之</td>
</tr>
<tr>
<td>public static boolean nonNull(Object obj)</td>
<td>判断对象是否为null，是isNull的结果相反</td>
</tr>
</tbody>
</table>
<h3 id="5-BigInteger和BigDecimal">5.BigInteger和BigDecimal</h3>
<h4 id="1-BigInteger">1.BigInteger</h4>
<h5 id="1-构造方法-3">1.构造方法</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public BigInteger(int num,Random rnd)</td>
<td>获取随机大整数，范围：0~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{num}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
<tr>
<td>public BigInteger(String val)</td>
<td>获取指定的大整数，字符串中必须是整数</td>
</tr>
<tr>
<td>public BigInteger(String val,int radix)</td>
<td>获取指定进制的大整数</td>
</tr>
<tr>
<td>public static BigInteger valueOf(long val)</td>
<td>静态方法获取BigInteger的对象，内部有优化，对常用数字-16~16进行了优化，会提前创建好，如果多次获取不会重新创建新的</td>
</tr>
</tbody>
</table>
<p># 对象一旦创建，内部记录的值不能发生改变</p>
<h5 id="2-常见成员方法">2.常见成员方法</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public BigInteger add(BigInteger val)</td>
<td>加法</td>
</tr>
<tr>
<td>public BigInteger subtract(BigInteger val)</td>
<td>减法</td>
</tr>
<tr>
<td>public BigInteger multiply(BigInteger val)</td>
<td>乘法</td>
</tr>
<tr>
<td>public BigInteger divide(BigInteger val)</td>
<td>除法，获取商</td>
</tr>
<tr>
<td>public BigInteger[] divideAndRemainder(BigInteger val)</td>
<td>除法，获取商和余数，返回数组，0索引的为商，1索引的为余数</td>
</tr>
<tr>
<td>public bollean equals(Object x)</td>
<td>比较是否相同，比较的是属性值</td>
</tr>
<tr>
<td>public BigInteger pow(int exponent)</td>
<td>次幂</td>
</tr>
<tr>
<td>public BigInteger max/min(BigInteger val)</td>
<td>返回较大值/较小值</td>
</tr>
<tr>
<td>public int inValue(BigInteger val)</td>
<td>转为int类型整数，超出范围数据有误</td>
</tr>
</tbody>
</table>
<h5 id="3-底层存储方式">3.底层存储方式</h5>
<ul>
<li>先把一个大整数转化成补码</li>
<li>再把补码每32位分为一组</li>
<li>再把每一组转成各自的十进制</li>
<li>再按顺序放到一个数组中
<ul>
<li>数组的最大长度的理论值是int的最大值：2147483647约为21亿</li>
<li>数组中的每一位能表示的数字范围：-2147483648~2147483647约为42亿</li>
<li>所以BigInteger能表示的最大数字为42亿的21亿次方
<ul>
<li>几乎是无限的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-BigDecimal">2.BigDecimal</h4>
<ul>
<li>计算机中用二进制存储小数通常需要很多位</li>
<li>而在Java中</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用字节数</th>
<th>总bit位数</th>
<th>小数部分bit位数</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4个字节</td>
<td>32个bit位</td>
<td>23个bit位</td>
</tr>
<tr>
<td>double</td>
<td>8个字节</td>
<td>64个bit位</td>
<td>52个bit位</td>
</tr>
</tbody>
</table>
<h5 id="1-作用">1.作用</h5>
<ul>
<li>用于小数的精确计算</li>
<li>用于表示很大的小数</li>
</ul>
<h5 id="2-创建对象">2.创建对象</h5>
<ul>
<li>通过传递double类型的小数来创建对象</li>
</ul>
<p># 可能不精确</p>
<ul>
<li>
<p>通过传递字符串表示的小数来创建对象</p>
</li>
<li>
<p>通过静态方法获取对象</p>
</li>
</ul>
<p># 如果要表示的数字没有超过double的范围，建议使用这种方法</p>
<p># 如果传递0~10之间的整数，包含0和10，那么方法会返回已经创建好的对象，不会new</p>
<h5 id="3-使用">3.使用</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static BigDecimal valueOf(double val)</td>
<td>获取对象</td>
</tr>
<tr>
<td>public BigDecimal add(BigDecimal val)</td>
<td>加法</td>
</tr>
<tr>
<td>public BigDecimal subtract(BigDecimal val)</td>
<td>减法</td>
</tr>
<tr>
<td>public BigDecimal multiply(BigDecimal val)</td>
<td>乘法</td>
</tr>
<tr>
<td>public BigDecimal divide(BigDecimal val)</td>
<td>除法</td>
</tr>
<tr>
<td>public BigDecimal divide(BigDecimal val,精确几位,舍入模式)</td>
<td>除法</td>
</tr>
</tbody>
</table>
<h5 id="4-底层存储方式">4.底层存储方式</h5>
<ul>
<li>将要存储的字符串形式的小数</li>
<li>先遍历每一个字符</li>
<li>然后将这些字符对应的ASCII码存储到数组中</li>
</ul>
<h4 id="6-正则表达式">6.正则表达式</h4>
<ul>
<li>用**.matches(“规则”)** 使用正则表达式</li>
</ul>
<h5 id="1-作用-2">1.作用</h5>
<ul>
<li>校验字符串是否满足规则</li>
<li>在一段文本中查找满足要求的内容</li>
</ul>
<h5 id="2-规则">2.规则</h5>
<p>字符类（只匹配一个字符）</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]</td>
<td>只能是a，b或c</td>
</tr>
<tr>
<td>[^abc]</td>
<td>除了a，b，c之外的任何字符</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>a到z A到Z</td>
</tr>
<tr>
<td>[a-d[m-p]]</td>
<td>a到d，或m到p</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[def]]</td>
<td>a-z和d，e，f的交集，即d，e，f</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[^bc]]</td>
<td>a-z和非bc的交集（等同于[ad-z]）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[^m-p]]</td>
<td>a到z和除了m到p的交集（等同于[a-lq-z]</td>
</tr>
</tbody>
</table>
<p>预定义字符（只匹配一个字符）</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任何字符</td>
</tr>
<tr>
<td>\d</td>
<td>一个数字[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字[^0-9]</td>
</tr>
<tr>
<td>\s</td>
<td>一个空白字符[\t\n\x08\f\r]</td>
</tr>
<tr>
<td>\S</td>
<td>非空白字符[^\s]</td>
</tr>
<tr>
<td>\w</td>
<td>[a-zA-A_0-9]英文，数字，下划线</td>
</tr>
<tr>
<td>\W</td>
<td>[^\w]一个非单词字符</td>
</tr>
</tbody>
</table>
<p># 用的时候在\前再加一个\</p>
<p>数量词</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>X?</td>
<td>X，一个或0次</td>
</tr>
<tr>
<td>X*</td>
<td>X，0次或多次</td>
</tr>
<tr>
<td>X+</td>
<td>X，一个或多次</td>
</tr>
<tr>
<td>X{n}</td>
<td>X，正好n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X，至少n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X，至少n次但不超过m次</td>
</tr>
</tbody>
</table>
<h5 id="3-分组">3.分组</h5>
<ul>
<li>用()将规则划分组</li>
<li>以左括号为基准，最左为第一组</li>
</ul>
<h5 id="4-捕获分组">4.捕获分组</h5>
<ul>
<li>后续还要使用本组的数据</li>
<li>在正则内部：
<ul>
<li><strong>\\组号</strong></li>
</ul>
</li>
<li>在正则外部：
<ul>
<li><strong>$组号</strong></li>
</ul>
</li>
</ul>
<h5 id="5-非捕获分组">5.非捕获分组</h5>
<ul>
<li>分组后不需要再使用本组数据，仅仅将数据括起来</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>(?:正则)</td>
<td>获取所有</td>
</tr>
<tr>
<td>(?=正则)</td>
<td>获取前面部分</td>
</tr>
<tr>
<td>(?!正则)</td>
<td>获取不是指定内容的前面部分</td>
</tr>
</tbody>
</table>
<p># 非捕获分组是不会占用组号的</p>
<h4 id="7-JDK7以前时间相关类">7.JDK7以前时间相关类</h4>
<h5 id="1-Date时间类">1.Date时间类</h5>
<ul>
<li>JDK写好的JavaBean类，用来描述时间，精确到毫秒</li>
<li>利用空参构造创建的对象，默认表示系统当前时间</li>
<li>利用有参构造创建的对象，表示指定时间</li>
<li>修改时间对象中的毫秒值
<ul>
<li>setTime(毫秒值);</li>
</ul>
</li>
<li>获取时间对象中的毫秒值
<ul>
<li>getTime();</li>
</ul>
</li>
</ul>
<h5 id="2-SimpleDateFormat类">2.SimpleDateFormat类</h5>
<ul>
<li>格式化：
<ul>
<li>将时间转化形式</li>
</ul>
</li>
<li>解析：
<ul>
<li>将字符串表示的时间变成Date对象</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public SimpleDateFormat()</td>
<td>构造一个SimpleDateFormat，使用默认格式</td>
</tr>
<tr>
<td>public SimpleDateFormat(String pattern)</td>
<td>构造一个SimpleDateFormat，使用指定格式</td>
</tr>
</tbody>
</table>
<p># 其中格式例如：yyyy-MM-dd HH:mm:ss或者yyyy年MM月dd日 HH时mm分ss秒</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public final String format(Date date)</td>
<td>格式化（日期对象转化为字符串）</td>
</tr>
<tr>
<td>public Date parse(String source)</td>
<td>解析（字符串转化为日期对象）</td>
</tr>
</tbody>
</table>
<h5 id="3-Calendar">3.Calendar</h5>
<ul>
<li>
<p>代表系统当前时间的日历对象，可以单独修改，获取时间中的年月日</p>
</li>
<li>
<p>是一个抽象类，不能直接创建对象</p>
</li>
<li>
<p>获取Calendar日历类对象的方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static Calendar getInstance()</td>
<td>获取当前时间的日历对象</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public final Date getTime()</td>
<td>获取日期对象</td>
</tr>
<tr>
<td>public final setTime(Date date)</td>
<td>给日历设置日期对象</td>
</tr>
<tr>
<td>public long getTimeInMillis()</td>
<td>拿到时间毫秒值</td>
</tr>
<tr>
<td>public void setTimeInMillis(long millis)</td>
<td>给日历设置时间毫秒值</td>
</tr>
<tr>
<td>public int get(int field)</td>
<td>取日历中的某个字段信息</td>
</tr>
<tr>
<td>public void set(int field,int value)</td>
<td>修改日历的某个字段信息</td>
</tr>
<tr>
<td>public void add(int field,int amount)</td>
<td>为某个字段增加/减少指定的值</td>
</tr>
</tbody>
</table>
<h4 id="8-JDK8新增时间相关类">8.JDK8新增时间相关类</h4>
<ul>
<li>原有的时间对象是不变的</li>
</ul>
<h5 id="1-Date时间类-2">1.Date时间类</h5>
<ul>
<li>ZoneId：时区</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static Set<String> getAvailableZoneIds()</td>
<td>获取Java中支持的所有时区</td>
</tr>
<tr>
<td>static ZoneId systemDefault()</td>
<td>获取系统默认时区</td>
</tr>
<tr>
<td>static ZoneId of(String zonId)</td>
<td>获取一个指定时区</td>
</tr>
</tbody>
</table>
<ul>
<li>Instant：时间戳</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static Instant now()</td>
<td>获取当前时间的Instant对象（标准时间）</td>
</tr>
<tr>
<td>static Instant ofxxxx(long epochMilli)</td>
<td>根据（秒/毫秒/纳秒）获取Instant对象</td>
</tr>
<tr>
<td>ZonedDate atZone(ZoneId zone)</td>
<td>指定时区</td>
</tr>
<tr>
<td>boolean isxxxx(Instant otherInstant)</td>
<td>判断系列的方法</td>
</tr>
<tr>
<td>Instatnt minusxxx(long millisToSubtract)</td>
<td>减少时间系列的方法</td>
</tr>
<tr>
<td>Instant pulsxxx(long millisToSubstract)</td>
<td>增加时间系列的方法</td>
</tr>
</tbody>
</table>
<p># 其中xxx是Years/Days/Hours/Minutes/Nanos/Seconds/Weeks</p>
<ul>
<li>ZoneDateTime：带时区的时间</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static ZonedDateTime now()</td>
<td>获取当前时间的ZonedDateTime对象</td>
</tr>
<tr>
<td>static ZonedDateTime ofxxxx(……)</td>
<td>获取指定时间的ZonedDateTime对象</td>
</tr>
<tr>
<td>ZonedDateTime withxxx(时间)</td>
<td>修改时间系列的方法</td>
</tr>
<tr>
<td>ZonedDateTime minusxxx(时间)</td>
<td>减少时间系列的方法</td>
</tr>
<tr>
<td>ZonedDateTime plusxxx(时间)</td>
<td>增加时间系列的方法</td>
</tr>
</tbody>
</table>
<h5 id="2-SimpleDateFormat类-2">2.SimpleDateFormat类</h5>
<ul>
<li>DateTimeFoemat：用于时间的格式化和解析</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static DateTimeFormatter ofPattern(格式)</td>
<td>获取格式对象</td>
</tr>
<tr>
<td>String format(时间对象)</td>
<td>按照指定方式格式化</td>
</tr>
</tbody>
</table>
<h5 id="3-Calendar-2">3.Calendar</h5>
<ul>
<li>LocalDate：年月日</li>
<li>LocalTime：时分秒</li>
<li>LocalDateTime：年月日时分秒</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static xxx now()</td>
<td>获取当前时间的对象</td>
</tr>
<tr>
<td>static xxx of(……)</td>
<td>获取指定时间的对象</td>
</tr>
<tr>
<td>get开头的方法</td>
<td>获取日历中的年月日时分秒风信息</td>
</tr>
<tr>
<td>isBefore，isAfter</td>
<td>比较两个LocalDate</td>
</tr>
<tr>
<td>with开头的</td>
<td>修改时间系列的方法</td>
</tr>
<tr>
<td>minus开头的</td>
<td>减少时间系列的方法</td>
</tr>
<tr>
<td>plus开头的</td>
<td>增加时间系列的方法</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public LocalDate toLoacalDate()</td>
<td>LocalDateTime转换成一个LocalDate对象</td>
</tr>
<tr>
<td>public LocalTime toLocalTime()</td>
<td>LocalDateTime转换成一个LocalTime对象</td>
</tr>
</tbody>
</table>
<h5 id="4-工具类">4.工具类</h5>
<ul>
<li>Duration：时间间隔（秒，纳秒）</li>
<li>Period：时间间隔（年月日）</li>
<li>ChronnUnit：时间间隔（所有单位）</li>
</ul>
<h4 id="9-包装类">9.包装类</h4>
<ul>
<li>
<p>基本数据类型对应的引用类型</p>
</li>
<li>
<p>基本数据类型中int对应Integer，char对应Character，其余数据类型都将首字母大写</p>
</li>
<li>
<p>在JDK5提出一个机制：</p>
<ul>
<li>自动装箱
<ul>
<li>把基本数据类型自动的变成其对应的包装类</li>
</ul>
</li>
<li>自动拆箱
<ul>
<li>把包装类自动的变成其对应的基本数据类型</li>
</ul>
</li>
</ul>
</li>
<li>
<p>int和Integer可以看作一个东西，在内部会自动转换</p>
</li>
<li>
<p>Integer成员方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static String toBinaryString(int i)</td>
<td>得到二进制</td>
</tr>
<tr>
<td>public static String toOctalString(int i)</td>
<td>得到八进制</td>
</tr>
<tr>
<td>public static String toHexString(int i)</td>
<td>得到十六进制</td>
</tr>
<tr>
<td>public static int paresInt(String s)</td>
<td>把字符串类型的整数转换为int类型的整数</td>
</tr>
</tbody>
</table>
<p>​</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">余</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/10/07/Java%E5%9F%BA%E7%A1%80/">http://example.com/2025/10/07/Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">不做花看</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951-7/" title="数据结构与算法1-7"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据结构与算法1-7</div></div><div class="info-2"><div class="info-item-1">本文系统梳理数据结构与算法的核心知识，涵盖算法定义、复杂度分析、迭代与递归，以及数组、链表、栈、队列、哈希表、二叉树等关键数据结构的原理、实现与应用，适合计算机学习者构建系统的算法与数据结构基础。</div></div></div></a><a class="pagination-related" href="/2025/10/03/CQB%E7%90%86%E8%AE%BA/" title="CQB理论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CQB理论</div></div><div class="info-2"><div class="info-item-1">CQB是室内近距离战术，核心为“迅猛”与“静默”两种模式。作战流程强调情报分析、战术执行（如死亡漏斗、强弱手位）与团队协作，是高度系统化的特种作战方法。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/27/MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="MySQL基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-27</div><div class="info-item-2">MySQL基础</div></div><div class="info-2"><div class="info-item-1">MySQL是关系型数据库，核心包括数据库与表的增删改查（DDL/DML）、数据查询（DQL）、数据类型、约束及事务特性，是数据库操作的基础。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">余</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lucime470"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.单行注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2.多行注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">3.文档注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%B3%E9%94%AE%E5%AD%97%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.关键字特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-class"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.class</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">1.使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">2.定义格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.4.1.3.</span> <span class="toc-text">3.使用方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.1.4.1.4.</span> <span class="toc-text">4.注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.计算机中的数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1.文本数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E8%BF%9B%E5%88%B6"><span class="toc-number">1.1.5.1.1.</span> <span class="toc-text">1.常见进制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="toc-number">1.1.5.1.2.</span> <span class="toc-text">2.任意进制转为十进制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%B8%BA%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6"><span class="toc-number">1.1.5.1.3.</span> <span class="toc-text">3.十进制转为其他进制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-ASCII%E8%A1%A8"><span class="toc-number">1.1.5.1.4.</span> <span class="toc-text">4.ASCII表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.5.1.5.</span> <span class="toc-text">5.编码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-GB2312%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.5.1.5.1.</span> <span class="toc-text">1.GB2312编码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-BIG5%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.5.1.5.2.</span> <span class="toc-text">2.BIG5编码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-GBK%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.5.1.5.3.</span> <span class="toc-text">3.GBK编码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-Unicode%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.5.1.5.4.</span> <span class="toc-text">4.Unicode编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">2.图片数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%BB%91%E7%99%BD%E5%9B%BE"><span class="toc-number">1.1.5.2.1.</span> <span class="toc-text">1.黑白图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%81%B0%E5%BA%A6%E5%9B%BE"><span class="toc-number">1.1.5.2.2.</span> <span class="toc-text">2.灰度图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%BD%A9%E8%89%B2%E5%9B%BE"><span class="toc-number">1.1.5.2.3.</span> <span class="toc-text">3.彩色图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A3%B0%E9%9F%B3%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">3.声音数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">6.数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.1.7.</span> <span class="toc-text">7.标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">标识符命名规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%A1%AC%E6%80%A7%E8%A6%81%E6%B1%82"><span class="toc-number">1.1.7.1.1.</span> <span class="toc-text">1.硬性要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BD%AF%E6%80%A7%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.1.7.1.2.</span> <span class="toc-text">2.软性建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5"><span class="toc-number">1.1.8.</span> <span class="toc-text">8.键盘录入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">1.概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-IDEA"><span class="toc-number">1.1.9.</span> <span class="toc-text">9.IDEA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-2"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">2.快捷键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BF%AB%E6%8D%B7%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">3.快捷功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.</span> <span class="toc-text">2.运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.算术运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.数字相加</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%88%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87%EF%BC%89%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="toc-number">1.2.1.1.1.1.</span> <span class="toc-text">1.隐式转换（自动类型提升）（默认）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.1.1.1.2.</span> <span class="toc-text">2.强制转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.字符串相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3.字符相加</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.自增自减运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E5%A2%9E"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1.自增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%87%8F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.自减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%82%E4%B8%8E%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3.参与计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.关系运算符（比较运算符）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.三元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.7.</span> <span class="toc-text">7.运算符优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81"><span class="toc-number">1.2.8.</span> <span class="toc-text">8.原码，反码，补码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8E%9F%E7%A0%81"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">1.原码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8E%9F%E7%A0%81%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.8.1.1.</span> <span class="toc-text">1.原码的计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8E%9F%E7%A0%81%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.2.8.1.2.</span> <span class="toc-text">2.原码的弊端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8D%E7%A0%81"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">2.反码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8D%E7%A0%81%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.8.2.1.</span> <span class="toc-text">1.反码的计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%8D%E7%A0%81%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.2.8.2.2.</span> <span class="toc-text">2.反码的弊端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A1%A5%E7%A0%81"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">3.补码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.</span> <span class="toc-text">3.判断与循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.顺序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-if%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1.if语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">1.第一种格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">2.第二种格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">3.第三种格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2.switch语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">1.格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-case%E7%A9%BF%E9%80%8F"><span class="toc-number">1.3.2.2.2.</span> <span class="toc-text">2.case穿透</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%86%99%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.2.3.</span> <span class="toc-text">3.写法优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1.for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">1.格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B3%A8%E6%84%8F"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">2.注意</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2.while循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%BC%E5%BC%8F-3"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">1.格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%92%8Cfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">2.和for循环的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">1.3.3.2.2.1.</span> <span class="toc-text">1.相同点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.3.2.2.2.</span> <span class="toc-text">2.区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-do%E2%80%A6%E2%80%A6while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.do……while循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.3.3.1.</span> <span class="toc-text">格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">4.无限循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">5.跳转控制语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">4.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.数组介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.数组的定义与静态初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2.静态初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%B8%8E%E9%9D%99%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">动态与静态的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.4.3.</span> <span class="toc-text">6.数组内存图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1.内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">2.数组的内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3.两个数组指向同一个空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.4.</span> <span class="toc-text">7.数组常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.5.</span> <span class="toc-text">8.数组常见操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B1%82%E6%9C%80%E5%80%BC"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">1.求最值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B1%82%E5%92%8C"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">2.求和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">3.交换数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%89%93%E4%B9%B1%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">4.打乱数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.5.4.1.</span> <span class="toc-text">2.调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84"><span class="toc-number">1.4.5.5.</span> <span class="toc-text">2.带参数的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.4.5.5.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%B0%83%E7%94%A8-2"><span class="toc-number">1.4.5.5.2.</span> <span class="toc-text">2.调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">1.4.5.5.3.</span> <span class="toc-text">3.形参和实参</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84"><span class="toc-number">1.4.5.6.</span> <span class="toc-text">3.带返回值的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-3"><span class="toc-number">1.4.5.6.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%B0%83%E7%94%A8-3"><span class="toc-number">1.4.5.6.2.</span> <span class="toc-text">2.调用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.5.6.2.1.</span> <span class="toc-text">1.直接调用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E8%B5%8B%E5%80%BC%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.5.6.2.2.</span> <span class="toc-text">2.赋值调用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E8%BE%93%E5%87%BA%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.5.6.2.3.</span> <span class="toc-text">3.输出调用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.6.</span> <span class="toc-text">3.方法的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">1.4.7.</span> <span class="toc-text">4.方法的内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">1.方法调用的基本内存原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">2.方法传递基本数据类型的内存原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.7.2.1.</span> <span class="toc-text">基本数据类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.7.3.</span> <span class="toc-text">3.方法传递引用数据类型的内存原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.7.3.1.</span> <span class="toc-text">引用数据类型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.</span> <span class="toc-text">6.面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.设计对象并使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">1.类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">1.如何定义类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.1.1.2.</span> <span class="toc-text">2.如何获得类的对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.1.1.3.</span> <span class="toc-text">3.如何使用对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E7%9A%84%E8%A1%A5%E5%85%85"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">2.类的补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E8%A1%A5%E5%85%85%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">1.定义类的补充事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BC%80%E5%8F%91%E4%B8%AD%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.5.1.2.2.</span> <span class="toc-text">2.开发中类的设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B0%81%E8%A3%85"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1.原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-private%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2.private关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">1.成员变量和局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">1.局部变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">2.成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">3.就近原则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-this"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">2.this</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-3"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">2.构造方法的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">3.构造方法注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%87%E5%87%86JavaBean"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.标准JavaBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.5.6.</span> <span class="toc-text">6.对象内存图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">1.一个对象的内存图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">2.多个对象的内存图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">3.两个变量指向同一个对象内存图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-this%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.6.4.</span> <span class="toc-text">4.this的内存原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.6.5.</span> <span class="toc-text">5.基本数据类型和引用数据类型的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.6.5.1.</span> <span class="toc-text">1.基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.6.5.2.</span> <span class="toc-text">2.引用数据类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.6.6.</span> <span class="toc-text">6.局部变量和成员变量的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.</span> <span class="toc-text">7.字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-API"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-String"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-4"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BAString%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2.创建String对象的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC"><span class="toc-number">1.6.2.2.1.</span> <span class="toc-text">1.直接赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-new"><span class="toc-number">1.6.2.2.2.</span> <span class="toc-text">2.new</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">1.6.2.2.3.</span> <span class="toc-text">3.内存分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-String%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.String的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%B7"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1.&#x3D;&#x3D;号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">1.6.3.1.1.</span> <span class="toc-text">1.基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">1.6.3.1.2.</span> <span class="toc-text">2.引用数据类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-bolean-equals%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">2.bolean equals方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-bolean-equalslgnoreCase%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">3.bolean equalslgnoreCase方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-StringBuilder"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-5"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">2.构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">3.常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-StringJoiner"><span class="toc-number">1.6.5.</span> <span class="toc-text">5.StringJoiner</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">1.构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">2.成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.字符串原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">1.字符串存储的内存原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%AF%94%E8%BE%83%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">2.&#x3D;&#x3D;比较的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">3.字符串拼接的底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-StringBuilder%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">1.6.6.4.</span> <span class="toc-text">4.StringBuilder提高效率原理图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-StringBuilder%E5%8E%9F%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.6.6.5.</span> <span class="toc-text">5.StringBuilder原码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-ArrayList"><span class="toc-number">1.7.</span> <span class="toc-text">8.ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.集合介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9B%86%E5%90%88"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.7.2.1.1.</span> <span class="toc-text">1.泛型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.7.2.1.2.</span> <span class="toc-text">2.成员方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6"><span class="toc-number">1.8.</span> <span class="toc-text">9.面向对象进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-static"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-static-2"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1.static</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.8.1.1.1.</span> <span class="toc-text">1.静态变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.1.1.2.</span> <span class="toc-text">2.静态方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">2.注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-6"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">2.什么时候使用继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%89%B9%E7%82%B9"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">3.特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%90%E7%B1%BB%E8%83%BD%E7%BB%A7%E6%89%BF%E7%9A%84"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">4.子类能继承的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.8.2.4.1.</span> <span class="toc-text">1.构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-2"><span class="toc-number">1.8.2.4.2.</span> <span class="toc-text">2.成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.2.4.3.</span> <span class="toc-text">3.成员方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">1.8.2.5.</span> <span class="toc-text">5.继承中的访问特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.8.2.5.1.</span> <span class="toc-text">1.成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.8.2.5.2.</span> <span class="toc-text">2.成员方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.2.5.3.</span> <span class="toc-text">3.构造方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-this%EF%BC%8Csuper%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.2.6.</span> <span class="toc-text">6.this，super使用总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-this"><span class="toc-number">1.8.2.6.1.</span> <span class="toc-text">1.this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-super"><span class="toc-number">1.8.2.6.2.</span> <span class="toc-text">2.super</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81"><span class="toc-number">1.8.3.</span> <span class="toc-text">3.多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-7"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">2.调用成员的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E8%B0%83%E7%94%A8"><span class="toc-number">1.8.3.2.1.</span> <span class="toc-text">1.变量调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">1.8.3.2.2.</span> <span class="toc-text">2.方法调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E5%8A%BF"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">3.优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.8.3.4.</span> <span class="toc-text">4.弊端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%9F%90%E4%B8%80%E7%B1%BB%E5%9E%8B%E5%B9%B6%E4%B8%94%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.8.3.4.1.</span> <span class="toc-text">判断是否为某一类型并且强制转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8C%85%EF%BC%8Cfinal%EF%BC%8C%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.8.4.</span> <span class="toc-text">4.包，final，权限修饰符，代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8C%85"><span class="toc-number">1.8.4.0.1.</span> <span class="toc-text">1.包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-final"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">2.final</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.4.1.1.</span> <span class="toc-text">1.修饰方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">1.8.4.1.2.</span> <span class="toc-text">2.修饰类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-number">1.8.4.1.3.</span> <span class="toc-text">3.修饰变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">3.权限修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">1.8.4.2.1.</span> <span class="toc-text">作用范围</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">4.代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B1%80%E9%83%A8%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.8.4.3.1.</span> <span class="toc-text">1.局部代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.8.4.3.2.</span> <span class="toc-text">2.构造代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.8.4.3.3.</span> <span class="toc-text">3.静态代码块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.8.5.</span> <span class="toc-text">5.抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">1.抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">2.注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%84%8F%E4%B9%89"><span class="toc-number">1.8.5.3.</span> <span class="toc-text">3.意义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.6.</span> <span class="toc-text">6.接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">1.定义接口并使用接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">2.接口中的成员特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-2"><span class="toc-number">1.8.6.2.1.</span> <span class="toc-text">1.成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.8.6.2.2.</span> <span class="toc-text">2.构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.8.6.2.3.</span> <span class="toc-text">3.成员方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.8.6.3.</span> <span class="toc-text">3.接口和类之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB%E5%92%8C%E7%B1%BB"><span class="toc-number">1.8.6.3.1.</span> <span class="toc-text">1.类和类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.6.3.2.</span> <span class="toc-text">2.类和接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.6.3.3.</span> <span class="toc-text">3.接口和接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-JDK8%E5%90%8E%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.6.4.</span> <span class="toc-text">4.JDK8后的接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.6.5.</span> <span class="toc-text">5.接口的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.6.6.</span> <span class="toc-text">6.适配器设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.7.</span> <span class="toc-text">7.内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.7.1.</span> <span class="toc-text">1.成员内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E4%B9%A6%E5%86%99"><span class="toc-number">1.8.7.1.1.</span> <span class="toc-text">1.如何书写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.7.1.2.</span> <span class="toc-text">2.创建成员内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.8.7.1.3.</span> <span class="toc-text">3.成员内部类如何获取外部类的成员变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.7.2.</span> <span class="toc-text">2.静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.7.3.</span> <span class="toc-text">3.局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.8.7.4.</span> <span class="toc-text">4.匿名内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%B8%B8%E7%94%A8API"><span class="toc-number">1.9.</span> <span class="toc-text">10.常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Math"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.Math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-System"><span class="toc-number">1.9.2.</span> <span class="toc-text">2.System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Runtime"><span class="toc-number">1.9.3.</span> <span class="toc-text">3.Runtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Object%E5%92%8CObjects"><span class="toc-number">1.9.4.</span> <span class="toc-text">4.Object和Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Object%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">1.Object的构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Object%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">2.Object的成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">3.对象克隆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B5%85%E5%85%8B%E9%9A%86"><span class="toc-number">1.9.4.3.1.</span> <span class="toc-text">1.浅克隆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B7%B1%E5%85%8B%E9%9A%86"><span class="toc-number">1.9.4.3.2.</span> <span class="toc-text">2.深克隆</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Objects"><span class="toc-number">1.9.4.4.</span> <span class="toc-text">4.Objects</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-BigInteger%E5%92%8CBigDecimal"><span class="toc-number">1.9.5.</span> <span class="toc-text">5.BigInteger和BigDecimal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-BigInteger"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">1.BigInteger</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.9.5.1.1.</span> <span class="toc-text">1.构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.5.1.2.</span> <span class="toc-text">2.常见成员方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.5.1.3.</span> <span class="toc-text">3.底层存储方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-BigDecimal"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">2.BigDecimal</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="toc-number">1.9.5.2.1.</span> <span class="toc-text">1.作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.9.5.2.2.</span> <span class="toc-text">2.创建对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.9.5.2.3.</span> <span class="toc-text">3.使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.5.2.4.</span> <span class="toc-text">4.底层存储方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.9.5.3.</span> <span class="toc-text">6.正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8-2"><span class="toc-number">1.9.5.3.1.</span> <span class="toc-text">1.作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%A7%84%E5%88%99"><span class="toc-number">1.9.5.3.2.</span> <span class="toc-text">2.规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%86%E7%BB%84"><span class="toc-number">1.9.5.3.3.</span> <span class="toc-text">3.分组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84"><span class="toc-number">1.9.5.3.4.</span> <span class="toc-text">4.捕获分组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E9%9D%9E%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84"><span class="toc-number">1.9.5.3.5.</span> <span class="toc-text">5.非捕获分组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-JDK7%E4%BB%A5%E5%89%8D%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">1.9.5.4.</span> <span class="toc-text">7.JDK7以前时间相关类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Date%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">1.9.5.4.1.</span> <span class="toc-text">1.Date时间类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-SimpleDateFormat%E7%B1%BB"><span class="toc-number">1.9.5.4.2.</span> <span class="toc-text">2.SimpleDateFormat类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Calendar"><span class="toc-number">1.9.5.4.3.</span> <span class="toc-text">3.Calendar</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-JDK8%E6%96%B0%E5%A2%9E%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">1.9.5.5.</span> <span class="toc-text">8.JDK8新增时间相关类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Date%E6%97%B6%E9%97%B4%E7%B1%BB-2"><span class="toc-number">1.9.5.5.1.</span> <span class="toc-text">1.Date时间类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-SimpleDateFormat%E7%B1%BB-2"><span class="toc-number">1.9.5.5.2.</span> <span class="toc-text">2.SimpleDateFormat类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Calendar-2"><span class="toc-number">1.9.5.5.3.</span> <span class="toc-text">3.Calendar</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.9.5.5.4.</span> <span class="toc-text">4.工具类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.9.5.6.</span> <span class="toc-text">9.包装类</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%958/" title="数据结构与算法8">数据结构与算法8</a><time datetime="2025-12-11T11:38:44.992Z" title="发表于 2025-12-11 19:38:44">2025-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951-7/" title="数据结构与算法1-7">数据结构与算法1-7</a><time datetime="2025-12-11T11:38:41.812Z" title="发表于 2025-12-11 19:38:41">2025-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/07/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2025-10-07T08:30:44.422Z" title="发表于 2025-10-07 16:30:44">2025-10-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/03/CQB%E7%90%86%E8%AE%BA/" title="CQB理论">CQB理论</a><time datetime="2025-10-03T09:37:52.535Z" title="发表于 2025-10-03 17:37:52">2025-10-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/30/%E5%9C%A8butterfly%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%89%AF%E6%A0%87%E9%A2%98%EF%BC%8C%E5%B9%B6%E8%83%BD%E5%A4%9F%E8%BE%93%E5%87%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%AD%E5%BD%95/" title="在butterfly主题添加一个副标题，并能够输出自定义的随机语录">在butterfly主题添加一个副标题，并能够输出自定义的随机语录</a><time datetime="2025-08-30T12:21:45.678Z" title="发表于 2025-08-30 20:21:45">2025-08-30</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 余</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="请输入内容" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
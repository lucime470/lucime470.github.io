<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法1-7 | 不做花看</title><meta name="author" content="余"><meta name="copyright" content="余"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文系统梳理数据结构与算法的核心知识，涵盖算法定义、复杂度分析、迭代与递归，以及数组、链表、栈、队列、哈希表、二叉树等关键数据结构的原理、实现与应用，适合计算机学习者构建系统的算法与数据结构基础。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法1-7">
<meta property="og:url" content="http://example.com/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951-7/index.html">
<meta property="og:site_name" content="不做花看">
<meta property="og:description" content="本文系统梳理数据结构与算法的核心知识，涵盖算法定义、复杂度分析、迭代与递归，以及数组、链表、栈、队列、哈希表、二叉树等关键数据结构的原理、实现与应用，适合计算机学习者构建系统的算法与数据结构基础。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.webp">
<meta property="article:published_time" content="2025-12-11T11:38:41.812Z">
<meta property="article:modified_time" content="2025-12-11T11:41:59.428Z">
<meta property="article:author" content="余">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构与算法1-7",
  "url": "http://example.com/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951-7/",
  "image": "http://example.com/img/avatar.webp",
  "datePublished": "2025-12-11T11:38:41.812Z",
  "dateModified": "2025-12-11T11:41:59.428Z",
  "author": [
    {
      "@type": "Person",
      "name": "余",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951-7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法1-7',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><style> .post-content h1 { font-size:2.5rem !important; } .post-content h2 { font-size:2rem !important; } .post-content h3 { font-size:1.75rem !important; } .post-content h4 { font-size:1.5rem !important; } .post-content h5 { font-size:1.25rem !important; } .post-content h6 { font-size:1.1rem !important; } </style><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/poems/"><i class="fa-fw fas fa-book"></i><span> 诗句库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">不做花看</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构与算法1-7</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/poems/"><i class="fa-fw fas fa-book"></i><span> 诗句库</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法1-7</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-11T11:38:41.812Z" title="发表于 2025-12-11 19:38:41">2025-12-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-11T11:41:59.428Z" title="更新于 2025-12-11 19:41:59">2025-12-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>数据结构与算法</h1>
<h2 id="1-算法">1.算法</h2>
<h3 id="1-算法定义">1.算法定义</h3>
<ul>
<li><strong>算法</strong> （algorithm）是在有限时间内解决特定问题的一组指令或操作步骤</li>
</ul>
<h3 id="2-特性">2.特性</h3>
<ul>
<li>问题是明确的，包含清晰的输入和输出定义。</li>
<li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li>
<li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li>
</ul>
<h3 id="3-与数据结构的关系">3.与数据结构的关系</h3>
<ul>
<li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li>
<li>算法为数据结构注入生命力。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li>
<li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li>
</ul>
<p># 常将数据结构与算法简称为<strong>算法</strong></p>
<h2 id="2-复杂度分析">2.复杂度分析</h2>
<h3 id="1-算法效率评估">1.算法效率评估</h3>
<h4 id="1-算法设计目标">1.算法设计目标</h4>
<h5 id="1-找到问题解法">1.找到问题解法</h5>
<ul>
<li>算法需要在规定的输入范围内可靠地求得问题的正确解。</li>
</ul>
<h5 id="2-寻求最优解法">2.寻求最优解法</h5>
<ul>
<li>同一个问题可能存在多种解法，找到尽可能高效的算法</li>
</ul>
<h4 id="2-算法评估指标">2.算法评估指标</h4>
<h5 id="1-时间效率">1.时间效率</h5>
<ul>
<li>算法运行时间的长短。</li>
</ul>
<h5 id="2-空间效率">2.空间效率</h5>
<ul>
<li>算法占用内存空间的大小</li>
</ul>
<h4 id="3-效率评估方法">3.效率评估方法</h4>
<h5 id="1-实际测试">1.实际测试</h5>
<ul>
<li>在同一台计算机上运行两种不同的算法，监控它们运行的时间和占用的空间</li>
</ul>
<p># 但是存在两种问题：</p>
<p>1.测试环境：在不同的硬件上的测试可能会有不同的结果</p>
<p>2.耗费资源：有时候输入数据量的变化也可能会导致效率不同，而要测试所有规模的数据量会浪费大量计算资源</p>
<h5 id="2-理论估计">2.理论估计</h5>
<ul>
<li>
<p>由于实际测试具有较大的局限性，因此可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为<strong>渐近复杂度分析</strong> （asymptotic complexity analysis），简称<strong>复杂度分析</strong> 。</p>
</li>
<li>
<p>它描述了随着输入数据大小的增加，算法执行所需时间（时间复杂度（time complexity））和空间（空间复杂度（space complexity））的增长趋势</p>
</li>
</ul>
<h3 id="2-迭代与递归">2.迭代与递归</h3>
<h4 id="1-迭代">1.迭代</h4>
<ul>
<li><strong>迭代</strong> （iteration）是一种重复执行某个任务的控制结构。<strong>自下而上</strong> 解决问题</li>
</ul>
<h5 id="1-for循环">1.for循环</h5>
<ul>
<li>适用于预先知道迭代次数时</li>
</ul>
<h5 id="2-while循环">2.while循环</h5>
<ul>
<li>相比于for循环可以自由设计条件变量和更新步骤</li>
</ul>
<p># for循环就是加了语法糖的while循环</p>
<p># <strong>语法糖</strong>：更加便捷的写法</p>
<h5 id="3-嵌套循环">3.嵌套循环</h5>
<ul>
<li>在一个循环结构内嵌套另一个循环结构</li>
</ul>
<h4 id="2-递归">2.递归</h4>
<ul>
<li><strong>递归</strong>（recursion）是一种算法策略，通过函数调用自身来解决问题。<strong>自上而下</strong> 解决问题，将问题分解为子问题，与原问题具有相同的形式，再将子问题分解为更小的子问题。它主要包含两个阶段：
<ul>
<li><strong>递</strong> ：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到<strong>终止条件</strong> 。</li>
<li><strong>归</strong> ：触发<strong>终止条件</strong> 后，程序从最深层的递归函数开始<strong>逐层返回</strong> ，汇聚每一层的结果</li>
</ul>
</li>
</ul>
<p># 例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 终止条件</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 递：递归调用</span></span><br><span class="line">	<span class="type">int</span> res = recur(n - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 归：返回结果</span></span><br><span class="line">	<span class="keyword">return</span> n + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于求累加的函数</p>
<p># 例如求1到5的累加，先调用recur（5），由于n=5，不等于1，所以先暂停计算recur（5）继续调用这个函数recur（4），一直到recur（1）（在recur（1）之前都是<strong>递</strong> 的过程），然后<strong>满足终止条件</strong> 直接返回1，res=1再返回n+res的值=2，计算recur（2）的值返回3，再依次返回到recur（5）得出最终结果</p>
<h5 id="1-调用栈">1.调用栈</h5>
<ul>
<li>
<p>递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。</p>
<ul>
<li>
<p>上下文数据都存储在<strong>栈帧空间</strong> 的内存区域中，因此<strong>递归比迭代更耗费内存空间</strong></p>
</li>
<li>
<p>递归调用函数会产生额外的开销。<strong>因此递归通常比循环的时间效率更低</strong></p>
</li>
</ul>
</li>
<li>
<p>在上述的代码中，在到达recur（1）之前（<strong>触发终止条件之前</strong> ），前面有5-2共4个<strong>未返回的递归函数</strong> ，此时的<strong>递归深度为4</strong> ，通常编程语言允许的递归深度是有限的，过深的递归可能会导致栈溢出错误</p>
</li>
</ul>
<h5 id="2-尾递归">2.尾递归</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tailRecur</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> res)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="comment">// 终止条件</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span> res; <span class="comment">// 尾递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> tailRecur(n - <span class="number">1</span>, res + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 用这段代码求累加，1-5的值，n=5，这里的res设置为0，tailRecur（5，0）未达到终止条件，就会返回tailRecur（4，0+5），依次返回tailRecur（3，（0+5）+4），tailRecur（2，（（0+5）+4）+3），tailRecur（1，（（（0+5）+4）+3）+2），tailRecur（0，（（（0+5）+4）+3）+2）+1）至此到达终止条件，直接返回res的值也就是（（（0+5）+4）+3）+2）+1</p>
<ul>
<li>函数在返回前的<strong>最后一步才进行递归调用</strong> ，<strong>部分</strong> 编译器或解释器会将函数优化，使其在空间效率上与迭代相当，这种情况被称为<strong>尾递归</strong> （tail recursion）</li>
</ul>
<p># 例如python中就不支持尾递归优化，仍然会有栈溢出的问题</p>
<ul>
<li>普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
<ul>
<li>求和操作是在<strong>归</strong> 的过程中执行的，每次返回一层都进行一次求和</li>
</ul>
</li>
<li>尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。
<ul>
<li>求和操作是在<strong>递</strong> 的过程中执行的，<strong>归</strong> 则直接返回结果</li>
</ul>
</li>
</ul>
<h5 id="3-递归树">3.递归树</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)<span class="comment">// 终止条件 f(1) = 0, f(2) = 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> res = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>); <span class="comment">// 递归调用 f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">// 返回结果 f(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 这是一个求斐波拉契数列的递归函数，斐波拉契数列的前两个数是0，1，从第三个数开始是前面两个数的和，所以这里将终止条件设置为1，2，然后返回0，1。例如计算其第5项为几，则fib（5），未到达终止条件就会返回fib（4）和fib（3），分别返回（fib（3），fib（2））和（fib（2），fib（1）），此时fib（2）和fib（1）都已经到达终止条件，返回0，1，而fib（3）继续分解为fib（2），fib（1）再返回值0，1</p>
<p># 每一次调用都生成了两个调用分支，这样就形成了一个类似于树状图的结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        fib(5)</span><br><span class="line">        /     \</span><br><span class="line">   fib(4)     fib(3)</span><br><span class="line">   /    \      /    \</span><br><span class="line">fib(3) fib(2) fib(2) fib(1)</span><br><span class="line">/    \</span><br><span class="line">fib(2) fib(1)</span><br></pre></td></tr></table></figure>
<p># 称其为<strong>层数为4的递归树</strong> （recursion tree）</p>
<ul>
<li>从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要
<ul>
<li>从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。</li>
<li>从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。</li>
</ul>
</li>
</ul>
<h4 id="3-对比">3.对比</h4>
<table>
<thead>
<tr>
<th></th>
<th>迭代</th>
<th>递归</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现方式</td>
<td>循环结构</td>
<td>函数调用自身</td>
</tr>
<tr>
<td>时间效率</td>
<td>效率通常较高，无函数调用开销</td>
<td>每次函数调用都会产生开销</td>
</tr>
<tr>
<td>内存使用</td>
<td>通常使用固定大小的内存空间</td>
<td>累积函数调用可能使用大量的栈帧空间</td>
</tr>
<tr>
<td>适用问题</td>
<td>适用于简单循环任务，代码直观、可读性好</td>
<td>适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰</td>
</tr>
</tbody>
</table>
<h4 id="4-联系">4.联系</h4>
<ul>
<li>
<p>从<strong>栈</strong> 的角度来分析</p>
<ul>
<li>递：当函数被<strong>调用时</strong> ，系统会在<strong>调用栈</strong> 上为该函数<strong>分配新的栈帧</strong> ，用于存储函数的局部变量、参数、返回地址等数据</li>
<li>归：当函数<strong>完成执行并返回时</strong> ，对应的栈帧会被从<strong>调用栈</strong> 上<strong>移除</strong> ，恢复之前函数的执行环境。</li>
</ul>
</li>
<li>
<p>尽管迭代和递归在很多情况下可以互相转化，但不一定值得这样做，有以下两点原因。</p>
<ul>
<li>转化后的代码可能更加难以理解，可读性更差。</li>
<li>对于某些复杂问题，模拟系统调用栈的行为可能非常困难</li>
</ul>
</li>
</ul>
<p># 在实际编程中需要权衡两者</p>
<h3 id="3-时间复杂度">3.时间复杂度</h3>
<ul>
<li>通常不会去具体考虑硬件配置，环境等因素，然后将每一步操作的耗时相加，这种做法不合理也不现实</li>
</ul>
<h4 id="1-统计时间增长趋势">1.统计时间增长趋势</h4>
<ul>
<li>统计<strong>算法运行时间随着数据量变大时的增长趋势</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法 A 的时间复杂度：常数阶，与n的大小无关</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm_A</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 算法 B 的时间复杂度：线性阶，运行时间随n的增大而增大</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm_B</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 算法 C 的时间复杂度：常数阶，与n的大小无关</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm_C</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这种方法将统计<strong>时间</strong> 转化为统计<strong>操作数量</strong></p>
</li>
<li>
<p>但也存在<strong>局限性</strong> ：A和C因为都是常数阶，所以复杂度相同，但是运行时间肯定不相同。同时B是线性阶但是其运行时间随n的大小而变化，较小时B算法就会优于C算法</p>
</li>
</ul>
<h4 id="2-函数渐近上界">2.函数渐近上界</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>; <span class="comment">// +1</span></span><br><span class="line">	a = a + <span class="number">1</span>; <span class="comment">// +1</span></span><br><span class="line">	a = a * <span class="number">2</span>; <span class="comment">// +1</span></span><br><span class="line">	<span class="comment">// 循环 n 次</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// +1（每轮都执行 i ++）</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>); <span class="comment">// +1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>例如上述代码，先进行三次赋值运算，再进行一次循环，这个循环有两个步骤</p>
</li>
<li>
<p>因此将上述代码的操作数量记为一个与输入数据大小n相关的函数T（n）：T（n）=3+2n</p>
</li>
<li>
<p>T（n）函数是线性函数，复杂度是线性阶</p>
</li>
<li>
<p>将线性阶的时间复杂度记为<strong>𝑂(𝑛)</strong> ，这个数学符号称为<strong>大 𝑂 记号</strong> （big‑𝑂 notation），表示函数 𝑇(𝑛) 的<strong>渐近上界</strong> （asymptotic upper bound）：𝑛 &gt; 𝑛0时 ，均有 𝑇(𝑛) ≤ 𝑐 ⋅ 𝑓(𝑛)，记为 𝑇(𝑛) = 𝑂(𝑓(𝑛))</p>
</li>
<li>
<p>时间复杂度分析<strong>本质</strong> 上是计算“操作数量 𝑇(𝑛)”的渐近上界</p>
</li>
<li>
<p>计算渐近上界就是寻找一个函数 𝑓(𝑛) ，使得当 𝑛 趋向于无穷大时，𝑇(𝑛) 和 𝑓(𝑛) 处于相同的增长级别，仅相差一个常数项 𝑐 的倍数。</p>
</li>
</ul>
<h4 id="3-推算方法">3.推算方法</h4>
<h5 id="1-统计操作数量">1.统计操作数量</h5>
<h6 id="1-忽略-𝑇-𝑛-中的常数项">1.<strong>忽略</strong> 𝑇(𝑛) 中的常数项</h6>
<ul>
<li>与n无关，对时间复杂度不产生影响</li>
</ul>
<h6 id="2-省略所有系数">2.省略所有系数</h6>
<ul>
<li>系数对时间复杂度没有影响</li>
</ul>
<h6 id="3-循环嵌套时使用乘法">3.循环嵌套时使用乘法</h6>
<ul>
<li>总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然遵循前两点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>; <span class="comment">// +0（技巧 1）</span></span><br><span class="line">	a = a + n; <span class="comment">// +0（技巧 1）</span></span><br><span class="line">	<span class="comment">// +n（技巧 2）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> * n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// +n*n（技巧 3）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>T（n）=n^2+n</li>
</ul>
<h5 id="2-判断渐近上界">2.判断渐近上界</h5>
<ul>
<li>时间复杂度由𝑇(𝑛) 中<strong>最高阶的项来决定</strong> 。这是因为在 𝑛 趋于无穷大时，最高阶的项将发挥<strong>主导</strong> 作用，其他</li>
</ul>
<p>项的影响都可以忽略</p>
<h4 id="4-常见类型">4.常见类型</h4>
<ul>
<li>𝑂(1) &lt; 𝑂(log 𝑛) &lt; 𝑂(𝑛) &lt; 𝑂(𝑛 log 𝑛) &lt; 𝑂(𝑛2 ) &lt; 𝑂(2𝑛) &lt; 𝑂(𝑛!）</li>
<li>常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt; 指数阶 &lt; 阶乘阶</li>
</ul>
<h5 id="1-常数阶-𝑂-1）">1.常数阶 𝑂(1）</h5>
<ul>
<li>常数阶的操作数量与输入数据大小 𝑛 无关，即不随着 𝑛 的变化而变化</li>
</ul>
<h5 id="2-线性阶𝑂-n）">2.线性阶𝑂(n）</h5>
<ul>
<li>线性阶的操作数量相对于输入数据大小 𝑛 以线性级别增长。线性阶通常出现在单层循环中</li>
</ul>
<p># 例如遍历数组和链表</p>
<ul>
<li><strong>输入数据大小𝑛需根据输入数据的类型来具体确定</strong>，可以是数据大小，也可以是数组长度</li>
</ul>
<h5 id="3-平方阶𝑂-n-2）">3.平方阶𝑂(n^2）</h5>
<ul>
<li>
<p>平方阶的操作数量相对于输入数据大小 𝑛 以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层</p>
<p>循环的时间复杂度都为 𝑂(𝑛) ，因此总体的时间复杂度为 𝑂(𝑛^2 )</p>
</li>
</ul>
<h5 id="4-指数阶𝑂-2-n）">4.指数阶𝑂(2^n）</h5>
<ul>
<li>
<p>在实际算法中，指数阶常出现于<strong>递归函数</strong> 中</p>
</li>
<li>
<p>例如上述的递归数中的斐波拉契数列，每一次调用都生成了两个调用分支</p>
</li>
</ul>
<p># 对于数据规模较大的问题，指数阶是不可接受的，通常需要使用动态规划或贪心算法等来解决。</p>
<h5 id="5-对数阶𝑂-log-n）">5.对数阶𝑂(log n）</h5>
<ul>
<li>对数阶反映了<strong>每轮缩减到一半</strong> 的情况。</li>
<li>时间复杂度为 𝑂(log2 𝑛) ，简记为 𝑂(log 𝑛)</li>
<li>与指数阶类似，对数阶也常出现于<strong>递归函数</strong> 中。</li>
<li>体现了<strong>一分为多</strong> 和<strong>化繁为简</strong> 的算法思想。</li>
</ul>
<p># 准确来说，<strong>一分为 𝑚</strong> 对应的时间复杂度是 𝑂(log𝑚 𝑛) 。</p>
<p>𝑂(log𝑚 𝑛) = 𝑂(log𝑘 𝑛/ log𝑘  𝑚) = 𝑂(log𝑘 𝑛)</p>
<p>底数 𝑚 可以在不影响复杂度的前提下转换。因此我们通常会省略底数 𝑚 ，将对数阶直接记为 𝑂(log 𝑛) 。</p>
<h5 id="6-线性对数阶𝑂-n-log-n）">6.线性对数阶𝑂(n*log n）</h5>
<ul>
<li>线性对数阶常出现于<strong>嵌套循环</strong> 中，两层循环的时间复杂度分别为<strong>𝑂(log 𝑛)</strong> 和<strong>𝑂(𝑛)</strong> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">linearLogRecur</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> count = linearLogRecur(n / <span class="number">2</span>) + linearLogRecur(n / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>主流排序算法的时间复杂度通常为 𝑂(𝑛*log 𝑛) ，例如快速排序、归并排序、堆排序等</li>
</ul>
<h5 id="7-阶乘阶𝑂-n！）">7.阶乘阶𝑂(n！）</h5>
<ul>
<li>乘阶对应数学上的<strong>全排列</strong> 问题。给定 𝑛 个互不重复的元素，求其所有可能的排列方案，方案数量为:</li>
<li>n! = 𝑛 × (𝑛 − 1) × (𝑛 − 2) × ⋯ × 2 × 1</li>
<li>阶乘通常使用<strong>递归</strong> 实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           *</span><br><span class="line">        /     \</span><br><span class="line">       *       *</span><br><span class="line">   /    \        \</span><br><span class="line">  *      *        *</span><br><span class="line">/    \     \        \</span><br><span class="line">*      *     *        *</span><br><span class="line">|  \     \     \        \</span><br><span class="line">*    *     *     *        *</span><br></pre></td></tr></table></figure>
<p># 形成这样的树状图，每次分裂后其中一个不再分裂</p>
<h4 id="5-最差，最佳，平均时间复杂度">5.最差，最佳，平均时间复杂度</h4>
<ul>
<li><strong>算法的时间效率往往不是固定的，而是与输入数据的分布有关</strong> 。</li>
</ul>
<p># 例如有两个数组，现在要返回数字1的索引</p>
<p>a1=[5,4,3,2,1]，需要遍历整个数组，达到<strong>最差复杂度𝑂(𝑛)</strong> ，其对应函数的渐近上界。</p>
<p>a2=[1,2,3,4,5]，不需要继续遍历后面的数字，达到<strong>最佳时间复杂度Ω(1)</strong> ，其对应函数的渐近下界。</p>
<ul>
<li>
<p>实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。而最差时间复杂度更为实用，因为它给出了一个<strong>效率安全值</strong>，让我们可以放心地使用算法。</p>
</li>
<li>
<p><strong>平均时间复杂度</strong>可以体现算法在随机输入数据下的运行效率，用 Θ（theta） 记号来表示（有时候也会用𝑂(𝑛)表示）</p>
</li>
</ul>
<p># 部分算法较为简单可以直接计算平均时间复杂度，但是对于较为复杂的算法则直接用最差时间复杂度来作为评判标准</p>
<h3 id="4-空间复杂度">4.空间复杂度</h3>
<ul>
<li><strong>空间复杂度</strong> （space complexity）用于衡量算法<strong>占用内存空间</strong> 随着数据量变大时的增长趋势。</li>
</ul>
<h4 id="1-算法相关空间">1.算法相关空间</h4>
<ul>
<li>
<p><strong>输入空间</strong> ：用于存储算法的输入数据。</p>
</li>
<li>
<p><strong>暂存空间</strong> ：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</p>
<ul>
<li><strong>暂存数据</strong> ：用于保存算法运行过程中的各种常量、变量、对象等。</li>
<li><strong>栈帧空间</strong> ：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li>
<li><strong>指令空间</strong> ：用于保存编译后的程序指令，在实际统计中通常忽略不计。</li>
</ul>
</li>
<li>
<p><strong>输出空间</strong> ：用于存储算法的输出数据。</p>
</li>
<li>
<p>在分析一段程序的空间复杂度时，<strong>我们通常统计暂存数据、栈帧空间和输出数据三部分</strong> ，但是一般统计<strong>暂存空间</strong> 加上<strong>输出空间</strong></p>
</li>
</ul>
<h4 id="2-推算方法">2.推算方法</h4>
<ul>
<li>
<p>与时间复杂度类似，将统计<strong>操作数量</strong> 转为<strong>使用空间大小</strong></p>
</li>
<li>
<p>但是不同于时间复杂度的是，通常只关注<strong>最差空间复杂度</strong> ，必须确保在所有输入数据下都有足够的内存空间预留。</p>
</li>
<li>
<p>其中最差的含义：</p>
<ul>
<li><strong>以最差输入数据为准</strong> ：对于不同的数据量会有不同的空间复杂度，以最差的为准</li>
<li><strong>以算法运行中的峰值内存为准</strong></li>
</ul>
</li>
<li>
<p>在递归函数中，需要统计<strong>栈帧空间</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">		func();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">return</span> recur(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 例如在这个代码中，loop函数中虽然在循环，但是每次调用后都会返回，会释放掉栈帧空间，空间复杂度为𝑂(1)</p>
<p>而recur递归函数，在归之前会有n个未返回的递归函数，会占用𝑂(n)的空间复杂度</p>
<h4 id="3-常见类型">3.常见类型</h4>
<ul>
<li>
<p>𝑂(1) &lt; 𝑂(log 𝑛) &lt; 𝑂(𝑛) &lt; 𝑂(𝑛^2 ) &lt; 𝑂(2^𝑛)</p>
</li>
<li>
<p>常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 平方阶 &lt; 指数阶</p>
</li>
</ul>
<h5 id="1-常数阶𝑂-1）">1.常数阶𝑂(1）</h5>
<ul>
<li>常数阶常见于数量与输入数据大小 𝑛 <strong>无关</strong> 的常量、变量、对象</li>
</ul>
<p># 需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 𝑂(1)</p>
<h5 id="2-线性阶𝑂-n）-2">2.线性阶𝑂(n）</h5>
<ul>
<li>线性阶常见于元素数量与 𝑛 成<strong>正比</strong> 的数组、链表、栈、队列等</li>
</ul>
<p># n就是这些表和数组的长度</p>
<ul>
<li>在<strong>递归函数</strong> 中，同时有多个未返回的函数，也使用 𝑂(𝑛) 大小的栈帧空间</li>
</ul>
<h5 id="3-平方阶𝑂-n-2）-2">3.平方阶𝑂(n^2）</h5>
<ul>
<li>
<p>平方阶常见于<strong>矩阵</strong> （二维列表）和<strong>图</strong> （由点（nodes）和线（边（edges））组成），元素数量与 𝑛 成平方关系</p>
</li>
<li>
<p>在<strong>递归函数</strong> 中，如递归深度为n，每个递归中又定义了一个数组，总体也占用 𝑂(𝑛^2 ) 空间</p>
</li>
</ul>
<h5 id="4-指数阶𝑂-2-n）-2">4.指数阶𝑂(2^n）</h5>
<ul>
<li>指数阶常见于二叉树，层数为 𝑛 的“满二叉树”的节点数量为 2^𝑛 − 1,占用 𝑂(2^n ) 空间</li>
</ul>
<h5 id="5-对数阶𝑂-log-n）-2">5.对数阶𝑂(log n）</h5>
<ul>
<li>对数阶常见于分治算法。例如归并排序，输入长度为 𝑛 的数组，每轮递归将数组从中点处划分为两半，形成高度为 log 𝑛 的递归树，使用 𝑂(log 𝑛) 栈帧空间。</li>
</ul>
<h4 id="5-权衡时间与空间">5.权衡时间与空间</h4>
<ul>
<li>理想情况下，我们希望算法的时间复杂度和空间复杂度都能达到最优。然而在实际情况中，同时优化时间复杂度和空间复杂度通常非常困难</li>
<li><strong>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然</strong>。我们将牺牲内存空间来提升算法运行速度的思路称为<strong>以空间换时间</strong> ；反之，则称为<strong>以时间换空间</strong> 。</li>
<li>选择哪种思路取决于我们更看重哪个方面。在<strong>大多数情况下</strong> ，<strong>时间比空间更宝贵</strong> ，因此<strong>以空间换时间</strong> 通常是更常用的策略。当然，在<strong>数据量很大</strong> 的情况下，<strong>控制空间复杂度</strong> 也非常重要</li>
</ul>
<h2 id="3-数据结构">3.数据结构</h2>
<h3 id="1-数据结构定义">1.数据结构定义</h3>
<ul>
<li><strong>数据结构</strong> （data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法</li>
</ul>
<h3 id="2-设计目标">2.设计目标</h3>
<ul>
<li><strong>空间占用</strong> 尽量少，以节省计算机内存。</li>
<li><strong>数据操作</strong> 尽可能快速，涵盖数据访问、添加、删除、更新等。</li>
<li>提供简洁的<strong>数据表示和逻辑信息</strong> ，以便算法高效运行。</li>
</ul>
<p># 通常来说这三者无法同时做到最好，只能<strong>相互权衡</strong></p>
<h3 id="3-与算法的关系">3.与算法的关系</h3>
<ul>
<li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li>
<li>算法为数据结构注入生命力。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li>
<li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li>
</ul>
<h3 id="4-数据结构分类">4.数据结构分类</h3>
<ul>
<li>常见的数据结构包括：
<ul>
<li>数组</li>
<li>链表</li>
<li>栈</li>
<li>队列</li>
<li>哈希表</li>
<li>树</li>
<li>堆</li>
<li>图</li>
</ul>
</li>
<li>可以分为<strong>逻辑结构</strong> 和<strong>物理结构</strong></li>
</ul>
<h4 id="1-逻辑结构">1.逻辑结构</h4>
<ul>
<li>逻辑结构揭示了数据元素之间的<strong>逻辑关系</strong> 。</li>
<li>逻辑结构又可以分为两类
<ul>
<li>线性数据结构
<ul>
<li>数组</li>
<li>链表</li>
<li>栈</li>
<li>队列</li>
<li>哈希表
<ul>
<li>元素之间是一对一的顺序关系</li>
</ul>
</li>
</ul>
</li>
<li>非线性数据结构又可以分为两类
<ul>
<li>树状结构
<ul>
<li>树</li>
<li>堆</li>
<li>哈希表
<ul>
<li>元素之间是一对多的关系</li>
</ul>
</li>
</ul>
</li>
<li>网状结构
<ul>
<li>图
<ul>
<li>元素之间是多对多的关系</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-物理结构">2.物理结构</h4>
<ul>
<li>
<p>算法程序中正在处理的数据主要存储在内存中，系统通过<strong>内存地址</strong> 来访问目标位置的数据</p>
</li>
<li>
<p>每个内存空间都有<strong>唯一</strong> 的内存地址</p>
</li>
<li>
<p>当一块内存被一个程序占用时，通常无法被其他程序同时使用</p>
</li>
<li>
<p>因此，在算法设计中，<strong>内存资源</strong> 是一个重要的考虑因素</p>
</li>
<li>
<p>物理结构反映了数据在计算机内存中的存储方式</p>
</li>
<li>
<p>可以分为</p>
<ul>
<li>连续空间存储（数组）</li>
<li>分散空间存储（链表）</li>
</ul>
</li>
</ul>
<p># 两种结构在<strong>时间效率</strong> 和<strong>空间效率</strong> 方面呈现<strong>互补</strong></p>
<ul>
<li>所有的数据结构都是基于数组，链表或二者的组合实现的
<ul>
<li>基于数组可实现
<ul>
<li>栈</li>
<li>队列</li>
<li>哈希表</li>
<li>树</li>
<li>堆</li>
<li>图</li>
<li>矩阵</li>
<li>张量（维度&gt;=3的数组）</li>
<li>等</li>
</ul>
</li>
<li>基于链表可实现
<ul>
<li>栈</li>
<li>队列</li>
<li>哈希表</li>
<li>树</li>
<li>堆</li>
<li>图</li>
<li>等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-基本数据类型">5.基本数据类型</h3>
<ul>
<li>参考Java中的数据类型</li>
</ul>
<p># 注意不同编程语言的数据类型的定义在占用空间，取值范围和默认值会有所不同</p>
<ul>
<li>基本数据类型提供了数据的<strong>内容类型</strong></li>
<li>数据结构提供了数据的<strong>组织方式</strong></li>
</ul>
<h3 id="6-数字编码">6.数字编码</h3>
<h4 id="1-原码，反码，补码">1.原码，反码，补码</h4>
<h5 id="1-原码">1.原码</h5>
<ul>
<li>十进制数据的二进制表现形式，最左边是符号位，0为正，1为负</li>
<li>八个bit为一个字节</li>
<li>最大值：01111111=127</li>
<li>最小值：11111111=-127</li>
</ul>
<h6 id="1-原码的计算">1.原码的计算</h6>
<ul>
<li>二进制的计算方式，加1，则直接在末位加1，满二进一</li>
</ul>
<h6 id="2-原码的弊端">2.原码的弊端</h6>
<ul>
<li>用原码对正数进行计算是不会有问题的</li>
<li>但如果是负数计算，结果就出错，实际运算的结果与预期的结果是相反的</li>
</ul>
<h5 id="2-反码">2.反码</h5>
<ul>
<li>为了解决<strong>原码不能计算负数</strong> 的问题而出现的</li>
</ul>
<h6 id="1-反码的计算">1.反码的计算</h6>
<ul>
<li>
<p>正数的反码不变，负数的反码在原码的基础上，符号位不变，数字取反，0变1，1变0</p>
</li>
<li>
<p>如果加1，则在末位加1，满二进一，得到的就是加1后的反码</p>
</li>
</ul>
<h6 id="2-反码的弊端">2.反码的弊端</h6>
<ul>
<li>反码的11111111表示-0，如果再加1，则变为00000000=0</li>
<li>同样类似于-4的反码+7，跨0，会比正确结果小1</li>
</ul>
<p># 因为反码中的0有11111111和00000000两种表示方式</p>
<h5 id="3-补码">3.补码</h5>
<ul>
<li>
<p>在负数的反码的基础上加1，这样-0就是00000000，-1就是11111111，反码再依次向后，形成补码</p>
</li>
<li>
<p>-127就是10000001，-128就是10000000，-128只有补码，没有原码</p>
</li>
<li>
<p><strong>计算机中数字的存储计算都是以补码的形式来操作的</strong></p>
</li>
<li>
<p>所以<strong>一个字节</strong> 的范围就是**-128~127**</p>
</li>
</ul>
<h4 id="2-浮点数编码">2.浮点数编码</h4>
<ul>
<li>
<p>在IEEE 754标准中，32bit长度的float类型由三个部分组成</p>
<ul>
<li>符号位：S，占1位</li>
<li>指数位：E，占8位</li>
<li>分数为：N，占23位</li>
</ul>
</li>
<li>
<p>尽管浮点数float<strong>扩展了取值范围</strong> ，但其副作用是<strong>牺牲了精度</strong> 。</p>
</li>
</ul>
<h3 id="7-字符编码">7.字符编码</h3>
<h4 id="1-ASCII字符集">1.ASCII字符集</h4>
<ul>
<li>
<p>用7位二进制数表示一个字符，最多能表示128个不同的字符</p>
</li>
<li>
<p>包含英文字母的大小写，数字，标点，控制字符（换行，制表）</p>
</li>
<li>
<p>字符用一个字节表示</p>
</li>
</ul>
<h4 id="2-GBK字符集">2.GBK字符集</h4>
<ul>
<li>
<p>收录汉字，包含国家标准GB13000-1中的全部中日韩汉字，和BIG5编码中的所有汉字</p>
</li>
<li>
<p>计算机默认编码</p>
</li>
<li>
<p>字符用两个字节表示</p>
</li>
</ul>
<h4 id="3-Unicode字符集（统一码）">3.Unicode字符集（统一码）</h4>
<ul>
<li>
<p>国际标准字符集，将世界各种语言的每个字符定义一个唯一的编码（码点），以满足跨语言，跨平台的文本信息转化</p>
</li>
<li>
<p>但它并没有规定在计算机中如何存储这些字符码点</p>
</li>
<li>
<p>当多种长度的码点同时出现在一个文本时，系统如何解析字符</p>
</li>
<li>
<p>可以将所有字符存储为等长的编码，通过补0，将所有字符的编码都变为2字节长度</p>
</li>
<li>
<p>但是这样非常浪费空间</p>
</li>
</ul>
<h4 id="4-UTF-8编码">4.UTF-8编码</h4>
<ul>
<li>
<p>是国际上使用最广泛的Unicode编码方法</p>
</li>
<li>
<p>它是一种<strong>可变长度</strong> 的编码</p>
</li>
<li>
<p>使用1~4个字节来表示一个字符，根据复杂度而变</p>
</li>
<li>
<p>ASCII字符需要1字节</p>
</li>
<li>
<p>拉丁字母和希腊字母需要2字节</p>
</li>
<li>
<p>常用中文字符需要3字节</p>
</li>
<li>
<p>一些生僻字需要4字节</p>
</li>
<li>
<p>对于长度为1字节的字符，将最高位设置为0，其余7位设置位Unicode编码，ASCII字符在Unicode字符集中占前128个码点，所以<strong>UTF-8编码可以向下兼容ASCII码</strong></p>
</li>
<li>
<p>除了UTF-8以外还有两种常见的编码方式</p>
</li>
<li>
<p><strong>UTF‑16 编码</strong> ：使用 2 或 4 字节来表示一个字符。所有的 ASCII 字符和常用的非英文字符，都用 2 字节表示；少数字符需要用到 4 字节表示。对于 2 字节的字符，UTF‑16 编码与 Unicode 码点相等。</p>
</li>
<li>
<p><strong>UTF‑32 编码</strong> ：每个字符都使用 4 字节。这意味着 UTF‑32 比 UTF‑8 和 UTF‑16 更占用空间，特别是对于 ASCII 字符占比较高的文本</p>
</li>
<li>
<p>从存储空间占用的角度来看，UTF-8的效率非常高，对比UTF-16和UTF-32更加高效</p>
</li>
<li>
<p>从兼容性角度来看，UTF-8的通用性也是最佳</p>
</li>
</ul>
<h4 id="5-编程语言的字符编码">5.编程语言的字符编码</h4>
<ul>
<li>于以往的大多数编程语言，程序运行中的字符串都采用 UTF‑16 或 UTF‑32 这类等长编码。在等长编码下，可以将字符串看作数组来处理，这种做法具有以下优点
<ul>
<li><strong>随机访问</strong>：UTF‑16 编码的字符串可以很容易地进行随机访问。UTF‑8 是一种变长编码，要想找到第 𝑖个字符，我们需要从字符串的开始处遍历到第 𝑖 个字符，这需要 𝑂(𝑛) 的时间。</li>
<li><strong>字符计数</strong>：与随机访问类似，计算 UTF‑16 编码的字符串的长度也是 𝑂(1) 的操作。但是，计算 UTF‑8编码的字符串的长度需要遍历整个字符串。</li>
<li><strong>字符串操作</strong>：在 UTF‑16 编码的字符串上，很多字符串操作（如分割、连接、插入、删除等）更容易进行。</li>
</ul>
</li>
</ul>
<p># 在 UTF‑8 编码的字符串上，进行这些操作通常需要额外的计算，以确保不会产生无效的 UTF‑8 编码</p>
<p># 但是在文件存储和网络传输中通常还是将字符串编码位UTF-8格式，以达到最优的兼容性和空间效率。</p>
<h2 id="4-数组与链表">4.数组与链表</h2>
<h3 id="1-数组">1.数组</h3>
<ul>
<li><strong>数组</strong> （array）是一种<strong>线性数据结构</strong> ，其将<strong>相同类型</strong> 的元素存储在<strong>连续的内存空间</strong> 中。我们将元素在数组中的位置称为该元素的<strong>索引</strong> （index）。</li>
</ul>
<h4 id="1-数组常用操作">1.数组常用操作</h4>
<h5 id="1-初始化数组">1.初始化数组</h5>
<ul>
<li>可以根据需求选用数组的两种初始化方式：<strong>无初始值</strong> 和<strong>给定初始值</strong> 。在<strong>未指定初始值</strong> 的情况下，大多数编程语言会将数组元素初始化为0</li>
</ul>
<h5 id="2-访问元素">2.访问元素</h5>
<ul>
<li>因为被存储在连续的内存空间中，所以只要给定数组的内存地址（首元素的内存地址）和某个元素的索引，就可以计算除该元素的内存地址，从而直接访问该元素</li>
<li>计算公式：<strong>元素内存地址 = 数组内存地址 + 元素长度 * 元素索引</strong></li>
</ul>
<p># 元素长度是又元素的类型决定的</p>
<ul>
<li>索引是从0开始的，因为索引本质上是内存地址的偏移量，第一个元素的地址偏移量是0，因此索引为0</li>
</ul>
<h5 id="3-插入元素">3.插入元素</h5>
<ul>
<li>由于数组是<strong>连续存储</strong> 的，所以要插入元素，就要将该元素后的所有元素都<strong>向后移动一位</strong> ，再将元素赋值给索引</li>
<li>但是数组的长度是确定的，这样会导致<strong>最后一个元素的丢失</strong></li>
</ul>
<h5 id="4-删除元素">4.删除元素</h5>
<ul>
<li>
<p>与插入相同，将删除元素后面的元素都<strong>向前移动一位</strong></p>
</li>
<li>
<p>因此插入和删除会有以下缺点</p>
</li>
<li>
<p><strong>时间复杂度高</strong> ：数组的插入和删除的平均时间复杂度均为 𝑂(𝑛) ，其中 𝑛 为数组长度。</p>
</li>
<li>
<p><strong>丢失元素</strong> ：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。</p>
</li>
<li>
<p><strong>内存浪费</strong> ：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是无意义的，但这样做会造成部分内存空间浪费。</p>
</li>
</ul>
<h5 id="5-遍历数组">5.遍历数组</h5>
<ul>
<li>既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素</li>
</ul>
<h5 id="6-查找元素">6.查找元素</h5>
<ul>
<li>在数组中查找指定元素需要遍历数组，判断是否匹配</li>
<li>因为数组是线性数据结构，所以这种查找操作称为<strong>线性查找</strong></li>
</ul>
<h5 id="7-扩容数组">7.扩容数组</h5>
<ul>
<li>当原本的数组长度不够时，需要扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个𝑂(𝑛) 的操作，在数组很大的情况下非常耗时</li>
</ul>
<h4 id="2-数组的优点与局限性">2.数组的优点与局限性</h4>
<h5 id="1-优点">1.优点</h5>
<ul>
<li><strong>空间效率高</strong> ：数组为数据分配了连续的内存块，无须额外的结构开销。</li>
<li><strong>支持随机访问</strong> ：数组允许在 𝑂(1) 时间内访问任何元素。</li>
<li><strong>缓存局部性</strong> ：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。</li>
</ul>
<h5 id="2-局限性">2.局限性</h5>
<ul>
<li><strong>插入与删除效率低</strong> ：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li>
<li><strong>长度不可变</strong> ：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li>
<li><strong>空间浪费</strong> ：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li>
</ul>
<h3 id="2-链表">2.链表</h3>
<ul>
<li>
<p><strong>链表</strong> （linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过<strong>引用</strong> 相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点</p>
</li>
<li>
<p>因为计算机的内存空间的占用是分散的并不连续，但是数组的存储必须连续，数组过大时，内存不一定能够提供连续空间</p>
</li>
<li>
<p>链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。</p>
</li>
<li>
<p>链表的组成单位是<strong>节点</strong> （node），其中包含数据</p>
<ul>
<li>值</li>
<li>指向下一个节点的引用（在支持指针的语言中，引用就替换为<strong>指针</strong> ）</li>
</ul>
<p># 因此链表在相同数据量下所占用的空间也比数组要大</p>
</li>
<li>
<p>链表的首个节点就叫<strong>头节点</strong> ，最后一个节点就叫<strong>尾节点</strong></p>
</li>
</ul>
<h4 id="1-链表常用操作">1.链表常用操作</h4>
<h5 id="1-初始化链表">1.初始化链表</h5>
<h6 id="1-初始化各个节点对象">1.初始化各个节点对象</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListNode* n0 = newListNode(<span class="number">1</span>);</span><br><span class="line">ListNode* n1 = newListNode(<span class="number">3</span>);</span><br><span class="line">ListNode* n2 = newListNode(<span class="number">2</span>);</span><br><span class="line">ListNode* n3 = newListNode(<span class="number">5</span>);</span><br><span class="line">ListNode* n4 = newListNode(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h6 id="2-构建节点之间的引用关系">2.构建节点之间的引用关系</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n0-&gt;next = n1;</span><br><span class="line">n1-&gt;next = n2;</span><br><span class="line">n2-&gt;next = n3;</span><br><span class="line">n3-&gt;next = n4;</span><br></pre></td></tr></table></figure>
<p># 通常将链表头作为链表的代称，上述代码的链表可以称为n0</p>
<h5 id="2-插入节点">2.插入节点</h5>
<ul>
<li>插入一个新的节点，只需要<strong>更改相邻两个节点的引用（指针）</strong> ，时间复杂度为𝑂(1)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(ListNode *n0, ListNode *P)</span> &#123;</span><br><span class="line">	ListNode *n1 = n0-&gt;next;</span><br><span class="line">	P-&gt;next = n1;</span><br><span class="line">	n0-&gt;next = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-删除节点">3.删除节点</h5>
<ul>
<li>删除一个节点，只需要<strong>改变前一个节点的引用（指针）</strong></li>
<li>被删除节点的引用虽然还存在，但因为已经无法被访问到了，所以认为已经被删除</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">removeItem</span><span class="params">(ListNode *n0)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!n0-&gt;next)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// n0 -&gt; P -&gt; n1</span></span><br><span class="line">	ListNode *P = n0-&gt;next;</span><br><span class="line">    ListNode *n1 = P-&gt;next;</span><br><span class="line">	n0-&gt;next = n1;</span><br><span class="line">	<span class="comment">// 释放内存</span></span><br><span class="line">	<span class="built_in">free</span>(P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-访问节点">4.访问节点</h5>
<ul>
<li>链表中访问节点的效率较低，需要从头开始，<strong>逐个向后遍历</strong> ，时间复杂度为 𝑂(𝑛)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">access</span><span class="params">(ListNode *head, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-查找节点">5.查找节点</h5>
<ul>
<li>查找某一个值的节点，遍历链表，也是<strong>线性查找</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(ListNode *head, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (head) &#123;</span><br><span class="line">		<span class="keyword">if</span> (head-&gt;val == target)</span><br><span class="line">			<span class="keyword">return</span> index;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-数组与节点的对比">2.数组与节点的对比</h4>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储方式</td>
<td>连续内存空间</td>
<td>分散内存空间</td>
</tr>
<tr>
<td>容量扩展</td>
<td>长度不可变</td>
<td>可灵活扩展</td>
</tr>
<tr>
<td>内存效率</td>
<td>元素占用内存少、但可能浪费空间</td>
<td>元素占用内存多</td>
</tr>
<tr>
<td>访问元素</td>
<td>𝑂(1)</td>
<td>𝑂(𝑛)</td>
</tr>
<tr>
<td>添加元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>删除元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<h4 id="3-常见链表类型">3.常见链表类型</h4>
<ul>
<li>
<p><strong>单向链表</strong> ：即普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。</p>
</li>
<li>
<p><strong>环形链表</strong> ：如果令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</p>
</li>
<li>
<p><strong>双向链表</strong> ：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</p>
</li>
</ul>
<h4 id="4-链表典型应用">4.链表典型应用</h4>
<ul>
<li>
<p><strong>单向链表</strong> ：通常用于实现栈、队列、哈希表和图等数据结构。</p>
<ul>
<li>
<p><strong>栈与队列</strong> ：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。</p>
</li>
<li>
<p><strong>哈希表</strong> ：链式地址是<strong>解决哈希冲突</strong> 的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</p>
</li>
<li>
<p><strong>图</strong> ：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素代</p>
<p>表与该顶点相连的其他顶点</p>
</li>
</ul>
</li>
<li>
<p><strong>双向链表</strong> ：常用于需要<strong>快速查找前一个和后一个元素</strong> 的场景。</p>
<ul>
<li><strong>高级数据结构</strong> ：比如在红黑树、B 树中，我们需要访问节点的<strong>父节点</strong> ，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</li>
<li><strong>浏览器历史</strong> ：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</li>
<li><strong>LRU 算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</li>
</ul>
</li>
<li>
<p><strong>环形链表</strong> ：常用于需要<strong>周期性操作</strong> 的场景，比如操作系统的<strong>资源调度</strong> 。</p>
<ul>
<li><strong>时间片轮转调度算法</strong> ：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。</li>
<li><strong>数据缓冲区</strong> ：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在<strong>音频、视频播放器</strong> 中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现<strong>无缝播放</strong> 。</li>
</ul>
</li>
</ul>
<h3 id="3-列表">3.列表</h3>
<ul>
<li>
<p><strong>列表</strong>（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。</p>
</li>
<li>
<p>当使用数组实现列表时，<strong>长度不可变的性质会导致列表的实用性降低</strong></p>
</li>
<li>
<p>可以使用<strong>动态数组</strong> （dynamic array）来实现列表</p>
</li>
<li>
<p>许多语言中提供的列表都是基于动态数组实现的</p>
</li>
<li>
<p>但是<strong>c语言中没有动态数组</strong></p>
</li>
</ul>
<h4 id="1列表常用操作">1列表常用操作</h4>
<h5 id="1-初始化列表">1.初始化列表</h5>
<h6 id="1-无初始值">1.无初始值</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums1: <span class="built_in">list</span>[<span class="built_in">int</span>] = []</span><br></pre></td></tr></table></figure>
<h6 id="2-有初始值">2.有初始值</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h5 id="2-访问元素-2">2.访问元素</h5>
<ul>
<li>列表本质上是数组，因此可以在 𝑂(1) 时间内访问和更新元素，效率很高</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num: <span class="built_in">int</span> = nums[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h5 id="3-插入和删除元素">3.插入和删除元素</h5>
<ul>
<li><strong>在列表尾部添加元素</strong> 的时间复杂度为 𝑂(1) ，但插入和删除元素的效率仍与数组相同，时间复杂度为 𝑂(𝑛) 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums.insert(<span class="number">3</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p># 在索引为3的位置插入数字6</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums.pop(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p># 删除索引为3的元素</p>
<h5 id="4-遍历列表">4.遍历列表</h5>
<ul>
<li>和数组一样，可以根据索引遍历，也可以直接遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line"></span><br><span class="line">	count += nums[i]</span><br></pre></td></tr></table></figure>
<p># 通过索引遍历列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line"></span><br><span class="line">	count += num</span><br></pre></td></tr></table></figure>
<p># 直接遍历列表元素</p>
<h5 id="5-拼接列表">5.拼接列表</h5>
<ul>
<li>将一个列表拼接到另一个列表的尾部</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums1: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>]</span><br><span class="line">nums += nums1</span><br></pre></td></tr></table></figure>
<h5 id="6-排序列表">6.排序列表</h5>
<ul>
<li>将列表元素排序，便于后面的二分查找和双指针</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br></pre></td></tr></table></figure>
<h4 id="2-列表实现">2.列表实现</h4>
<ul>
<li>一个简易的列表主要有三个部分
<ul>
<li><strong>初始容量</strong> ：选取一个合理的数组初始容量。</li>
<li><strong>数量记录</strong> ：声明一个变量 size ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。</li>
<li><strong>扩容机制</strong> ：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组</li>
</ul>
</li>
</ul>
<h3 id="4-内存与缓存">4.内存与缓存</h3>
<ul>
<li><strong>物理结构在很大程度上决定了程序对内存和缓存的使用效率</strong> ，影响算法的整体性能</li>
</ul>
<h4 id="1-计算机存储设备">1.计算机存储设备</h4>
<ul>
<li>主要包含硬盘（hard disk）、内存（random‑access memory, RAM）、缓存（cache memory）</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>硬盘</th>
<th>内存</th>
<th>缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td>用途</td>
<td>长期存储数据，包括操作系统、程序、文件等</td>
<td>临时存储当前运行的程序和正在处理的数据</td>
<td>存储经常访问的数据和指令，减少 CPU访问内存的次数</td>
</tr>
<tr>
<td>易失性</td>
<td>断电后数据不会丢失</td>
<td>断电后数据会丢失</td>
<td>断电后数据会丢失</td>
</tr>
<tr>
<td>容量</td>
<td>较大，TB 级别</td>
<td>较小，GB 级别</td>
<td>非常小，MB 级别</td>
</tr>
<tr>
<td>速度</td>
<td>较慢，几百到几千 MB/s</td>
<td>较快，几十 GB/s</td>
<td>非常快，几十到几百 GB/s</td>
</tr>
<tr>
<td>价格</td>
<td>较便宜，几毛到几元 / GB</td>
<td>较贵，几十到几百元 / GB</td>
<td>非常贵，随 CPU 打包计价</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>硬盘难以被内存取代</strong> 。首先，内存中的数据在断电后会丢失，因此它<strong>不适合长期存储数据</strong> ；其次，内存的成本是硬盘的几十倍，这使得它难以在消费者市场普及。</p>
</li>
<li>
<p><strong>缓存的大容量和高速度难以兼得</strong> 。随着L1、L2、L3缓存的容量逐步增大，其<strong>物理尺寸会变大</strong> ，与 CPU核心之间的物理距离会变远，从而导致<strong>数据传输时间增加</strong> ，<strong>元素访问延迟变高</strong> 。在当前技术下，<strong>多层级</strong> 的缓存结构是容量、速度和成本之间的最佳平衡点</p>
</li>
<li>
<p>总的来说，<strong>硬盘用于长期存储大量数据，内存用于临时存储程序运行中正在处理的数据，而缓存则用于存储经常访问的数据和指令</strong>，以提高程序运行效率。三者共同协作，确保计算机系统高效运行</p>
</li>
<li>
<p>在程序运行时，数据会<strong>从硬盘中被读取到内存中</strong> ，供CPU计算使用。缓存可以看作CPU的一部分，<strong>它通过智能地从内存加载数据</strong>，给CPU提供高速的数据读取，从而显著提升程序的执行效率，减少对较慢的内存的依赖</p>
</li>
</ul>
<h4 id="2-数据结构的内存效率">2.数据结构的内存效率</h4>
<ul>
<li>内存是有限的，而且同一块内存只能有一个程序使用
<ul>
<li>数组：需要连续的内存空间，可能导致浪费，而且扩容时也需要时间和空间</li>
<li>链表：以节点为单位，更加灵活</li>
</ul>
</li>
<li>程序运行时，反复申请和释放内存，<strong>空闲的内存碎片化程度变高</strong>
<ul>
<li>数组：连续存储，不容易导致内存碎片化</li>
<li>链表：分散存储，频繁的插入与删除，易导致内存碎片化</li>
</ul>
</li>
</ul>
<h4 id="3-数据结构的缓存效率">3.数据结构的缓存效率</h4>
<ul>
<li>
<p>由于<strong>缓存的容量有限</strong> ，只能存储一小部分<strong>频繁访问的数据</strong> ，因此当CPU尝试访问的数据不在缓存中时，就会发生<strong>缓存未命中</strong> （cache miss），此时CPU不得不<strong>从速度较慢的内存中加载所需数据</strong></p>
</li>
<li>
<p><strong>缓存未命中</strong> 越少，CPU读写数据的效率就越高，将CPU 从缓存中成功获取数据的比例称为<strong>缓存命中率</strong> （cache hit rate），这个指标通常用来衡量缓存效率。</p>
</li>
<li>
<p>为了尽可能达到更高的效率，缓存会采取以下数据加载机制</p>
<ul>
<li><strong>缓存行</strong> ：缓存不是单个字节地存储与加载数据，而是<strong>以缓存行为单位</strong> 。相比于单个字节的传输，缓存行的传输形式<strong>更加高效</strong> 。</li>
<li><strong>预取机制</strong> ：处理器会尝试<strong>预测数据访问模式</strong> （例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。</li>
<li><strong>空间局部性</strong> ：如果一个数据被访问，那么它<strong>附近的数据</strong> 可能近期也会被访问。因此，缓存在加载某一数据时，也会<strong>加载其附近的数据</strong> ，以提高命中率。</li>
<li><strong>时间局部性</strong> ：如果一个数据被访问，那么它<strong>在不久的将来很可能再次被访问</strong> 。缓存利用这一原理，通过<strong>保留最近访问过的数据</strong> 来提高命中率</li>
</ul>
</li>
<li>
<p>数组和链表对缓存的利用效率是不同的：</p>
<ul>
<li><strong>占用空间</strong> ：<strong>链表元素</strong> 比数组元素<strong>占用空间更多</strong> ，导致缓存中<strong>容纳的有效数据量更少</strong> 。</li>
<li><strong>缓存行</strong> ：链表数据<strong>分散</strong> 在内存各处，而缓存是<strong>按行加载</strong> 的，因此<strong>加载到无效数据</strong> 的比例更高。</li>
<li><strong>预取机制</strong> ：<strong>数组</strong> 比链表的数据访问模式更具<strong>可预测性</strong> ，即系统更容易猜出即将被加载的数据。</li>
<li><strong>空间局部性</strong> ：数组被存储在<strong>集中</strong> 的内存空间中，因此被加载数据<strong>附近的数据</strong> 更有可能即将被访问</li>
</ul>
</li>
<li>
<p>总体而言，<strong>数组具有更高的缓存命中率，因此它在操作效率上通常优于链表</strong> 。</p>
</li>
</ul>
<h2 id="5-栈与队列">5.栈与队列</h2>
<h3 id="1-栈">1.栈</h3>
<ul>
<li>
<p><strong>栈</strong> （stack）是一种遵循<strong>先入后出</strong> 逻辑的线性数据结构。</p>
</li>
<li>
<p>可以将栈类比为桌面上的一摞盘子，如果想取出底部的盘子，则需要先将上面的盘子依次移走。</p>
</li>
<li>
<p>将把元素<strong>添加到栈顶</strong> 的操作叫作<strong>入栈</strong> ，<strong>删除栈顶元素</strong> 的操作叫作<strong>出栈</strong> 。</p>
</li>
</ul>
<h4 id="1-栈的常用操作">1.栈的常用操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>push()</td>
<td>元素入栈（添加至栈顶）</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>pop()</td>
<td>栈顶元素出栈</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>peek()</td>
<td>访问栈顶元素</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<p># 不同语言的方法名不一定相同</p>
<p># 通常情况下，可以直接使用编程语言内置的栈类，但是，c语言没有提供</p>
<p># 可以将c语言的数组或者链表当作栈来使用，并在程序逻辑上忽略与栈无关的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> stack.isEmpty();</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化栈</span></span><br><span class="line"><span class="comment"># Python 没有内置的栈类，可以把 list 当作栈来使用</span></span><br><span class="line">stack: <span class="built_in">list</span>[<span class="built_in">int</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入栈</span></span><br><span class="line">stack.append(<span class="number">1</span>)</span><br><span class="line">stack.append(<span class="number">3</span>)</span><br><span class="line">stack.append(<span class="number">2</span>)</span><br><span class="line">stack.append(<span class="number">5</span>)</span><br><span class="line">stack.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问栈顶元素</span></span><br><span class="line">peek: <span class="built_in">int</span> = stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出栈</span></span><br><span class="line">pop: <span class="built_in">int</span> = stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取栈的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(stack)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-栈的实现">2.栈的实现</h4>
<ul>
<li>遵循栈先入后出的原则，只能在栈顶添加删除元素，但数组和链表可以在任意位置添加删除元素</li>
<li>可以将栈视为一种受限制的数组或链表</li>
</ul>
<h5 id="1-基于链表的实现">1.基于链表的实现</h5>
<ul>
<li>将链表的头节点视为栈顶，尾节点视为栈底</li>
<li>对于入栈操作，只需在链表头部插入元素即可，这种节点插入方法被称为<strong>头插法</strong></li>
<li>对于出栈操作，只需将头节点从链表中删除即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的栈 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ListNode *top; <span class="comment">// 将头节点作为栈顶</span></span><br><span class="line">	<span class="type">int</span> size; <span class="comment">// 栈的长度</span></span><br><span class="line">&#125; LinkedListStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">LinkedListStack *<span class="title function_">newLinkedListStack</span><span class="params">()</span> &#123;</span><br><span class="line">	LinkedListStack *s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedListStack));</span><br><span class="line">	s-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delLinkedListStack</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (s-&gt;top) &#123;</span><br><span class="line">		ListNode *n = s-&gt;top-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(s-&gt;top);</span><br><span class="line">		s-&gt;top = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> size(s) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkedListStack *s, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	ListNode *node = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	node-&gt;next = s-&gt;top; <span class="comment">// 更新新加节点指针域</span></span><br><span class="line">	node-&gt;val = num; <span class="comment">// 更新新加节点数据域</span></span><br><span class="line">	s-&gt;top = node; <span class="comment">// 更新栈顶</span></span><br><span class="line">	s-&gt;size++; <span class="comment">// 更新栈大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 栈为空\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s-&gt;top-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedListStack *s)</span> &#123;</span><br><span class="line">	<span class="type">int</span> val = peek(s);</span><br><span class="line">	ListNode *tmp = s-&gt;top;</span><br><span class="line">	s-&gt;top = s-&gt;top-&gt;next;</span><br><span class="line">	<span class="comment">// 释放内存</span></span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">	s-&gt;size--;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-基于数组的实现">2.基于数组的实现</h5>
<ul>
<li>将数组尾部视为栈顶，入栈和出栈分别对应在数组尾部添加和删除元素</li>
<li>由于入栈的元素可能会一致增加，所以使用动态数组，不需要再去处理数组扩容的问题</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于数组实现的栈 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> *data;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125; ArrayStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">ArrayStack *<span class="title function_">newArrayStack</span><span class="params">()</span> &#123;</span><br><span class="line">	ArrayStack *<span class="built_in">stack</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayStack));</span><br><span class="line">	<span class="comment">// 初始化一个大容量，避免扩容</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * MAX_SIZE);</span><br><span class="line">	<span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delArrayStack</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入栈 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(ArrayStack *<span class="built_in">stack</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;size == MAX_SIZE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 栈已满\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;size] = num;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 栈为空\n&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> INT_MAX;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> val = peek(<span class="built_in">stack</span>);</span><br><span class="line">	<span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># c语言中没有内置动态数组，所以仅使用一个大容量的数组来避免扩容问题</p>
<h5 id="3-两种实现的对比">3.两种实现的对比</h5>
<ul>
<li>
<p><strong>支持操作</strong></p>
<ul>
<li>两种实现都支持栈定义中的各项操作。<strong>数组</strong> 实现<strong>额外支持随机访问</strong> ，但这已超出了栈的定义范畴，因此一般不会用到。</li>
</ul>
</li>
<li>
<p><strong>时间效率</strong></p>
<ul>
<li>在基于<strong>数组</strong> 的实现中，入栈和出栈操作都在预先分配好的连续内存中进行，具有很好的<strong>缓存本地性</strong> ，因此<strong>效率较高</strong> 。然而，如果<strong>入栈时超出数组容量</strong> ，会<strong>触发扩容机制</strong> ，导致该次<strong>入栈操作的时间复杂度变为𝑂(𝑛)</strong> 。</li>
<li>在基于<strong>链表</strong> 的实现中，链表的<strong>扩容非常灵活</strong> ，不存在上述数组扩容时效率降低的问题。但是，<strong>入栈</strong> 操作<strong>需要初始化节点对象并修改指针</strong> ，因此效率相对较低。不过，<strong>如果入栈元素本身就是节点对象，那么可以省去初始化步骤</strong> ，从而提高效率。</li>
<li>综上所述，当入栈与出栈操作的元素是基本数据类型时，例如 int 或 double ，我们可以得出以下结论
<ul>
<li>基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此<strong>平均效率更高</strong> 。</li>
<li>基于链表实现的栈可以提供<strong>更加稳定</strong> 的效率表现。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>空间效率</strong></p>
<ul>
<li>在初始化列表时，系统会为列表分配<strong>初始容量</strong> ，该容量可能<strong>超出实际需求</strong> ；并且，扩容机制通常是按照特定倍率（例如 2 倍）进行扩容的，<strong>扩容后的容量</strong> 也可能<strong>超出实际需求</strong> 。因此，<strong>基于数组实现的栈可能造成一定的空间浪费</strong>。</li>
<li>然而，由于链表节点需要额外存储指针，<strong>因此链表节点占用的空间相对较大</strong>。</li>
<li>综上，我们不能简单地确定哪种实现更加节省内存，需要针对具体情况进行分析。</li>
</ul>
</li>
</ul>
<h5 id="4-栈的典型应用">4.栈的典型应用</h5>
<ul>
<li><strong>浏览器中的后退与前进、软件中的撤销与反撤销</strong> 。每当打开新的网页，浏览器就会对上一个网页执行入栈，这样我们就可以通过后退操作回到上一个网页。<strong>后退</strong> 操作实际上是在执行<strong>出栈</strong> 。如果要同时支持后退和前进，那么需要两个栈来配合实现。</li>
<li><strong>程序内存管理</strong> 。每次<strong>调用函数</strong> 时，系统都会在栈顶添加一个<strong>栈帧</strong> ，用于记录函数的<strong>上下文信息</strong> 。在递归函数中，<strong>向下递推</strong> 阶段会不断执行<strong>入栈</strong> 操作，而<strong>向上回溯</strong> 阶段则会不断执行<strong>出栈</strong> 操作</li>
</ul>
<h3 id="2-队列">2.队列</h3>
<ul>
<li><strong>队列</strong> （queue）是一种遵循<strong>先入先出</strong> 规则的线性数据结构</li>
<li>将队列头部称为<strong>队首</strong> ，尾部则称为<strong>队尾</strong> ，将元素加入<strong>队尾</strong> 的操作称为<strong>入队</strong> ，删除<strong>队首</strong> 元素则称为<strong>出队</strong></li>
</ul>
<h4 id="1-队列常用操作">1.队列常用操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>push()</td>
<td>元素入队（将元素添加到队尾）</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>pop()</td>
<td>队首元素出队</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>peek()</td>
<td>访问队首元素</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<p># 不同语言的方法名不一定相同</p>
<p># c语言未提供内置队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化队列</span></span><br><span class="line"><span class="comment"># 在 Python 中，我们一般将双向队列类 deque 当作队列使用</span></span><br><span class="line"><span class="comment"># 虽然 queue.Queue() 是纯正的队列类，但不太好用，因此不推荐</span></span><br><span class="line">que: deque[<span class="built_in">int</span>] = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入队</span></span><br><span class="line">que.append(<span class="number">1</span>)</span><br><span class="line">que.append(<span class="number">3</span>)</span><br><span class="line">que.append(<span class="number">2</span>)</span><br><span class="line">que.append(<span class="number">5</span>)</span><br><span class="line">que.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问队首元素</span></span><br><span class="line">front: <span class="built_in">int</span> = que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出队</span></span><br><span class="line">pop: <span class="built_in">int</span> = que.popleft()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取队列的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(que)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断队列是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(que) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-队列的实现">2.队列的实现</h4>
<h5 id="1-基于链表的实现-2">1.基于链表的实现</h5>
<ul>
<li>将<strong>头节点</strong> 对应<strong>队首</strong> ，<strong>尾节点</strong> 对应<strong>队尾</strong> ，并且队尾只能添加节点，队首只能删除节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的队列 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ListNode *front, *rear;</span><br><span class="line">	<span class="type">int</span> queSize;</span><br><span class="line">&#125; LinkedListQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">LinkedListQueue *<span class="title function_">newLinkedListQueue</span><span class="params">()</span> &#123;</span><br><span class="line">	LinkedListQueue *<span class="built_in">queue</span> = (LinkedListQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedListQueue));</span><br><span class="line">	<span class="built_in">queue</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;queSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">delLinkedListQueue</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 释放所有节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">queue</span>-&gt;front != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			ListNode *tmp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">			<span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放 queue 结构体</span></span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;queSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (size(<span class="built_in">queue</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="comment">// 尾节点处添加 node</span></span><br><span class="line">	ListNode *node = newListNode(num);</span><br><span class="line">	<span class="comment">// 如果队列为空，则令头、尾节点都指向该节点</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">queue</span>-&gt;front = node;</span><br><span class="line">		<span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果队列不为空，则将该节点添加到尾节点后</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">queue</span>-&gt;rear-&gt;next = node;</span><br><span class="line">		<span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;queSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	assert(size(<span class="built_in">queue</span>) &amp;&amp; <span class="built_in">queue</span>-&gt;front);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = peek(<span class="built_in">queue</span>);</span><br><span class="line">	ListNode *tmp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">	<span class="built_in">queue</span>-&gt;queSize--;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印队列 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinkedListQueue</span><span class="params">(LinkedListQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> *arr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="built_in">queue</span>-&gt;queSize);</span><br><span class="line">	<span class="comment">// 拷贝链表中的数据到数组</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	ListNode *node;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, node = <span class="built_in">queue</span>-&gt;front; i &lt; <span class="built_in">queue</span>-&gt;queSize; i++) &#123;</span><br><span class="line">		arr[i] = node-&gt;val;</span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printArray(arr, <span class="built_in">queue</span>-&gt;queSize);</span><br><span class="line">	<span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-基于数组的实现-2">2.基于数组的实现</h5>
<ul>
<li>
<p>在数组中删除首元素的时间复杂度为 𝑂(𝑛) ，这会导致出队操作效率较低。</p>
</li>
<li>
<p>所以可以用以下方法来解决</p>
</li>
<li>
<p>用一个变量front来指向<strong>队首</strong> 元素，再用一个变量size来记录<strong>队列的长度</strong> ，再定义一个rear=front+size，指向的结果就是队尾元素后的下一个位置</p>
</li>
<li>
<p>那么数组中包含元素的区间就是[front,rear-1]</p>
<ul>
<li>入队：将输入的元素赋值给rear计算出的索引，并且将size+1</li>
<li>出队：将front+1，size-1</li>
</ul>
</li>
<li>
<p>这样就可以将时间复杂度降为 𝑂(1)</p>
</li>
<li>
<p>但是上面入队和出队操作中front和rear都在不断增加，即<strong>向右移动</strong> ，如果到达了队尾就无法再移动了</p>
</li>
<li>
<p>所以可以将数组视为首尾相接的<strong>环形数组</strong></p>
</li>
<li>
<p>即当front和rear将要越过数组的尾部时，通过取余操作，使其回到数组的头部继续遍历</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于环形数组实现的队列 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> *nums; <span class="comment">// 用于存储队列元素的数组</span></span><br><span class="line">	<span class="type">int</span> front; <span class="comment">// 队首指针，指向队首元素</span></span><br><span class="line">	<span class="type">int</span> queSize; <span class="comment">// 尾指针，指向队尾 + 1</span></span><br><span class="line">	<span class="type">int</span> queCapacity; <span class="comment">// 队列容量</span></span><br><span class="line">&#125; ArrayQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">ArrayQueue *<span class="title function_">newArrayQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">	ArrayQueue *<span class="built_in">queue</span> = (ArrayQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayQueue));</span><br><span class="line">	<span class="comment">// 初始化数组</span></span><br><span class="line">	<span class="built_in">queue</span>-&gt;queCapacity = capacity;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;nums = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="built_in">queue</span>-&gt;queCapacity);</span><br><span class="line">	<span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;queSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delArrayQueue</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;nums);</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的容量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">capacity</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;queCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;queSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;queSize == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	assert(size(<span class="built_in">queue</span>) != <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;nums[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (size(<span class="built_in">queue</span>) == capacity(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 队列已满\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算队尾指针，指向队尾索引 + 1</span></span><br><span class="line">	<span class="comment">// 通过取余操作实现 rear 越过数组尾部后回到头部</span></span><br><span class="line">	<span class="type">int</span> rear = (<span class="built_in">queue</span>-&gt;front + <span class="built_in">queue</span>-&gt;queSize) % <span class="built_in">queue</span>-&gt;queCapacity;</span><br><span class="line">	<span class="comment">// 将 num 添加至队尾</span></span><br><span class="line">	<span class="built_in">queue</span>-&gt;nums[rear] = num;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;queSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = peek(<span class="built_in">queue</span>);</span><br><span class="line">	<span class="comment">// 队首指针向后移动一位，若越过尾部，则返回到数组头部</span></span><br><span class="line">	<span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;queCapacity;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;queSize--;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">toArray</span><span class="params">(ArrayQueue *<span class="built_in">queue</span>, <span class="type">int</span> *queSize)</span> &#123;</span><br><span class="line">	*queSize = <span class="built_in">queue</span>-&gt;queSize;</span><br><span class="line">	<span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="built_in">queue</span>-&gt;queSize, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>-&gt;queSize; i++) &#123;</span><br><span class="line">		res[i] = <span class="built_in">queue</span>-&gt;nums[j % <span class="built_in">queue</span>-&gt;queCapacity];</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 这样的队列仍然会受限于数组长度不可变的问题，所以可以再将数组替换为动态数组，加入扩容机制</p>
<h5 id="3-队列的典型应用">3.队列的典型应用</h5>
<ul>
<li><strong>淘宝订单</strong> 。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。</li>
<li><strong>各类待办事项</strong> 。任何需要实现<strong>先来后到</strong> 功能的场景，例如<strong>打印机的任务队列</strong> 、<strong>餐厅的出餐队列</strong> 等，队列在这些场景中可以有效地维护<strong>处理顺序</strong> 。</li>
</ul>
<h3 id="3-双向队列">3.双向队列</h3>
<ul>
<li><strong>双向队列</strong> （double‑ended queue）提供了更高的灵活性，<strong>允许在头部和尾部执行元素的添加或删除操作</strong>。</li>
</ul>
<h4 id="1-双向队列的常用操作">1.双向队列的常用操作</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>push_first()</td>
<td>将元素添加至队首</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>push_last()</td>
<td>将元素添加至队尾</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>pop_first()</td>
<td>删除队首元素</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>pop_last()</td>
<td>删除队尾元素</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>peek_first()</td>
<td>访问队首元素</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>peek_last()</td>
<td>访问队尾元素</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<p># 不同编程语言的方法名不一定相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化双向队列</span></span><br><span class="line">deq: deque[<span class="built_in">int</span>] = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入队</span></span><br><span class="line">deq.append(<span class="number">2</span>) <span class="comment"># 添加至队尾</span></span><br><span class="line">deq.append(<span class="number">5</span>)</span><br><span class="line">deq.append(<span class="number">4</span>)</span><br><span class="line">deq.appendleft(<span class="number">3</span>) <span class="comment"># 添加至队首</span></span><br><span class="line">deq.appendleft(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line">front: <span class="built_in">int</span> = deq[<span class="number">0</span>] <span class="comment"># 队首元素</span></span><br><span class="line">rear: <span class="built_in">int</span> = deq[-<span class="number">1</span>] <span class="comment"># 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出队</span></span><br><span class="line">pop_front: <span class="built_in">int</span> = deq.popleft() <span class="comment"># 队首元素出队</span></span><br><span class="line">pop_rear: <span class="built_in">int</span> = deq.pop() <span class="comment"># 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取双向队列的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(deq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断双向队列是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(deq) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-双向队列实现">2.双向队列实现</h4>
<h5 id="1-基于双向链表的实现">1.基于双向链表的实现</h5>
<ul>
<li>双向链表的头节点和尾节点都可以视为队首和队尾，可以在两端添加和删除节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoublyListNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DoublyListNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后继节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DoublyListNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前驱节点</span></span><br><span class="line">&#125; DoublyListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">DoublyListNode *<span class="title function_">newDoublyListNode</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">	DoublyListNode *new = (DoublyListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoublyListNode));</span><br><span class="line">	new-&gt;val = num;</span><br><span class="line">	new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	new-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delDoublyListNode</span><span class="params">(DoublyListNode *node)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于双向链表实现的双向队列 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	DoublyListNode *front, *rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">	<span class="type">int</span> queSize; <span class="comment">// 双向队列的长度</span></span><br><span class="line">&#125; LinkedListDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">LinkedListDeque *<span class="title function_">newLinkedListDeque</span><span class="params">()</span> &#123;</span><br><span class="line">	LinkedListDeque *<span class="built_in">deque</span> = (LinkedListDeque *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedListDeque));</span><br><span class="line">	<span class="built_in">deque</span>-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delLinkedListdeque</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 释放所有节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">deque</span>-&gt;queSize &amp;&amp; <span class="built_in">deque</span>-&gt;front != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		DoublyListNode *tmp = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">		<span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;front-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放 deque 结构体</span></span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">deque</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;queSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (size(<span class="built_in">deque</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>, <span class="type">int</span> num, <span class="type">bool</span> isFront)</span> &#123;</span><br><span class="line">	DoublyListNode *node = newDoublyListNode(num);</span><br><span class="line">	<span class="comment">// 若链表为空，则令 front 和 rear 都指向 node</span></span><br><span class="line">	<span class="keyword">if</span> (empty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">		<span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;rear = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 队首入队操作</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">		<span class="comment">// 将 node 添加至链表头部</span></span><br><span class="line">		<span class="built_in">deque</span>-&gt;front-&gt;prev = node;</span><br><span class="line">		node-&gt;next = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">		<span class="built_in">deque</span>-&gt;front = node; <span class="comment">// 更新头节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 队尾入队操作</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 将 node 添加至链表尾部</span></span><br><span class="line">		<span class="built_in">deque</span>-&gt;rear-&gt;next = node;</span><br><span class="line">		node-&gt;prev = <span class="built_in">deque</span>-&gt;rear;</span><br><span class="line">		<span class="built_in">deque</span>-&gt;rear = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize++; <span class="comment">// 更新队列长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队首入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushFirst</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	push(<span class="built_in">deque</span>, num, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队尾入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushLast</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	push(<span class="built_in">deque</span>, num, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekFirst</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	assert(size(<span class="built_in">deque</span>) &amp;&amp; <span class="built_in">deque</span>-&gt;front);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;front-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队尾元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekLast</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	assert(size(<span class="built_in">deque</span>) &amp;&amp; <span class="built_in">deque</span>-&gt;rear);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;rear-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>, <span class="type">bool</span> isFront)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (empty(<span class="built_in">deque</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="comment">// 队首出队操作</span></span><br><span class="line">	<span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">		val = peekFirst(<span class="built_in">deque</span>); <span class="comment">// 暂存头节点值</span></span><br><span class="line">		DoublyListNode *fNext = <span class="built_in">deque</span>-&gt;front-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (fNext) &#123;</span><br><span class="line">			fNext-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="built_in">deque</span>-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		delDoublyListNode(<span class="built_in">deque</span>-&gt;front);</span><br><span class="line">		<span class="built_in">deque</span>-&gt;front = fNext; <span class="comment">// 更新头节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 队尾出队操作</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		val = peekLast(<span class="built_in">deque</span>); <span class="comment">// 暂存尾节点值</span></span><br><span class="line">		DoublyListNode *rPrev = <span class="built_in">deque</span>-&gt;rear-&gt;prev;</span><br><span class="line">		<span class="keyword">if</span> (rPrev) &#123;</span><br><span class="line">			rPrev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="built_in">deque</span>-&gt;rear-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		delDoublyListNode(<span class="built_in">deque</span>-&gt;rear);</span><br><span class="line">		<span class="built_in">deque</span>-&gt;rear = rPrev; <span class="comment">// 更新尾节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize--; <span class="comment">// 更新队列长度</span></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队首出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">popFirst</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pop(<span class="built_in">deque</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队尾出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">popLast</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pop(<span class="built_in">deque</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印队列 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinkedListDeque</span><span class="params">(LinkedListDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> *arr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="built_in">deque</span>-&gt;queSize);</span><br><span class="line">	<span class="comment">// 拷贝链表中的数据到数组</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	DoublyListNode *node;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, node = <span class="built_in">deque</span>-&gt;front; i &lt; <span class="built_in">deque</span>-&gt;queSize; i++) &#123;</span><br><span class="line">		arr[i] = node-&gt;val;</span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printArray(arr, <span class="built_in">deque</span>-&gt;queSize);</span><br><span class="line">	<span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-基于数组的实现-3">2.基于数组的实现</h5>
<ul>
<li>用环形数组来实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于环形数组实现的双向队列 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> *nums; <span class="comment">// 用于存储队列元素的数组</span></span><br><span class="line">	<span class="type">int</span> front; <span class="comment">// 队首指针，指向队首元素</span></span><br><span class="line">	<span class="type">int</span> queSize; <span class="comment">// 尾指针，指向队尾 + 1</span></span><br><span class="line">	<span class="type">int</span> queCapacity; <span class="comment">// 队列容量</span></span><br><span class="line">&#125; ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">ArrayDeque *<span class="title function_">newArrayDeque</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">	ArrayDeque *<span class="built_in">deque</span> = (ArrayDeque *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayDeque));</span><br><span class="line">	<span class="comment">// 初始化数组</span></span><br><span class="line">	<span class="built_in">deque</span>-&gt;queCapacity = capacity;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;nums = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="built_in">deque</span>-&gt;queCapacity);</span><br><span class="line">	<span class="built_in">deque</span>-&gt;front = <span class="built_in">deque</span>-&gt;queSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delArrayDeque</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">deque</span>-&gt;nums);</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">deque</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的容量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">capacity</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;queCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;queSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;queSize == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算环形数组索引 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeIndex</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="comment">// 通过取余操作实现数组首尾相连</span></span><br><span class="line">	<span class="comment">// 当 i 越过数组尾部时，回到头部</span></span><br><span class="line">	<span class="comment">// 当 i 越过数组头部后，回到尾部</span></span><br><span class="line">	<span class="keyword">return</span> ((i + capacity(<span class="built_in">deque</span>)) % capacity(<span class="built_in">deque</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队首入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushFirst</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;queSize == capacity(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 双向队列已满\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 队首指针向左移动一位</span></span><br><span class="line">	<span class="comment">// 通过取余操作实现 front 越过数组头部回到尾部</span></span><br><span class="line">	<span class="built_in">deque</span>-&gt;front = dequeIndex(<span class="built_in">deque</span>, <span class="built_in">deque</span>-&gt;front - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 将 num 添加到队首</span></span><br><span class="line">	<span class="built_in">deque</span>-&gt;nums[<span class="built_in">deque</span>-&gt;front] = num;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队尾入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushLast</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;queSize == capacity(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 双向队列已满\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算队尾指针，指向队尾索引 + 1</span></span><br><span class="line">	<span class="type">int</span> rear = dequeIndex(<span class="built_in">deque</span>, <span class="built_in">deque</span>-&gt;front + <span class="built_in">deque</span>-&gt;queSize);</span><br><span class="line">	<span class="comment">// 将 num 添加至队尾</span></span><br><span class="line">	<span class="built_in">deque</span>-&gt;nums[rear] = num;</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekFirst</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 访问异常：双向队列为空</span></span><br><span class="line">	assert(empty(<span class="built_in">deque</span>) == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;nums[<span class="built_in">deque</span>-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队尾元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekLast</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 访问异常：双向队列为空</span></span><br><span class="line">	assert(empty(<span class="built_in">deque</span>) == <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> last = dequeIndex(<span class="built_in">deque</span>, <span class="built_in">deque</span>-&gt;front + <span class="built_in">deque</span>-&gt;queSize - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">deque</span>-&gt;nums[last];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队首出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">popFirst</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = peekFirst(<span class="built_in">deque</span>);</span><br><span class="line">	<span class="comment">// 队首指针向后移动一位</span></span><br><span class="line">	<span class="built_in">deque</span>-&gt;front = dequeIndex(<span class="built_in">deque</span>, <span class="built_in">deque</span>-&gt;front + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize--;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 队尾出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">popLast</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = peekLast(<span class="built_in">deque</span>);</span><br><span class="line">	<span class="built_in">deque</span>-&gt;queSize--;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">toArray</span><span class="params">(ArrayDeque *<span class="built_in">deque</span>, <span class="type">int</span> *queSize)</span> &#123;</span><br><span class="line">	*queSize = <span class="built_in">deque</span>-&gt;queSize;</span><br><span class="line">	<span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="built_in">deque</span>-&gt;queSize, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">deque</span>-&gt;front;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">deque</span>-&gt;queSize; i++) &#123;</span><br><span class="line">		res[i] = <span class="built_in">deque</span>-&gt;nums[j % <span class="built_in">deque</span>-&gt;queCapacity];</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-双向队列的应用">3.双向队列的应用</h5>
<ul>
<li>
<p>双向队列兼具了栈和队列的逻辑，因此它可以实现这两者的所有应用场景，同时提供更高的自由度</p>
</li>
<li>
<p>例如：因为软件限制只能撤销最多50步，（撤销功能就需要栈来实现）当栈中存储超过50步的内容时，所以在长度超过50的时候要<strong>将队首删除</strong> ，（这就需要队列的功能）也就是将50步以前的删除掉，减少占用过多的内存</p>
</li>
<li>
<p>双向队列相当于是给这个栈设置了最大容量</p>
</li>
</ul>
<h2 id="6-哈希表">6.哈希表</h2>
<h3 id="1-哈希表">1.哈希表</h3>
<ul>
<li>
<p><strong>哈希表</strong> （hash table），又称<strong>散列表</strong> ，它通过建立<strong>键key</strong> 与<strong>值value</strong> 之间的<strong>映射</strong> ，实现高效的元素查询。</p>
</li>
<li>
<p>效率对比</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>链表</th>
<th>哈希表</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(𝑛)</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>添加元素</td>
<td>𝑂(1)</td>
<td>𝑂(1)</td>
<td>𝑂(1)</td>
</tr>
<tr>
<td>删除元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(𝑛)</td>
<td>𝑂(1)</td>
</tr>
</tbody>
</table>
<h4 id="1-哈希表常用操作">1.哈希表常用操作</h4>
<p># c语言没有提供内置哈希表</p>
<ul>
<li>哈希表的常见操作：初始化，查询操作，添加键值对，删除键值对</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化哈希表</span></span><br><span class="line">hmap: <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加操作</span></span><br><span class="line"><span class="comment"># 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">hmap[<span class="number">12836</span>] = <span class="string">&quot; 小哈&quot;</span></span><br><span class="line">hmap[<span class="number">15937</span>] = <span class="string">&quot; 小啰&quot;</span></span><br><span class="line">hmap[<span class="number">16750</span>] = <span class="string">&quot; 小算&quot;</span></span><br><span class="line">hmap[<span class="number">13276</span>] = <span class="string">&quot; 小法&quot;</span></span><br><span class="line">hmap[<span class="number">10583</span>] = <span class="string">&quot; 小鸭&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询操作</span></span><br><span class="line"><span class="comment"># 向哈希表中输入键 key ，得到值 value</span></span><br><span class="line">name: <span class="built_in">str</span> = hmap[<span class="number">15937</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除操作</span></span><br><span class="line"><span class="comment"># 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">hmap.pop(<span class="number">10583</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>常用的遍历方式：遍历键值对，遍历键，遍历值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历哈希表</span></span><br><span class="line"><span class="comment"># 遍历键值对 key-&gt;value</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> hmap.items():</span><br><span class="line">	<span class="built_in">print</span>(key, <span class="string">&quot;-&gt;&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单独遍历键 key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> hmap.keys():</span><br><span class="line">	<span class="built_in">print</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单独遍历值 value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> hmap.values():</span><br><span class="line">	<span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<h4 id="2-哈希表简单实现">2.哈希表简单实现</h4>
<ul>
<li>
<p>考虑最简单的情况，仅用一个<strong>数组来实现哈希表</strong></p>
</li>
<li>
<p>将数组的每个空位称为<strong>桶</strong> ，每个桶中存储一个键值对</p>
</li>
<li>
<p>查询操作就是找到<strong>key对应的桶</strong> ，再在桶中获取<strong>value</strong></p>
</li>
<li>
<p><strong>哈希函数</strong> （hash function）可以通过key来定位到对应的桶</p>
</li>
<li>
<p>此函数可以将一个较大的输入空间映射到一个较小的输出空间</p>
</li>
<li>
<p>即将所有key映射到所有桶（数组索引）</p>
</li>
<li>
<p>哈希函数的计算分为两步：</p>
<ul>
<li>通过哈希算法hash（）计算得到哈希值</li>
<li>将哈希值对桶数量（数组长度）capacity取模，从而获取该key对应的数组索引index</li>
<li>index = hash(key) % capacity</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>:</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 键值对&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">		<span class="variable language_">self</span>.key = key</span><br><span class="line">		<span class="variable language_">self</span>.val = val</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayHashMap</span>:</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 基于数组实现的哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 构造方法&quot;&quot;&quot;</span></span><br><span class="line">	<span class="comment"># 初始化数组，包含 100 个桶</span></span><br><span class="line">	<span class="variable language_">self</span>.buckets: <span class="built_in">list</span>[Pair | <span class="literal">None</span>] = [<span class="literal">None</span>] * <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 哈希函数&quot;&quot;&quot;</span></span><br><span class="line">		index = key % <span class="number">100</span></span><br><span class="line">		<span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 查询操作&quot;&quot;&quot;</span></span><br><span class="line">		index: <span class="built_in">int</span> = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		pair: Pair = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">		<span class="keyword">if</span> pair <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">		<span class="keyword">return</span> pair.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 添加操作&quot;&quot;&quot;</span></span><br><span class="line">		pair = Pair(key, val)</span><br><span class="line">		index: <span class="built_in">int</span> = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		<span class="variable language_">self</span>.buckets[index] = pair</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 删除操作&quot;&quot;&quot;</span></span><br><span class="line">		index: <span class="built_in">int</span> = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		<span class="comment"># 置为 None ，代表删除</span></span><br><span class="line">		<span class="variable language_">self</span>.buckets[index] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">entry_set</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[Pair]:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 获取所有键值对&quot;&quot;&quot;</span></span><br><span class="line">		result: <span class="built_in">list</span>[Pair] = []</span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">			<span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">				result.append(pair)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">key_set</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 获取所有键&quot;&quot;&quot;</span></span><br><span class="line">	result = []</span><br><span class="line">	<span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">		<span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">			result.append(pair.key)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">value_set</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">str</span>]:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 获取所有值&quot;&quot;&quot;</span></span><br><span class="line">		result = []</span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">			<span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">             result.append(pair.val)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">			<span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">				<span class="built_in">print</span>(pair.key, <span class="string">&quot;-&gt;&quot;</span>, pair.val)</span><br></pre></td></tr></table></figure>
<p># 这里设置数组长度 capacity = 100、哈希算法 hash(key) = key ，易得哈希函数为 key % 100</p>
<h4 id="3-哈希冲突与扩容">3.哈希冲突与扩容</h4>
<ul>
<li>
<p>哈希函数可以将一个<strong>较大的</strong> 输入空间映射到一个<strong>较小的</strong> 输出空间</p>
</li>
<li>
<p>所以理论上必定会存在重复的现象</p>
</li>
<li>
<p>即多个输入对应一个输出</p>
</li>
<li>
<p>将这种多个输入对应同一输出的情况称为<strong>哈希冲突</strong> （hash collision）</p>
</li>
<li>
<p>扩容哈希表（数组）可以降低哈希冲突的概率</p>
</li>
<li>
<p>但是扩容就需要用到数组的迁移，所以在一开始就要给哈希表留足够大的容量，防止频繁扩容</p>
</li>
<li>
<p><strong>负载因子</strong> （load factor）是哈希表的一个重要概念，其定义为哈希表的<strong>元素数量除以桶数量</strong> ，用于衡量哈希冲突的<strong>严重程度</strong> ，也常作为<strong>哈希表扩容的触发条件</strong> 。</p>
</li>
<li>
<p>例如在 Java 中，当负载因子超过0.75时，系统会将哈希表扩容至原先的2倍。</p>
</li>
</ul>
<h3 id="2-哈希冲突">2.哈希冲突</h3>
<ul>
<li>理论上哈希冲突是不可避免的</li>
<li>可以通过一直扩容直到哈希冲突消失，但是效率过低</li>
<li>可以采取两种策略
<ul>
<li>改良哈希表的数据结构，使得哈希表可以在出现哈希冲突的时候正常工作</li>
<li>仅在哈希冲突严重的时候才执行扩容操作</li>
</ul>
</li>
</ul>
<h4 id="1-链式地址">1.链式地址</h4>
<ul>
<li>
<p>在原始哈希表中，每个桶仅能存储一个键值对。<strong>链式地址</strong> （separate chaining）<strong>将单个元素转换为链表</strong> ，将键值对作为链表节点，将<strong>所有发生冲突的键值对都存储在同一链表</strong> 中</p>
</li>
<li>
<p>是一个<strong>索引对应数组元素</strong> ，<strong>数组元素再对应一个链表</strong> 的结构</p>
</li>
<li>
<p>其操作方式也就发生了改变</p>
<ul>
<li><strong>查询元素</strong>：输入key，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比key以查找目标键值对。</li>
<li><strong>添加元素</strong>：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。</li>
<li><strong>删除元素</strong>：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。</li>
</ul>
</li>
<li>
<p>因此也就存在了局限性</p>
<ul>
<li><strong>占用空间增大</strong>：链表包含节点指针，它相比数组更加耗费内存空间。</li>
<li><strong>查询效率降低</strong>：因为需要线性遍历链表来查找对应元素。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span>:</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 链式地址哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 构造方法&quot;&quot;&quot;</span></span><br><span class="line">		<span class="variable language_">self</span>.size = <span class="number">0</span> <span class="comment"># 键值对数量</span></span><br><span class="line">		<span class="variable language_">self</span>.capacity = <span class="number">4</span> <span class="comment"># 哈希表容量</span></span><br><span class="line">		<span class="variable language_">self</span>.load_thres = <span class="number">2.0</span> / <span class="number">3.0</span> <span class="comment"># 触发扩容的负载因子阈值</span></span><br><span class="line">		<span class="variable language_">self</span>.extend_ratio = <span class="number">2</span> <span class="comment"># 扩容倍数</span></span><br><span class="line">		<span class="variable language_">self</span>.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.capacity)] <span class="comment"># 桶数组</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 哈希函数&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">return</span> key % <span class="variable language_">self</span>.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_factor</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 负载因子&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">self</span>.size / <span class="variable language_">self</span>.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span> | <span class="literal">None</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 查询操作&quot;&quot;&quot;</span></span><br><span class="line">		index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		bucket = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">		<span class="comment"># 遍历桶，若找到 key ，则返回对应 val</span></span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">			<span class="keyword">if</span> pair.key == key:</span><br><span class="line">				<span class="keyword">return</span> pair.val</span><br><span class="line">		<span class="comment"># 若未找到 key ，则返回 None</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 添加操作&quot;&quot;&quot;</span></span><br><span class="line">		<span class="comment"># 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">		<span class="keyword">if</span> <span class="variable language_">self</span>.load_factor() &gt; <span class="variable language_">self</span>.load_thres:</span><br><span class="line">			<span class="variable language_">self</span>.extend()</span><br><span class="line">		index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		bucket = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">		<span class="comment"># 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">			<span class="keyword">if</span> pair.key == key:</span><br><span class="line">				pair.val = val</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">		<span class="comment"># 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">		pair = Pair(key, val)</span><br><span class="line">		bucket.append(pair)</span><br><span class="line">		<span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 删除操作&quot;&quot;&quot;</span></span><br><span class="line">		index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">		bucket = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">		<span class="comment"># 遍历桶，从中删除键值对</span></span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">			<span class="keyword">if</span> pair.key == key:</span><br><span class="line">				bucket.remove(pair)</span><br><span class="line">				<span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 扩容哈希表&quot;&quot;&quot;</span></span><br><span class="line">		<span class="comment"># 暂存原哈希表</span></span><br><span class="line">		buckets = <span class="variable language_">self</span>.buckets</span><br><span class="line">		<span class="comment"># 初始化扩容后的新哈希表</span></span><br><span class="line">		<span class="variable language_">self</span>.capacity *= <span class="variable language_">self</span>.extend_ratio</span><br><span class="line">		<span class="variable language_">self</span>.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.capacity)]</span><br><span class="line">		<span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line">		<span class="comment"># 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">		<span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">			<span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">				<span class="variable language_">self</span>.put(pair.key, pair.val)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; 打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> bucket <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">		res = []</span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">			res.append(<span class="built_in">str</span>(pair.key) + <span class="string">&quot; -&gt; &quot;</span> + pair.val)</span><br><span class="line">		<span class="built_in">print</span>(res)                </span><br></pre></td></tr></table></figure>
<p># 使用列表（动态数组）代替链表，从而简化代码。在这种设定下，哈希表（数组）包含多个桶，每个桶都是一个列表。</p>
<p># 这里实现包含哈希表扩容方法。当负载因子超过 2/3 时，将哈希表扩容至原先的 2 倍。</p>
<p># 当链表很长时，查询效率 𝑂(𝑛) 很差。此时可以将链表转换为<strong>AVL 树</strong> 或<strong>红黑树</strong> ，从而将查询操作的时间复杂度优化至 𝑂(log 𝑛) 。</p>
<h4 id="2-开放寻址">2.开放寻址</h4>
<ul>
<li><strong>开放寻址</strong> （open addressing）不引入额外的数据结构，而是通过<strong>多次探测</strong> 来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。</li>
<li><strong>开放</strong> ：即是所有键值对都存储在数组内，而不是数组元素对应的链表</li>
<li><strong>寻址</strong> ：哈希冲突时，按照预定规则，寻址下一个可用的空位置</li>
</ul>
<h5 id="1-线性探测">1.线性探测</h5>
<ul>
<li>
<p>采用固定步长的线性搜索来探测</p>
</li>
<li>
<p>其操作方法与普通哈希表有所不同</p>
<ul>
<li><strong>插入元素</strong> ：通过哈希函数计算桶索引，若发现桶内已有元素（即发生哈希冲突），则从冲突位置向后线性遍历，步长通常为1 ，直至找到空桶，将元素插入其中。
<ul>
<li>所以其插入的一定是第一个空桶，所以下面查找时，遇到第一个空桶，即元素不在表中</li>
<li>因此也导致下面的聚集问题</li>
</ul>
</li>
<li><strong>查找元素</strong> ：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。
<ul>
<li>元素查找时，如果不在其初始的位置，那么就是发生了哈希冲突导致其插入时向后找可用的第一个空桶，查找时是从初始位置开始一直到第一个空桶，因为元素只有可能在这个区间内（直接删除元素的情况除外）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>线性探测容易产生<strong>聚集现象</strong> 。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成<strong>恶性循环</strong> ，最终导致增删查改操作效率劣化。</p>
</li>
<li>
<p>不能在开放寻址哈希表中直接删除元素。这是因为删除元素会在数组内产生一个空桶None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在</p>
</li>
<li>
<p>为了解决该问题，可以采用<strong>懒删除</strong> （lazy deletion）机制：它不直接从哈希表中移除元素，而是利用一个常量 <strong>Tombstone/Deleted来标记</strong>这个桶。在该机制下，None和Tombstone/Deleted都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。</p>
</li>
<li>
<p>但是，懒删除可能会加速哈希表的<strong>性能退化</strong> 。这是因为每次删除操作都会产生一个删除标记，随着 Tombstone/Deleted的增加，搜索时间也会增加，因为线性探测可能需要跳过多个Tombstone/Deleted才能找到目标元素。</p>
</li>
<li>
<p>在线性探测中记录遇到的首个Tombstone/Deleted的索引，并将搜索到的目标元素与该Tombstone/Deleted<strong>交换位置</strong> 。这样做的好处是当每次查询或添加元素时，元素会被移动至<strong>距离理想位置（探测起始点）更近的桶</strong> ，从而优化查询效率。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 开放寻址哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span> <span class="comment"># 键值对数量</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity = <span class="number">4</span> <span class="comment"># 哈希表容量</span></span><br><span class="line">        <span class="variable language_">self</span>.load_thres = <span class="number">2.0</span> / <span class="number">3.0</span> <span class="comment"># 触发扩容的负载因子阈值</span></span><br><span class="line">        <span class="variable language_">self</span>.extend_ratio = <span class="number">2</span> <span class="comment"># 扩容倍数</span></span><br><span class="line">        <span class="variable language_">self</span>.buckets: <span class="built_in">list</span>[Pair | <span class="literal">None</span>] = [<span class="literal">None</span>] * <span class="variable language_">self</span>.capacity <span class="comment"># 桶数组</span></span><br><span class="line">        <span class="variable language_">self</span>.TOMBSTONE = Pair(-<span class="number">1</span>, <span class="string">&quot;-1&quot;</span>) <span class="comment"># 删除标记</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">		<span class="string">&quot;&quot;&quot; 哈希函数&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">return</span> key % <span class="variable language_">self</span>.capacity</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">load_factor</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 负载因子&quot;&quot;&quot;</span></span><br><span class="line">   	    <span class="keyword">return</span> <span class="variable language_">self</span>.size / <span class="variable language_">self</span>.capacity</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_bucket</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; 搜索 key 对应的桶索引&quot;&quot;&quot;</span></span><br><span class="line">        index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">        first_tombstone = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 线性探测，当遇到空桶时跳出</span></span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 若遇到 key ，返回对应的桶索引</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index].key == key:</span><br><span class="line">                <span class="comment"># 若之前遇到了删除标记，则将键值对移动至该索引处</span></span><br><span class="line">                <span class="keyword">if</span> first_tombstone != -<span class="number">1</span>:</span><br><span class="line">                    <span class="variable language_">self</span>.buckets[first_tombstone] = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">                    <span class="variable language_">self</span>.buckets[index] = <span class="variable language_">self</span>.TOMBSTONE</span><br><span class="line">                    <span class="keyword">return</span> first_tombstone <span class="comment"># 返回移动后的桶索引</span></span><br><span class="line">                <span class="keyword">return</span> index <span class="comment"># 返回桶索引</span></span><br><span class="line">            <span class="comment"># 记录遇到的首个删除标记</span></span><br><span class="line">            <span class="keyword">if</span> first_tombstone == -<span class="number">1</span> <span class="keyword">and</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">is</span> <span class="variable language_">self</span>.TOMBSTONE:</span><br><span class="line">                first_tombstone = index</span><br><span class="line">                <span class="comment"># 计算桶索引，越过尾部则返回头部</span></span><br><span class="line">                index = (index + <span class="number">1</span>) % <span class="variable language_">self</span>.capacity</span><br><span class="line">			<span class="comment"># 若 key 不存在，则返回添加点的索引</span></span><br><span class="line">            <span class="keyword">return</span> index <span class="keyword">if</span> first_tombstone == -<span class="number">1</span> <span class="keyword">else</span> first_tombstone</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot; 查询操作&quot;&quot;&quot;</span></span><br><span class="line">   		    <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">            index = <span class="variable language_">self</span>.find_bucket(key)</span><br><span class="line">            <span class="comment"># 若找到键值对，则返回对应 val</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>.buckets[index].val</span><br><span class="line">            <span class="comment"># 若键值对不存在，则返回 None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot; 添加操作&quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.load_factor() &gt; <span class="variable language_">self</span>.load_thres:</span><br><span class="line">                <span class="variable language_">self</span>.extend()</span><br><span class="line">            <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">   	        index = <span class="variable language_">self</span>.find_bucket(key)</span><br><span class="line">            <span class="comment"># 若找到键值对，则覆盖 val 并返回</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">                <span class="variable language_">self</span>.buckets[index].val = val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 若键值对不存在，则添加该键值对</span></span><br><span class="line">            <span class="variable language_">self</span>.buckets[index] = Pair(key, val)</span><br><span class="line">            <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 删除操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">        index = <span class="variable language_">self</span>.find_bucket(key)</span><br><span class="line">        <span class="comment"># 若找到键值对，则用删除标记覆盖它</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">            <span class="variable language_">self</span>.buckets[index] = <span class="variable language_">self</span>.TOMBSTONE</span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">          </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 扩容哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 暂存原哈希表</span></span><br><span class="line">        buckets_tmp = <span class="variable language_">self</span>.buckets</span><br><span class="line">        <span class="comment"># 初始化扩容后的新哈希表</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity *= <span class="variable language_">self</span>.extend_ratio</span><br><span class="line">        <span class="variable language_">self</span>.buckets = [<span class="literal">None</span>] * <span class="variable language_">self</span>.capacity</span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> buckets_tmp:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">                <span class="variable language_">self</span>.put(pair.key, pair.val)</span><br><span class="line">                </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> pair <span class="keyword">is</span> <span class="variable language_">self</span>.TOMBSTONE:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;TOMBSTONE&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(pair.key, <span class="string">&quot;-&gt;&quot;</span>, pair.val)</span><br></pre></td></tr></table></figure>
<p># 为了更加充分地使用哈希表的空间，将哈希表看作一个<strong>环形数组</strong> ，当越过数组尾部时，回到头部继续遍历。</p>
<h5 id="2-平方探测">2.平方探测</h5>
<ul>
<li>
<p>与线性探测类似，发生冲突时，会跳过<strong>探测次数的平方</strong> 的步数，即 1, 4, 9, … 步</p>
</li>
<li>
<p>平方探测主要具有以下优势：</p>
<ul>
<li>平方探测通过跳过探测次数平方的距离，试图<strong>缓解线性探测的聚集效应</strong> 。</li>
<li>平方探测会跳过更大的距离来寻找空位置，有助于数据<strong>分布得更加均匀</strong> 。</li>
</ul>
</li>
<li>
<p>同样也有局限性：</p>
<ul>
<li>
<p>仍然存在聚集现象，即某些位置比其他位置更容易被占用。</p>
</li>
<li>
<p>由于平方的增长，平方探测可能<strong>不会探测整个哈希表</strong> ，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。</p>
</li>
<li>
<p>同样不能直接删除元素</p>
</li>
</ul>
</li>
</ul>
<h5 id="3-多次哈希">3.多次哈希</h5>
<ul>
<li>
<p>多次哈希方法使用多个哈希函数 𝑓1(𝑥)、𝑓2(𝑥)、𝑓3(𝑥)、… 进行探测</p>
</li>
<li>
<p>插入元素：若哈希函数 𝑓1(𝑥) 出现冲突，则尝试 𝑓2(𝑥) ，以此类推，直到找到空位后插入元素。</p>
</li>
<li>
<p>查找元素：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 None 。</p>
</li>
<li>
<p>同样不能直接删除元素</p>
</li>
</ul>
<h4 id="3-编程语言的选择">3.编程语言的选择</h4>
<ul>
<li>各种编程语言采取了不同的哈希表实现策略
<ul>
<li><strong>Python</strong>  采用<strong>开放寻址</strong> 。<strong>字典 dict</strong>  使用<strong>伪随机数</strong> 进行探测。</li>
<li><strong>Java</strong> 采用<strong>链式地址</strong> 。自 JDK 1.8 以来，当 HashMap 内数组长度达到 64 且链表长度达到 8 时，链表会转换为<strong>红黑树</strong> 以提升查找性能。</li>
<li><strong>Go</strong> 采用<strong>链式地址</strong> 。Go规定每个桶最多存储 8 个键值对，超出容量则连接一个溢出桶；当溢出桶过多时，会<strong>执行一次特殊的等量扩容操作</strong> ，以确保性能。</li>
</ul>
</li>
</ul>
<h3 id="3-哈希算法">3.哈希算法</h3>
<ul>
<li>
<p>无论是开放寻址还是链式地址，它们只能保证哈希表可以在发生冲突时正常工作，而无法减少哈希冲突的发生</p>
</li>
<li>
<p>如果哈希冲突过于频繁，哈希表的性能则会急剧劣化</p>
</li>
<li>
<p><strong>键值对的分布情况由哈希函数决定</strong></p>
</li>
<li>
<p>index = hash(key) % capacity</p>
</li>
<li>
<p>当哈希表容量 capacity 固定时，哈希算法 hash() 决定了输出值</p>
</li>
<li>
<p>所以要降低哈希冲突的概率，就要集中于哈希算法的设计</p>
</li>
</ul>
<h4 id="1-哈希算法的目标">1.哈希算法的目标</h4>
<ul>
<li>
<p>为了实现既<strong>快</strong> 又<strong>稳</strong> 的哈希表数据结构，哈希算法应具备以下特点。</p>
<ul>
<li><strong>确定性</strong> ：对于<strong>相同的输入</strong> ，哈希算法应始终产生<strong>相同的输出</strong> 。这样才能确保哈希表是可靠的。</li>
<li><strong>效率高</strong> ：<strong>计算哈希值的过程应该足够快</strong> 。计算开销越小，哈希表的<strong>实用性越高</strong> 。</li>
<li><strong>均匀分布</strong> ：哈希算法应使得<strong>键值对均匀分布</strong> 在哈希表中。分布越均匀，<strong>哈希冲突的概率就越低</strong> 。</li>
</ul>
</li>
<li>
<p>在其他领域中也有广泛应用</p>
<ul>
<li><strong>密码存储</strong> ：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会<strong>对输入的密码计算哈希值</strong> ，然后<strong>与存储的哈希值进行比较</strong> 。如果两者匹配，那么密码就被视为正确。</li>
<li><strong>数据完整性检查</strong> ：数据发送方可以<strong>计算数据的哈希值</strong> 并将其一同发送；接收方可以重新<strong>计算接收到的数据的哈希值</strong> ，并<strong>与接收到的哈希值进行比较</strong> 。如果<strong>两者匹配</strong> ，那么数据就被视为完整。</li>
</ul>
</li>
<li>
<p>在<strong>密码学</strong> 中，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全特性</p>
<ul>
<li><strong>单向性</strong> ：无法通过哈希值反推出关于输入数据的任何信息。</li>
<li><strong>抗碰撞性</strong> ：应当<strong>极难</strong> 找到两个不同的输入，使得它们的哈希值相同。即哈希冲突（哈希碰撞）</li>
</ul>
<p># 这里不完全等同于均匀分布，均匀分布是均匀导致哈希冲突概率低，但是哈希算法可以较为简单，可以被简单的反推出来，而抗碰撞性是通过计算复杂度使其极难发生哈希冲突</p>
<p># <strong>哈希冲突</strong>就像是“世界上存在两片一模一样的雪花”。我们知道理论上可能存在，但几乎没人见过。</p>
<p># <strong>抗碰撞性</strong>就是“制造一台机器，让它能故意造出两片一模一样的雪花”。密码学哈希函数的设计目标就是，让造出这台机器的难度高到令人绝望。</p>
<ul>
<li><strong>雪崩效应</strong> ：<strong>输入的微小变化</strong> 应当导致<strong>输出的显著且不可预测的变化</strong> 。</li>
</ul>
</li>
</ul>
<h4 id="2-哈希算法的设计">2.哈希算法的设计</h4>
<ul>
<li>对于某些要求不高的场景，可以设计一些简单的哈希算法。</li>
<li><strong>加法哈希</strong> ：对输入的<strong>每个字符的ASCII码</strong> 进行相加，将得到的总和作为哈希值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 加法哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> += <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>乘法哈希</strong> ：利用<strong>乘法的不相关性</strong> ，每轮乘以一个常数，将各个字符的ASCII码累积到哈希值中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mul_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 乘法哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> = <span class="number">31</span> * <span class="built_in">hash</span> + <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>异或哈希</strong> ：将输入数据的每个元素通过<strong>异或操作</strong> 累积到一个哈希值中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 异或哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> ^= <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>旋转哈希</strong> ：将每个<strong>字符的ASCII码</strong> 累积到一个哈希值中，每次累积之前都会对哈希值进行<strong>旋转操作</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rot_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 旋转哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> = (<span class="built_in">hash</span> &lt;&lt; <span class="number">4</span>) ^ (<span class="built_in">hash</span> &gt;&gt; <span class="number">28</span>) ^ <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br></pre></td></tr></table></figure>
<ul>
<li>这些算法的最后都是对大质数1000000007取模，可以确保哈希值在合适的范围内</li>
<li>因为质数不存在公约数，减少出现取模产生的周期性模式，最大程度的保证哈希值均匀分布，避免聚集现象的出现，避免哈希冲突</li>
</ul>
<h4 id="3-常见哈希算法">3.常见哈希算法</h4>
<ul>
<li>以上算法都比较简单</li>
<li>实际中会采用一些标准哈希算法</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>MD5</th>
<th>SHA-1</th>
<th>SHA-2</th>
<th>SHA-3</th>
</tr>
</thead>
<tbody>
<tr>
<td>推出时间</td>
<td>1992</td>
<td>1995</td>
<td>2002</td>
<td>2008</td>
</tr>
<tr>
<td>输出长度</td>
<td>128 bit</td>
<td>160 bit</td>
<td>256/512 bit</td>
<td>224/256/384/512 bit</td>
</tr>
<tr>
<td>哈希冲突</td>
<td>较多</td>
<td>较多</td>
<td>很少</td>
<td>很少</td>
</tr>
<tr>
<td>安全等级</td>
<td>低，已被成功攻击</td>
<td>低，已被成功攻击</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>应用</td>
<td>已被弃用，仍用于数据完整性检查</td>
<td>已被弃用</td>
<td>加密货币交易验证、数字签名等</td>
<td>可用于替代 SHA‑2</td>
</tr>
</tbody>
</table>
<ul>
<li>SHA‑2 系列中的 SHA‑256 是最安全的哈希算法之一，仍未出现成功的攻击案例，因此常用在各类安全应用与协议中。</li>
<li>SHA‑3 相较 SHA‑2 的实现开销更低、计算效率更高，但目前使用覆盖度不如 SHA‑2 系列。</li>
</ul>
<h4 id="4-数据结构的哈希值">4.数据结构的哈希值</h4>
<ul>
<li>
<p>编程语言中通常会为数据类型提供内置的哈希算法</p>
</li>
<li>
<p>在python中，调用hash()来计算各种数据类型的哈希值</p>
<ul>
<li><strong>整数</strong> 和<strong>布尔量</strong> 的哈希值就是<strong>其本身</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">3</span></span><br><span class="line">hash_num = <span class="built_in">hash</span>(num)</span><br><span class="line"><span class="comment"># 整数 3 的哈希值为 3</span></span><br><span class="line"></span><br><span class="line">bol = <span class="literal">True</span></span><br><span class="line">hash_bol = <span class="built_in">hash</span>(bol)</span><br><span class="line"><span class="comment"># 布尔量 True 的哈希值为 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>浮点数</strong> 和<strong>字符串</strong> 的哈希值计算<strong>较为复杂</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dec = <span class="number">3.14159</span></span><br><span class="line">hash_dec = <span class="built_in">hash</span>(dec)</span><br><span class="line"><span class="comment"># 小数 3.14159 的哈希值为 326484311674566659</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hello 算法&quot;</span></span><br><span class="line">hash_str = <span class="built_in">hash</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 字符串“Hello 算法”的哈希值为 4617003410720528961</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>元组</strong> 的哈希值是<strong>对其中每一个元素进行哈希</strong> ，然后将这些<strong>哈希值组合起来</strong> ，<strong>得到单一的哈希值</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">12836</span>, <span class="string">&quot; 小哈&quot;</span>)</span><br><span class="line">hash_tup = <span class="built_in">hash</span>(tup)</span><br><span class="line"><span class="comment"># 元组 (12836, &#x27;小哈&#x27;) 的哈希值为 1029005403108185979</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对象</strong> 的哈希值<strong>基于其内存地址</strong> 生成。通过<strong>重写对象的哈希方法</strong> ，可实现<strong>基于内容生成哈希值</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = ListNode(<span class="number">0</span>)</span><br><span class="line">hash_obj = <span class="built_in">hash</span>(obj)</span><br><span class="line"><span class="comment"># 节点对象 &lt;ListNode object at 0x1058fd810&gt; 的哈希值为 274267521</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p># 不同编程语言的内置哈希值计算函数的定义和方法不同</p>
<ul>
<li>
<p>在许多编程语言中，<strong>只有不可变对象才可作为哈希表的</strong> <strong>key</strong> 。将列表（动态数组）作为key，当列表的内容发生变化时，它的哈希值也随之改变，就无法在哈希表中查询到原先的value了</p>
</li>
<li>
<p>虽然自定义对象（比如链表节点）的成员变量是可变的，但它是可哈希的。<strong>这是因为对象的哈希值通常是基于内存地址生成的</strong>，即使对象的<strong>内容发生了变化</strong> ，但<strong>它的内存地址不变</strong> ，哈希值仍然是不变的</p>
</li>
<li>
<p>在不同控制台中运行程序时，输出的哈希值是不同的。<strong>这是因为 Python 解释器在每次启动时，都会为字符串哈希函数加入一个随机的盐（salt）值</strong>。这种做法可以有效防止 HashDoS 攻击，提升哈希算法的安全性。</p>
</li>
</ul>
<h2 id="7-树">7.树</h2>
<h3 id="1-二叉树">1.二叉树</h3>
<ul>
<li>
<p><strong>二叉树</strong> （binary tree）是一种<strong>非线性</strong> 数据结构，代表<strong>祖先</strong> 与<strong>后代</strong> 之间的<strong>派生关系</strong> ，体现了<strong>一分为二</strong></p>
<p>的分治逻辑。与链表类似，二叉树的<strong>基本单元是节点</strong> ，每个节点包含<strong>值</strong> 、<strong>左子节点引用</strong> 和<strong>右子节点引用</strong> 。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树节点结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    <span class="type">int</span> height; <span class="comment">// 节点高度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span> <span class="comment">// 左子节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span> <span class="comment">// 右子节点指针</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">TreeNode *<span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode *node;</span><br><span class="line">    </span><br><span class="line">    node = (TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;height = <span class="number">0</span>;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code class="highlight mermaid">flowchart TD
	1[&quot;1
	(2和3的父节点)&quot;] --&gt; 2[&quot;2
	(左子节点)&quot;]
	1 --&gt; 3[&quot;3
	(右子节点)&quot;]
	subgraph 右子树
	3 --&gt; 6
	3 --&gt; 7
	end
	subgraph 左子树
	2 --&gt; 4
	2 --&gt; 5
	end
</code></pre>
<ul>
<li>
<p>每个节点都有<strong>两个引用</strong> （指针），分别指向<strong>左子节点</strong> （left‑child node）和<strong>右子节点</strong> （right‑child node），该节点被称为这两个子节点的<strong>父节点</strong> （parent node）。当给定一个二叉树的节点时，将该节点的左子节点及其以下节点形成的树称为该节点的<strong>左子树</strong> （left subtree），同理可得<strong>右子树</strong> （right subtree）</p>
</li>
<li>
<p>在二叉树中，除叶节点外，其他所有节点都包含<strong>子节点</strong> 和<strong>非空子树</strong></p>
</li>
</ul>
<h4 id="1-二叉树常见术语">1.二叉树常见术语</h4>
<ul>
<li><strong>根节点</strong> （root node）：位于二叉树顶层的节点，<strong>没有父节点</strong> 。</li>
<li><strong>叶节点</strong> （leaf node）：<strong>没有子节点</strong> 的节点，其两个指针均<strong>指向None</strong> 。</li>
<li><strong>边</strong> （edge）：<strong>连接两个节点的线段</strong> ，即<strong>节点引用</strong> （指针）。</li>
<li>节点所在的<strong>层</strong> （level）：<strong>从顶至底</strong> 递增，<strong>根节点</strong> 所在层为<strong>1</strong> 。</li>
<li>节点的<strong>度</strong> （degree）：<strong>节点的子节点的数量</strong> 。在二叉树中，度的取值范围是 0、1、2 。</li>
<li>二叉树的<strong>高度</strong> （height）：从<strong>根节点</strong> 到<strong>最远叶节点</strong> 所经过的<strong>边的数量</strong> 。</li>
<li>节点的<strong>深度</strong> （depth）：从<strong>根节点</strong> 到<strong>该节点</strong> 所经过的<strong>边的数量</strong> 。</li>
<li>节点的<strong>高度</strong> （height）：从距离<strong>该节点最远的叶节点</strong> 到<strong>该节点</strong> 所经过的<strong>边的数量</strong> 。</li>
</ul>
<pre><code class="highlight mermaid">flowchart TB
	subgraph 高度为3的二叉树
	direction TB
	1[&quot;1
	(根节点)
	(层为1)
	(度为2)
	(深度为0)
	(高度为3)&quot;] --边--&gt; 2[&quot;2
	(层为2)
	(度为2)
	(深度为1)
	(高度为2)&quot;]
	1 --边--&gt; 3[&quot;3
	(层为2)
	(度为2)
	(深度为1)
	(高度为2)&quot;]
	3 --边--&gt; 6[&quot;6
	(层为3)
	(度为1)
	(深度为2)
	(高度为1)&quot;]
	3 --边--&gt; 7[&quot;7
	(层为3)
	(度为2)
	(深度为2)
	(高度为1)&quot;]
	2 --边--&gt; 4[&quot;4
	(层为3)
	(度为2)
	(深度为2)
	(高度为1)&quot;]
    2 --边--&gt; 5[&quot;5
    (叶节点)
    (层为3)
    (度为0)
    (深度为2)
    (高度为1)&quot;]
    4 --边--&gt; 8[&quot;8
    (叶节点)
    (层为4)
    (度为0)
    (深度为3)
    (高度为0)&quot;]
    4 --边--&gt; 9[&quot;9
    (叶节点)
    (层为4)
    (度为0)
    (深度为3)
    (高度为0)&quot;]
    6 --边--&gt; 12[&quot;12
    (叶节点)
    (层为4)
    (度为0)
    (深度为3)
    (高度为0)&quot;]
    7 --边--&gt; 14[&quot;14
    (叶节点)
    (层为4)
    (度为0)
    (深度为3)
    (高度为0)&quot;]
    7 --边--&gt; 15[&quot;15
    (叶节点)
    (层为4)
    (度为0)
    (深度为3)
    (高度为0)&quot;]   
    end</code></pre>
<h4 id="2-二叉树基本操作">2.二叉树基本操作</h4>
<h5 id="1-初始化二叉树">1.初始化二叉树</h5>
<ul>
<li>与链表相似，先初始化节点，然后构建引用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化二叉树 */</span></span><br><span class="line"><span class="comment">// 初始化节点</span></span><br><span class="line">TreeNode *n1 = newTreeNode(<span class="number">1</span>);</span><br><span class="line">TreeNode *n2 = newTreeNode(<span class="number">2</span>);</span><br><span class="line">TreeNode *n3 = newTreeNode(<span class="number">3</span>);</span><br><span class="line">TreeNode *n4 = newTreeNode(<span class="number">4</span>);</span><br><span class="line">TreeNode *n5 = newTreeNode(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 构建节点之间的引用（指针）</span></span><br><span class="line">n1-&gt;left = n2;</span><br><span class="line">n1-&gt;right = n3;</span><br><span class="line">n2-&gt;left = n4;</span><br><span class="line">n2-&gt;right = n5;</span><br></pre></td></tr></table></figure>
<h5 id="2-插入与删除节点">2.插入与删除节点</h5>
<ul>
<li>与链表相似，都是修改指针</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
    
    subgraph 插入后二叉树
    direction TB
    1&#x27;[&quot;1
    (n1)&quot;] --&gt; 0
	1&#x27; --&gt; 3&#x27;[3]
	0[&quot;0
	(p)&quot;] --&gt; 2&#x27;[&quot;2
	(n2)&quot;]
    2&#x27; --&gt; 4&#x27;[4]
    2&#x27; --&gt; 5&#x27;[5]
    end
    
    subgraph 原二叉树
	direction TB
	1[&quot;1
	(n1)&quot;] --&gt; 2[&quot;2
	(n2)&quot;]
	1 --&gt; 3
	2 --&gt; 4
    2 --&gt; 5
    0&#x27;[&quot;0
	(p)&quot;]
    end
    
    subgraph 删除后二叉树
	direction TB
	1&#x27;&#x27;[&quot;1
	(n1)&quot;] --&gt; 2&#x27;&#x27;[&quot;2
	(n2)&quot;]
	1&#x27;&#x27; --&gt; 3&#x27;&#x27;[3]
	2&#x27;&#x27; --&gt; 4&#x27;&#x27;[4]
    2&#x27;&#x27; --&gt; 5&#x27;&#x27;[5]
    end
    
    
    
    原二叉树 --n1.left = p
    p.left = n2--&gt; 插入后二叉树
    
    插入后二叉树 --n1.left = n2--&gt; 删除后二叉树</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入与删除节点 */</span></span><br><span class="line">TreeNode *P = newTreeNode(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 在 n1 -&gt; n2 中间插入节点 P</span></span><br><span class="line">n1-&gt;left = P;</span><br><span class="line">P-&gt;left = n2;</span><br><span class="line"><span class="comment">// 删除节点 P</span></span><br><span class="line">n1-&gt;left = n2;</span><br></pre></td></tr></table></figure>
<p># 原有的引用不删除，只将插入的节点删除，所以删除后就是原二叉树，如果将原有引用删除后又删除插入的节点则就是删除了整个左子树</p>
<h4 id="3-常见二叉树类型">3.常见二叉树类型</h4>
<h5 id="1-完美二叉树-满二叉树">1.完美二叉树(满二叉树)</h5>
<ul>
<li><strong>完美二叉树</strong> （perfect binary tree）所有层的节点都被完全填满。在完美二叉树中，叶节点的度 为 0 ，其余所有节点的度都为 2 ；若树的高度为 ℎ ，则节点总数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{ℎ+1} − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象</li>
</ul>
<pre><code class="highlight mermaid">flowchart TD
	1 --&gt; 2
	1 --&gt; 3
	3 --&gt; 6
	3 --&gt; 7
	2 --&gt; 4
	2 --&gt; 5
	4 --&gt; 8
	4 --&gt; 9
	5 --&gt; 10
	5 --&gt; 11
	6 --&gt; 12
	6 --&gt; 13
	7 --&gt; 14
	7 --&gt; 15</code></pre>
<h5 id="2-完全二叉树">2.完全二叉树</h5>
<ul>
<li><strong>完全二叉树</strong> （complete binary tree）只有<strong>最底层</strong> 的节点<strong>未被填满</strong> ，且<strong>最底层</strong> 节点<strong>尽量靠左</strong> 填充。</li>
</ul>
<p># 完美二叉树也是一棵完全二叉树。</p>
<pre><code class="highlight mermaid">flowchart TD
	1 --&gt; 2
	1 --&gt; 3
	3 --&gt; 6
	3 --&gt; 7
	2 --&gt; 4
	2 --&gt; 5
	4 --&gt; 8
	4 --&gt; 9
	5 --&gt; 10
	5 --&gt; 11
	6 --&gt; 12</code></pre>
<h5 id="3-完满二叉树">3.完满二叉树</h5>
<ul>
<li><strong>完满二叉树</strong> （full binary tree）除了叶节点之外，其余所有节点都有两个子节点</li>
<li>即所有节点的度都为0或2</li>
</ul>
<pre><code class="highlight mermaid">flowchart TD
	1 --&gt; 2
	1 --&gt; 3
	2 --&gt; 4
	2 --&gt; 5
	5 --&gt; 10
	5 --&gt; 11
</code></pre>
<h5 id="4-平衡二叉树">4.平衡二叉树</h5>
<ul>
<li><strong>平衡二叉树</strong> （balanced binary tree）中<strong>任意节点</strong> 的<strong>左子树</strong> 和<strong>右子树</strong> 的<strong>高度之差</strong> 的绝对值不超过1。</li>
</ul>
<pre><code class="highlight mermaid">flowchart TD
	1 --&gt; 2
	1 --&gt; 3
	3 --&gt; 6
	2 --&gt; 4
	2 --&gt; 5
	5 --&gt; 10
	5 --&gt; 11</code></pre>
<h4 id="4-二叉树的退化">4.二叉树的退化</h4>
<ul>
<li>二叉树的理想结构就是满二叉树</li>
<li>当所有节点都偏向一侧时，二叉树就退化为链表</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 满二叉树
	1 --&gt; 2
	1 --&gt; 3
	3 --&gt; 6
	3 --&gt; 7
	2 --&gt; 4
	2 --&gt; 5
	end
	
	subgraph 链表
	1&#x27;[1] --&gt; 2&#x27;[2]
	2&#x27; --&gt; 3&#x27;[3]
	3&#x27; --&gt; 4&#x27;[4]
	4&#x27; --&gt; 5&#x27;[5]
	5&#x27; --&gt; 6&#x27;[6]
	6&#x27; --&gt; 7&#x27;[7]
	end
	
	满二叉树 --退化--&gt; 链表</code></pre>
<ul>
<li>
<p>在<strong>最佳结构</strong> 和<strong>最差结构</strong> 下，二叉树的叶节点数量、节点总数、高度等达到<strong>极大值</strong> 或<strong>极小值</strong></p>
</li>
<li>
<p>完美二叉树是理想情况，可以充分发挥二叉树<strong>分治</strong> 的优势。</p>
</li>
<li>
<p>链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 𝑂(𝑛)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>完美二叉树</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>第i层的节点数量</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td>1</td>
</tr>
<tr>
<td>高度为h的树的叶节点数量</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></td>
<td>1</td>
</tr>
<tr>
<td>高度为h的树的节点总数</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{h+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td>h+1</td>
</tr>
<tr>
<td>节点总数为n的树的高度</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\log_2(n+1)-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td>
<td>n-1</td>
</tr>
</tbody>
</table>
<h3 id="2-二叉树遍历">2.二叉树遍历</h3>
<ul>
<li>从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过<strong>指针</strong> 逐个访问节点。然而，树是一种<strong>非线性</strong> 数据结构，这使得遍历树比遍历链表更加复杂，需要借助<strong>搜索算法</strong> 来实现。二叉树常见的遍历方式包括<strong>层序遍历</strong> 、<strong>前序遍历</strong> 、<strong>中序遍历</strong> 和<strong>后序遍历</strong> 等</li>
</ul>
<h4 id="1-层序遍历">1.层序遍历</h4>
<ul>
<li>
<p><strong>层序遍历</strong> （level‑order traversal）<strong>从顶部到底部逐层</strong> 遍历二叉树，并在每一层按照<strong>从左到右</strong> 的顺序访问节点</p>
</li>
<li>
<p>层序遍历本质上属于<strong>广度优先</strong> 遍历（breadth‑first traversal），也称<strong>广度优先搜索</strong> （breadth‑first search,BFS）</p>
</li>
</ul>
<h5 id="1-代码实现">1.代码实现</h5>
<ul>
<li>借助队列来实现，队列的<strong>先进先出</strong> 和广度优先的<strong>逐层推进</strong> 是一致的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">levelOrder</span><span class="params">(TreeNode *root, <span class="type">int</span> *size)</span> &#123;</span><br><span class="line">    <span class="comment">/* 辅助队列 */</span></span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="type">int</span> index, *arr;</span><br><span class="line">    TreeNode *node;</span><br><span class="line">    TreeNode **<span class="built_in">queue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 辅助队列 */</span></span><br><span class="line">    <span class="built_in">queue</span> = (TreeNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode *) * MAX_SIZE);</span><br><span class="line">    <span class="comment">// 队列指针</span></span><br><span class="line">    front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 加入根节点</span></span><br><span class="line">    <span class="built_in">queue</span>[rear++] = root;</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    <span class="comment">/* 辅助数组 */</span></span><br><span class="line">    arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * MAX_SIZE);</span><br><span class="line">    <span class="comment">// 数组指针</span></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">        <span class="comment">// 队列出队</span></span><br><span class="line">        node = <span class="built_in">queue</span>[front++];</span><br><span class="line">        <span class="comment">// 保存节点值</span></span><br><span class="line">        arr[index++] = node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 左子节点入队</span></span><br><span class="line">            <span class="built_in">queue</span>[rear++] = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 右子节点入队</span></span><br><span class="line">            <span class="built_in">queue</span>[rear++] = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新数组长度的值</span></span><br><span class="line">    *size = index;</span><br><span class="line">    arr = <span class="built_in">realloc</span>(arr, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (*size));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放辅助数组空间</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-复杂度分析-2">2.复杂度分析</h5>
<ul>
<li><strong>时间复杂度为</strong>  𝑂(𝑛) ：所有节点被访问一次，使用 𝑂(𝑛) 时间，其中 𝑛 为节点数量。</li>
<li><strong>空间复杂度为</strong>  𝑂(𝑛) ：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在(𝑛 + 1)/2 个节点，占用 𝑂(𝑛) 空间。</li>
</ul>
<h4 id="2-前序，中序，后序遍历">2.前序，中序，后序遍历</h4>
<ul>
<li>
<p><strong>前序、中序和后序遍历</strong> 都属于<strong>深度优先</strong> 遍历（depth‑first traversal），也称<strong>深度优先</strong> 搜索（depth‑first search, DFS）</p>
</li>
<li>
<p>规定D，L，R分别代表根节点，左子树，右子树</p>
<ul>
<li>DLR–前序遍历（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）
<ul>
<li>1（D）-[2（4，5的D）-4（2的L）-5（2的R）]（L）-[3（6，7的D）-6（3的L）-7（3的R）]（R）</li>
</ul>
</li>
<li>LDR–中序遍历（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）
<ul>
<li>[4（2的L）-2（4，5的D）-5（2的R）]（L）-1（D）-[6（3的L）-3（6，7的D）-7（3的R）]（R）</li>
</ul>
</li>
<li>LRD–后序遍历（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）
<ul>
<li>[4（2的L）-5（2的R）-2（4，5的D）]（L）-[6（3的L）-7（3的R）-3（6，7的D）]（R）-1（D）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p># 每个根都是相对的</p>
<pre><code class="highlight mermaid">flowchart TB
	subgraph D
	1
	end
	1 --&gt; L
	1 --&gt; R
	subgraph R
	direction TB
	3 --&gt; L&#x27;&#x27;
	3 --&gt; R&#x27;&#x27;
	subgraph D&#x27;[D]
	3
	end
	subgraph L&#x27;&#x27;[L]
	6
	end
	subgraph R&#x27;&#x27;[R]
	7
	end
	end
	subgraph L
	direction TB
	2 --&gt; L&#x27;
	2 --&gt; R&#x27;
	subgraph D&#x27;&#x27;[D]
	2
	end
	subgraph L&#x27;[L]
	4
	end
	subgraph R&#x27;[R]
	5
	end
	end</code></pre>
<h5 id="1-代码实现-2">1.代码实现</h5>
<ul>
<li><strong>深度优先</strong> 搜索通常基于<strong>递归</strong> 实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode *root, <span class="type">int</span> *size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    arr[(*size)++] = root-&gt;val;</span><br><span class="line">    preOrder(root-&gt;left, size);</span><br><span class="line">    preOrder(root-&gt;right, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode *root, <span class="type">int</span> *size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    inOrder(root-&gt;left, size);</span><br><span class="line">    arr[(*size)++] = root-&gt;val;</span><br><span class="line">    inOrder(root-&gt;right, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode *root, <span class="type">int</span> *size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    postOrder(root-&gt;left, size);</span><br><span class="line">    postOrder(root-&gt;right, size);</span><br><span class="line">    arr[(*size)++] = root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 也可以基于迭代来实现</p>
<ul>
<li>可以分为两个部分
<ul>
<li><strong>递</strong> 表示开启新方法，程序在此过程中访问下一个节点。</li>
<li><strong>归</strong> 表示函数返回，代表当前节点已经访问完毕</li>
</ul>
</li>
</ul>
<p># 以前序遍历为例</p>
<p>1（递）-2（递）-4（递）-[2（归）]-5（递）-[2（归）]-[1（归）]-3（递）-6（递）-[3（归）]-7（递）-[3（归）]-[1（归）]</p>
<h5 id="2-复杂度分析-3">2.复杂度分析</h5>
<ul>
<li><strong>时间复杂度为</strong> 𝑂(𝑛) ：所有节点被访问一次，使用 𝑂(𝑛) 时间。</li>
<li><strong>空间复杂度为</strong> 𝑂(𝑛) ：在最差情况下，即树退化为链表时，递归深度达到 𝑛 ，系统占用 𝑂(𝑛) 栈帧空间。</li>
</ul>
<h3 id="3-二叉树数组表示">3.二叉树数组表示</h3>
<h4 id="1-表示完美二叉树">1.表示完美二叉树</h4>
<ul>
<li>按照层序遍历的顺序作为索引，即从每一层从左到右</li>
<li>根据层序遍历的特性，可以推导出<strong>父节点索引</strong> 与<strong>子节点索引</strong> 之间的<strong>映射公式</strong> ：若某节点的索引为𝑖 ，则该节点的左子节点索引为2𝑖 + 1，右子节点索引为2𝑖 + 2 。
<ul>
<li>这个公式就相当于是链表里的指针，给定节点索引就可以访问其左右子节点</li>
</ul>
</li>
</ul>
<h4 id="2-表示任意二叉树">2.表示任意二叉树</h4>
<ul>
<li>一般的二叉树中会有许多none，所以在写数组的时候就把none的地方直接标记出来</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 int 最大值标记空位，因此要求节点值不能为 INT_MAX</span></span><br><span class="line"><span class="type">int</span> tree[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, INT_MAX, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, INT_MAX, INT_MAX, <span class="number">12</span>, INT_MAX, INT_MAX, <span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure>
<p># <strong>完全二叉树</strong> 非常适合使用数组来表示。None 只出现在最底层且靠右的位置，因此所有 <strong>None</strong> <strong>一定出现在层序遍历序列的末尾</strong> ，可以省略存储所有 None</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数组表示下的二叉树结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *tree;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; ArrayBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">ArrayBinaryTree *<span class="title function_">newArrayBinaryTree</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize)</span> &#123;</span><br><span class="line">    ArrayBinaryTree *abt = (ArrayBinaryTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayBinaryTree));</span><br><span class="line">    abt-&gt;tree = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * arrSize);</span><br><span class="line">    <span class="built_in">memcpy</span>(abt-&gt;tree, arr, <span class="keyword">sizeof</span>(<span class="type">int</span>) * arrSize);</span><br><span class="line">    abt-&gt;size = arrSize;</span><br><span class="line">    <span class="keyword">return</span> abt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delArrayBinaryTree</span><span class="params">(ArrayBinaryTree *abt)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(abt-&gt;tree);</span><br><span class="line">    <span class="built_in">free</span>(abt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 列表容量 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">(ArrayBinaryTree *abt)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> abt-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取索引为 i 节点的值 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">val</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 若索引越界，则返回 INT_MAX ，代表空位</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size(abt))</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">return</span> abt-&gt;tree[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">levelOrder</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> *returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size(abt));</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 直接遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size(abt); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val(abt, i) != INT_MAX)</span><br><span class="line">            res[index++] = val(abt, i);</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = index;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> i, <span class="type">char</span> *order, <span class="type">int</span> *res, <span class="type">int</span> *index)</span> &#123;</span><br><span class="line">    <span class="comment">// 若为空位，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (val(abt, i) == INT_MAX)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(order, <span class="string">&quot;pre&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        res[(*index)++] = val(abt, i);</span><br><span class="line">    dfs(abt, left(i), order, res, index);</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(order, <span class="string">&quot;in&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        res[(*index)++] = val(abt, i);</span><br><span class="line">    dfs(abt, right(i), order, res, index);</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(order, <span class="string">&quot;post&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        res[(*index)++] = val(abt, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">preOrder</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> *returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size(abt));</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    dfs(abt, <span class="number">0</span>, <span class="string">&quot;pre&quot;</span>, res, &amp;index);</span><br><span class="line">    *returnSize = index;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">inOrder</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> *returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size(abt));</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    dfs(abt, <span class="number">0</span>, <span class="string">&quot;in&quot;</span>, res, &amp;index);</span><br><span class="line">    *returnSize = index;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">postOrder</span><span class="params">(ArrayBinaryTree *abt, <span class="type">int</span> *returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size(abt));</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    dfs(abt, <span class="number">0</span>, <span class="string">&quot;post&quot;</span>, res, &amp;index);</span><br><span class="line">    *returnSize = index;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>可以实现</p>
<ul>
<li>
<p>给定某节点，获取它的值、左（右）子节点、父节点。</p>
</li>
<li>
<p>获取前序遍历、中序遍历、后序遍历、层序遍历序列</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-优点与局限性">3.优点与局限性</h4>
<ul>
<li>优点
<ul>
<li>数组存储在<strong>连续的内存空间</strong> 中，<strong>对缓存友好</strong> ，访问与遍历<strong>速度较快</strong> 。</li>
<li><strong>不需要存储指针</strong> ，比较<strong>节省空间</strong> 。</li>
<li><strong>允许随机访问节点</strong> 。</li>
</ul>
</li>
<li>局限性
<ul>
<li>数组存储<strong>需要连续内存空间</strong> ，因此<strong>不适合存储数据量过大</strong> 的树。</li>
<li><strong>增删节点</strong> 需要通过数组插入与删除操作实现，<strong>效率较低</strong> 。</li>
<li>当二叉树中<strong>存在大量 None 时</strong> ，数组中包含的<strong>节点数据比重较低</strong> ，<strong>空间利用率较低</strong> 。</li>
</ul>
</li>
</ul>
<h3 id="4-二叉搜索树">4.二叉搜索树</h3>
<ul>
<li><strong>二叉搜索树</strong> （binary search tree）满足以下条件
<ul>
<li>对于根节点，<strong>左子树</strong> 中<strong>所有节点的值</strong> &lt; <strong>根节点的值</strong> &lt; <strong>右子树</strong> 中<strong>所有节点的值</strong> 。</li>
<li><strong>任意节点</strong> 的<strong>左、右子树也是二叉搜索树</strong> ，即同样满足上一个条件 。</li>
</ul>
</li>
</ul>
<h4 id="1-二叉搜索树的操作">1.二叉搜索树的操作</h4>
<ul>
<li>将二叉搜索树封装为一个类 BinarySearchTree ，并声明一个成员变量 root ，指向树的根节点</li>
</ul>
<h5 id="1-查找操作">1.查找操作</h5>
<ul>
<li>给定目标节点值 num ，可以根据二叉搜索树的性质来查找。声明一个节点 cur ，从二叉树的根节点 root 出发，循环比较节点值 cur.val 和 num 之间的大小关系。
<ul>
<li>若 <strong>cur.val &lt; num</strong> ，说明目标节点在 cur 的<strong>右子树</strong> 中，因此<strong>执行 cur = cur.right</strong> 。</li>
<li>若 <strong>cur.val &gt; num</strong> ，说明目标节点在 cur 的<strong>左子树</strong> 中，因此<strong>执行 cur = cur.left</strong> 。</li>
<li>若 <strong>cur.val = num</strong> ，说明<strong>找到目标节点</strong> ，跳出循环并返回该节点。</li>
</ul>
</li>
<li>二叉搜索树的查找操作与<strong>二分查找算法</strong> 的工作原理一致，都是<strong>每轮排除一半</strong> 情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用 𝑂(log 𝑛) 时间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查找节点 */</span></span><br><span class="line">TreeNode *<span class="title function_">search</span><span class="params">(BinarySearchTree *bst, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    TreeNode *cur = bst-&gt;root;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num) &#123;</span><br><span class="line">            <span class="comment">// 目标节点在 cur 的右子树中</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;val &gt; num) &#123;</span><br><span class="line">            <span class="comment">// 目标节点在 cur 的左子树中</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到目标节点，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目标节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-插入节点-2">2.插入节点</h5>
<ul>
<li>
<p>插入元素时需要保证二叉搜索树<strong>左子树 &lt; 根节点 &lt; 右子树</strong> 的性质，流程如下</p>
<ul>
<li>
<p><strong>查找插入位置</strong> ：<strong>与查找操作相似</strong> ，从根节点出发，根据当前节点值和 num 的大小关系循环向下搜索，直到越过叶节点（<strong>遍历至 None</strong> ）时跳出循环。</p>
</li>
<li>
<p><strong>在该位置插入节点</strong> ：初始化节点 num ，将该节点置于 None 的位置。</p>
</li>
</ul>
<p># 因此与查找节点相同，插入节点使用 𝑂(log 𝑛) 时间</p>
</li>
<li>
<p>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若<strong>待插入节点在树中已存在</strong> ，则<strong>不执行插入</strong> ，直接返回。</p>
</li>
<li>
<p>为了实现插入节点，我们需要借助节点 pre <strong>保存上一轮循环的节点</strong> 。这样在遍历至 None 时，我们<strong>可以获取到其父节点</strong> ，从而完成节点插入操作。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BinarySearchTree *bst, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 若树为空，则初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> (bst-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bst-&gt;root = newTreeNode(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *cur = bst-&gt;root, *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到重复节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == num) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num) &#123;</span><br><span class="line">            <span class="comment">// 插入位置在 cur 的右子树中</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入位置在 cur 的左子树中</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    TreeNode *node = newTreeNode(num);</span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;val &lt; num) &#123;</span><br><span class="line">        pre-&gt;right = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pre-&gt;left = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 插入后二叉树
	subgraph A[在None的位置插入节点执行pre.right = 8]
	direction TB
	4&#x27;[4] --&gt; 2&#x27;[2]
	4&#x27; --&gt; 6&#x27;[6]
	6&#x27; --&gt; 5&#x27;[5]
	6&#x27; --&gt; 7&#x27;[7]
	2&#x27; --&gt; 1&#x27;[1]
	2&#x27; --&gt; 3&#x27;[3]
	3&#x27; --&gt; 8&#x27;[8]
	end
	end

	subgraph 原二叉树
	subgraph 查找节点插入位置
	direction TB
	4 --&gt; 2
	4 --&gt; 6
	6 --&gt; 5
	6 --&gt; 7
	2 --&gt; 1
	2 --&gt; 3
	7 --&gt; None
	end
	end
	
	原二叉树 --插入节点8--&gt; 插入后二叉树</code></pre>
<h5 id="3-删除节点-2">3.删除节点</h5>
<ul>
<li>
<p>首先查找相应节点，为了保证删除后仍满足<strong>左子树 &lt; 根节点 &lt; 右子树</strong> 的性质，将要删除的节点的位置分为三种</p>
<ul>
<li>度为0，即叶节点，直接删除</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 删除后二叉树
	subgraph A[直接删除cur即可，执行pre.left = None]
	direction TB
	4&#x27;[4] --&gt; 2&#x27;[2]
	4&#x27; --&gt; 6&#x27;[6]
	2&#x27; --&gt; 3&#x27;[3]
	6&#x27; --&gt; 5&#x27;[5]
	6&#x27; --&gt; 7&#x27;[7]
	end
	end

	subgraph 原二叉树
	subgraph 查找要删除元素的位置
	direction TB
	4 --&gt; 2
	4 --&gt; 6
	6 --&gt; 5
	6 --&gt; 7
	2 --&gt; 1[&quot;1
	(节点cur，子节点的个数为0)&quot;]
	2 --&gt; 3
	end
	end
	
	原二叉树 --删除节点1--&gt; 删除后二叉树</code></pre>
<ul>
<li>度为1，将要删除的节点换位其子节点即可</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 删除后二叉树
	subgraph A[将删除节点替换为其子节点，执行pre.left = pre.right]
	direction TB
	4&#x27;[4] --&gt; 3&#x27;[3]
	4&#x27; --&gt; 6&#x27;[6]
	6&#x27; --&gt; 5&#x27;[5]
	6&#x27; --&gt; 7&#x27;[7]
	end
	end

	subgraph 原二叉树
	subgraph 查找要删除元素的位置
	direction TB
	4 --&gt; 2
	4 --&gt; 6
	6 --&gt; 5
	6 --&gt; 7
	2 --&gt; 3[&quot;3
	(节点cur，子节点的个数为1)&quot;]
	end
	end
	
	原二叉树 --删除节点3--&gt; 删除后二叉树</code></pre>
<ul>
<li>
<p>度为2，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树<strong>左子树 &lt; 根节点 &lt; 右子树</strong> 的性质，因此这个节点可以是<strong>右子树的最小节点（中序遍历该删除节点的下一个节点）或左子树的最大节点（中序遍历该删除节点的上一个节点）</strong> 。</p>
<ul>
<li>先用中序遍历找到要删除节点的下一个（右子树的最小节点）或上一个（左子树的最大节点），记为tmp</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR

	subgraph 查找中序遍历的后继节点nex
	8&#x27;[8] --&gt; 4&#x27;[&quot;4
	(节点cur，子节点的个数为2)&quot;]
	8&#x27; --&gt; 12&#x27;[12]
	4&#x27; --&gt; 3&#x27;[3]
	4&#x27; --&gt; 6&#x27;[6]
	6&#x27; --&gt; 5&#x27;[&quot;5
	(cur在中序遍历中的后继节点nex)&quot;]
	6&#x27; --&gt; 7&#x27;[7]
	12&#x27; --&gt; 10&#x27;[10]
	12&#x27; --&gt; 14&#x27;[14]
	10&#x27; --&gt; 9&#x27;[9]
	10&#x27; --&gt; 11&#x27;[11]
	14&#x27; --&gt; 13&#x27;[13]
	14&#x27; --&gt; 15&#x27;[15]
	end
	
	subgraph 原二叉树
	8 --&gt; 4[&quot;4
	(节点cur，子节点的个数为2)&quot;]
	8 --&gt; 12
	4 --&gt; 3
	4 --&gt; 6
	6 --&gt; 7
	6 --&gt; 5
	12 --&gt; 10
	12 --&gt; 14
	10 --&gt; 9
	10 --&gt; 11
	14 --&gt; 13
	14 --&gt; 15
	end
	

	原二叉树 --&gt; 查找中序遍历的后继节点nex</code></pre>
<ul>
<li>删除tmp，然后将要删除的节点替换为tmp</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 将节点nex的值赋给cur
	8&#x27;&#x27;&#x27;[8] --&gt; 5&#x27;&#x27;&#x27;[5]
	8&#x27;&#x27;&#x27; --&gt; 12&#x27;&#x27;&#x27;[12]
	5&#x27;&#x27;&#x27; --&gt; 3&#x27;&#x27;&#x27;[3]
	5&#x27;&#x27;&#x27; --&gt; 6&#x27;&#x27;&#x27;
	6&#x27;&#x27;&#x27;[6] --&gt; 7&#x27;&#x27;&#x27;[7]
	12&#x27;&#x27;&#x27; --&gt; 10&#x27;&#x27;&#x27;[10]
	12&#x27;&#x27;&#x27; --&gt; 14&#x27;&#x27;&#x27;[14]
	10&#x27;&#x27;&#x27; --&gt; 9&#x27;&#x27;&#x27;[9]
	10&#x27;&#x27;&#x27; --&gt; 11&#x27;&#x27;&#x27;[11]
	14&#x27;&#x27;&#x27; --&gt; 13&#x27;&#x27;&#x27;[13]
	14&#x27;&#x27;&#x27; --&gt; 15&#x27;&#x27;&#x27;[15]
	end

	subgraph 删除nex
	8&#x27;&#x27;[8] --&gt; 4&#x27;&#x27;[&quot;4
	(节点cur，子节点的个数为2)&quot;]
	8&#x27;&#x27; --&gt; 12&#x27;&#x27;[12]
	4&#x27;&#x27; --&gt; 3&#x27;&#x27;[3]
	4&#x27;&#x27; --&gt; 6&#x27;&#x27;[6]
	6&#x27;&#x27; --&gt; 7&#x27;&#x27;[7]
	12&#x27;&#x27; --&gt; 10&#x27;&#x27;[10]
	12&#x27;&#x27; --&gt; 14&#x27;&#x27;[14]
	10&#x27;&#x27; --&gt; 9&#x27;&#x27;[9]
	10&#x27;&#x27; --&gt; 11&#x27;&#x27;[11]
	14&#x27;&#x27; --&gt; 13&#x27;&#x27;[13]
	14&#x27;&#x27; --&gt; 15&#x27;&#x27;[15]
	end
	
	删除nex --&gt; 将节点nex的值赋给cur</code></pre>
</li>
</ul>
<p># 因为与查找类似，所以删除节点操作同样使用 𝑂(log 𝑛) 时间，其中查找待删除节点需要 𝑂(log 𝑛) 时间，获取中序遍历后继节点需要 𝑂(log 𝑛) 时间</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="comment">// 由于引入了 stdio.h ，此处无法使用 remove 关键词</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeItem</span><span class="params">(BinarySearchTree *bst, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> (bst-&gt;root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TreeNode *cur = bst-&gt;root, *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到待删除节点，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num) &#123;</span><br><span class="line">            <span class="comment">// 待删除节点在 root 的右子树中</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 待删除节点在 root 的左子树中</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若无待删除节点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 判断待删除节点是否存在子节点</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> || cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* 子节点数量 = 0 or 1 */</span></span><br><span class="line">        <span class="comment">// 当子节点数量 = 0 / 1 时， child = nullptr / 该子节点</span></span><br><span class="line">        TreeNode *child = cur-&gt;left != <span class="literal">NULL</span> ? cur-&gt;left : cur-&gt;right;</span><br><span class="line">        <span class="comment">// 删除节点 cur</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;left == cur) &#123;</span><br><span class="line">            pre-&gt;left = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre-&gt;right = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 子节点数量 = 2 */</span></span><br><span class="line">        <span class="comment">// 获取中序遍历中 cur 的下一个节点</span></span><br><span class="line">        TreeNode *tmp = cur-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmpVal = tmp-&gt;val;</span><br><span class="line">        <span class="comment">// 递归删除节点 tmp</span></span><br><span class="line">        removeItem(bst, tmp-&gt;val);</span><br><span class="line">        <span class="comment">// 用 tmp 覆盖 cur</span></span><br><span class="line">        cur-&gt;val = tmpVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-中序遍历有序">4.中序遍历有序</h5>
<ul>
<li>中序遍历遵循<strong>LDR</strong> ，且二叉搜索树满足<strong>左子节点&lt;根节点&lt;右子节点</strong></li>
<li>所以二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：</li>
<li><strong>二叉搜索树的中序遍历序列是升序的</strong> 。</li>
<li>利用中序遍历升序的性质，在二叉搜索树中获取有序数据仅需 𝑂(𝑛) 时间，无须进行额外的排序操作</li>
</ul>
<h4 id="2-二叉搜索树的效率">2.二叉搜索树的效率</h4>
<table>
<thead>
<tr>
<th></th>
<th>无序数组</th>
<th>二叉搜索树</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(log 𝑛)</td>
</tr>
<tr>
<td>插入元素</td>
<td>𝑂(1)</td>
<td>𝑂(log 𝑛)</td>
</tr>
<tr>
<td>删除元素</td>
<td>𝑂(𝑛)</td>
<td>𝑂(log 𝑛)</td>
</tr>
</tbody>
</table>
<ul>
<li>二叉搜索树的各项操作的时间复杂度都是对数阶，具有<strong>稳定</strong> 且<strong>高效</strong> 的性能。</li>
<li>只有在<strong>高频添加</strong> 、<strong>低频查找删除数据</strong> 的场景下，数组比二叉搜索树的效率更高。</li>
</ul>
<p># 理想状态下的二叉树是平衡的，此时可以在 log 𝑛 轮循环内查找任意节点</p>
<p># 但在使用后可能会退化为链表，此时各操作的时间复杂度也会退化为 𝑂(𝑛) 。</p>
<h4 id="3-二叉搜索树常见应用">3.二叉搜索树常见应用</h4>
<ul>
<li>用作系统中的多级索引，实现高效的查找、插入、删除操作。</li>
<li>作为某些搜索算法的底层数据结构。</li>
<li>用于存储数据流，以保持其有序状态。</li>
</ul>
<h3 id="5-AVL树">5.AVL树</h3>
<ul>
<li>二叉搜索树在多次删除和插入后都会严重退化</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR

	subgraph 链表
	4&#x27;&#x27;[4] --&gt; 2&#x27;&#x27;[2]
	2&#x27;&#x27; --&gt; 1&#x27;&#x27;[1]
	end
	
	subgraph 普通二叉树
	4&#x27;[4] --&gt; 2&#x27;[2]
	2&#x27; --&gt; 1&#x27;[1]
	2&#x27; --&gt; 3&#x27;[3]
	end
	
	subgraph 平衡二叉树
	4[4] --&gt; 2[2]
	4 --&gt; 5[5]
	2 --&gt; 1[1]
	2 --&gt; 3[3]
	end
	
	平衡二叉树 --删除节点5--&gt; 普通二叉树
	普通二叉树 --删除节点3--&gt; 链表
</code></pre>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 普通二叉树
	4&#x27;&#x27;[4] --&gt; 3&#x27;&#x27;[3]
	4&#x27;&#x27; --&gt; 5&#x27;&#x27;[5]
	3&#x27;&#x27; --&gt; 2&#x27;&#x27;[2]
	2&#x27;&#x27; --&gt; 1&#x27;&#x27;[1]
	end


	subgraph 平衡二叉树
	4&#x27;[4] --&gt; 3&#x27;[3]
	4&#x27; --&gt; 5&#x27;[5]
	3&#x27; --&gt; 2&#x27;[2]
	end
	

	subgraph 完美二叉树
	4[4] --&gt; 3[3]
	4 --&gt; 5[5]
	end
	
	完美二叉树 --插入节点2--&gt; 平衡二叉树
	平衡二叉树 --插入节点1--&gt; 普通二叉树</code></pre>
<ul>
<li>1962 年 G. M. Adelson‑Velsky 和 E. M. Landis 在 论 文 “An algorithm for the organization of information”中提出了 <strong>AVL 树</strong> 。论文中详细描述了一系列操作，确保<strong>在持续添加和删除节点后</strong> ，AVL 树不会退化，从而使得各种操作的<strong>时间复杂度保持在 𝑂(log 𝑛) 级别</strong> 。</li>
</ul>
<h4 id="1-AVL树常见术语">1.AVL树常见术语</h4>
<ul>
<li>AVL 树既是二叉搜索树，也是平衡二叉树，同时满足这两类二叉树的所有性质，因此是一种<strong>平衡二叉搜索树</strong> （balanced binary search tree）</li>
</ul>
<h5 id="1-节点高度">1.节点高度</h5>
<ul>
<li>由于 AVL 树的相关操作需要获取节点高度，因此需要为节点类添加 height 变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AVL 树节点结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数 */</span></span><br><span class="line">TreeNode *<span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode *node;</span><br><span class="line">    </span><br><span class="line">    node = (TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;height = <span class="number">0</span>;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>节点高度：该节点到它的最远叶节点的距离，即所经过的<strong>边</strong> 的数量</li>
</ul>
<p># 叶节点的高度为0</p>
<p># 空节点的高度为-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取节点高度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 空节点高度为 -1 ，叶节点高度为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新节点高度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateHeight</span><span class="params">(TreeNode *node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> lh = height(node-&gt;left);</span><br><span class="line">    <span class="type">int</span> rh = height(node-&gt;right);</span><br><span class="line">    <span class="comment">// 节点高度等于最高子树高度 + 1</span></span><br><span class="line">    <span class="keyword">if</span> (lh &gt; rh) &#123;</span><br><span class="line">        node-&gt;height = lh + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;height = rh + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-节点平衡因子">2.节点平衡因子</h5>
<ul>
<li>节点的<strong>平衡因子</strong> （balance factor）：节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为 0 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取平衡因子 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">balanceFactor</span><span class="params">(TreeNode *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 空节点平衡因子为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> height(node-&gt;left) - height(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 设平衡因子为 𝑓 ，则一棵 AVL 树的任意节点的平衡因子皆满足 −1 ≤ 𝑓 ≤ 1 。</p>
<h4 id="2-AVL树旋转">2.AVL树旋转</h4>
<ul>
<li>
<p>AVL 树的特点在于<strong>旋转</strong> 操作，它能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，<strong>旋转操作既能保持二叉搜索树的性质，也能使树重新变为平衡二叉树</strong></p>
</li>
<li>
<p>将平衡因子绝对值 &gt; 1 的节点称为<strong>失衡节点</strong> 。根据节点失衡情况的不同，旋转操作分为四种：</p>
<ul>
<li>右旋</li>
<li>左旋</li>
<li>先右旋后左旋</li>
<li>先左旋后右旋。</li>
</ul>
</li>
</ul>
<h5 id="1-右旋">1.右旋</h5>
<pre><code class="highlight mermaid">flowchart LR
	subgraph B[将该节点记为node，其左节点记为child]
	4&#x27;[4] --&gt; 3&#x27;[&quot;3
	(node)&quot;]
	4&#x27; --&gt; 5&#x27;[5]
	3&#x27; --&gt; 1&#x27;[&quot;1
	(child)&quot;]
	1&#x27; --&gt; 0&#x27;[0]
	end

	subgraph A[失衡的树]
	4[4] --&gt; 3[3]
	4 --&gt; 5[5]
	3 --&gt; 1[1]
	1 --&gt; 0[0]
	end
	
	A --关注失衡节点为根节点的子树--&gt; B</code></pre>
<pre><code class="highlight mermaid">flowchart LR
	subgraph B[恢复平衡]
	4&#x27; --&gt; 1&#x27;
	1&#x27;[1] --&gt; 3&#x27;[3]
	1&#x27; --&gt; 0&#x27;[0]
	4&#x27;[4] --&gt; 5&#x27;[5]
	end


	subgraph A[将失衡节点以child为原点右旋]
	4[4] --&gt; 5[5]
	1[1] --&gt; 3
	1 --&gt; 0[0]
	end
	
	A --用child代替原来node的位置--&gt; B</code></pre>
<ul>
<li><strong>向右旋转</strong> 是一种形象化的说法，实际上需要通过<strong>修改节点指针</strong> 来实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line">TreeNode *<span class="title function_">rightRotate</span><span class="params">(TreeNode *node)</span> &#123;</span><br><span class="line">    TreeNode *child, *grandChild;</span><br><span class="line">    child = node-&gt;left;</span><br><span class="line">    grandChild = child-&gt;right;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    updateHeight(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-左旋">2.左旋</h5>
<ul>
<li>与右旋类似</li>
<li>在逻辑上和右旋是镜像对称的，它们分别解决的两种失衡情况也是对称的</li>
<li>所以只要把上述右旋代码中的left替换为right，right替换为left即可</li>
</ul>
<h5 id="3-先左旋后右旋">3.先左旋后右旋</h5>
<pre><code class="highlight mermaid">flowchart LR
	subgraph 原失衡树
	4[4] --&gt; 3[&quot;3
	(失衡节点)&quot;]
	4 --&gt; 5[5]
	3 --&gt; 1[1]
	1 --&gt; 2[2]
	end
	subgraph 先左旋
	4&#x27;[4] --&gt; 3&#x27;[3]
	4&#x27; --&gt; 5&#x27;[5]
	3&#x27; --&gt; 1&#x27;[1]
	1&#x27; --&gt; 2&#x27;[2]
	end	
	subgraph 再右旋
	4&#x27;&#x27;[4] --&gt; 3&#x27;&#x27;[3]
	4&#x27;&#x27; --&gt; 5&#x27;&#x27;[5]
	3&#x27;&#x27; --&gt; 1&#x27;&#x27;[1]
	1&#x27;&#x27; --&gt; 2&#x27;&#x27;[2]
	end	
	原失衡树 --&gt; 先左旋 --&gt; 再右旋</code></pre>
<h5 id="4-先右旋后左旋">4.先右旋后左旋</h5>
<ul>
<li>和上述同理</li>
</ul>
<h5 id="5-旋转的选择">5.旋转的选择</h5>
<ul>
<li>根据失衡节点的平衡因子已经较高一侧的平衡因子的正负号来确定</li>
</ul>
<table>
<thead>
<tr>
<th>失衡节点的平衡因子</th>
<th>子节点的平衡因子</th>
<th>应采用的旋转方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;1（左偏树）</td>
<td>$\geq$0</td>
<td>右旋</td>
</tr>
<tr>
<td>&gt;1（左偏树）</td>
<td>&lt;0</td>
<td>先左旋后右旋</td>
</tr>
<tr>
<td>&lt;-1（右偏树）</td>
<td>$\leq$0</td>
<td>左旋</td>
</tr>
<tr>
<td>&lt;-1（右偏树）</td>
<td>&gt;0</td>
<td>先右旋后左旋</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">TreeNode *<span class="title function_">rotate</span><span class="params">(TreeNode *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取节点 node 的平衡因子</span></span><br><span class="line">    <span class="type">int</span> bf = balanceFactor(node);</span><br><span class="line">    <span class="comment">// 左偏树</span></span><br><span class="line">    <span class="keyword">if</span> (bf &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor(node-&gt;left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 右旋</span></span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先左旋后右旋</span></span><br><span class="line">            node-&gt;left = leftRotate(node-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右偏树</span></span><br><span class="line">    <span class="keyword">if</span> (bf &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor(node-&gt;right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左旋</span></span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先右旋后左旋</span></span><br><span class="line">            node-&gt;right = rightRotate(node-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平衡树，无须旋转，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># 这个函数就可以应对各种失衡情况</p>
<h4 id="3-AVL树常见操作">3.AVL树常见操作</h4>
<h5 id="1-插入节点">1.插入节点</h5>
<ul>
<li>与二叉搜索树类似，但是在插入后可能会导致失衡，所以需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(AVLTree *tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    tree-&gt;root = insertHelper(tree-&gt;root, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 递归插入节点（辅助函数） */</span></span><br><span class="line">TreeNode *<span class="title function_">insertHelper</span><span class="params">(TreeNode *node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newTreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 1. 查找插入位置并插入节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node-&gt;val) &#123;</span><br><span class="line">        node-&gt;left = insertHelper(node-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val) &#123;</span><br><span class="line">        node-&gt;right = insertHelper(node-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 重复节点不插入，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = rotate(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-删除节点">2.删除节点</h5>
<ul>
<li>在二叉搜索树的基础上，需要从底部至顶部执行旋转操作，使所有失衡节点恢复平衡</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="comment">// 由于引入了 stdio.h ，此处无法使用 remove 关键词</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeItem</span><span class="params">(AVLTree *tree, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode *root = removeHelper(tree-&gt;root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归删除节点（辅助函数） */</span></span><br><span class="line">TreeNode *<span class="title function_">removeHelper</span><span class="params">(TreeNode *node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode *child, *grandChild;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 1. 查找节点并删除 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node-&gt;val) &#123;</span><br><span class="line">        node-&gt;left = removeHelper(node-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val) &#123;</span><br><span class="line">        node-&gt;right = removeHelper(node-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> || node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            child = node-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                child = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点数量 = 0 ，直接删除 node 并返回</span></span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 子节点数量 = 1 ，直接删除 node</span></span><br><span class="line">                node = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点</span></span><br><span class="line">            TreeNode *temp = node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (temp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> tempVal = temp-&gt;val;</span><br><span class="line">            node-&gt;right = removeHelper(node-&gt;right, temp-&gt;val);</span><br><span class="line">            node-&gt;val = tempVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = rotate(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-查找节点">3.查找节点</h5>
<ul>
<li>与二叉搜索树相同</li>
</ul>
<h4 id="4-AVL树典型应用">4.AVL树典型应用</h4>
<ul>
<li>组织和存储大型数据，适用于<strong>高频查找、低频增删</strong> 的场景。</li>
<li>用于构建数据库中的<strong>索引系统</strong> 。</li>
<li><strong>红黑树</strong> 也是一种常见的平衡二叉搜索树。相较于 AVL 树，红黑树的平衡条件更宽松，插入与删除节点所需的旋转操作更少，节点增删操作的平均效率更高。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">余</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951-7/">http://example.com/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951-7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">不做花看</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%958/" title="数据结构与算法8"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据结构与算法8</div></div><div class="info-2"><div class="info-item-1">本文系统介绍堆数据结构，包括定义、存储与基本操作，详细分析入堆、出堆的堆化过程，阐述两种建堆方法及其时间复杂度，最后探讨堆在Top-k问题中的高效应用。全文结合代码与图示，兼顾理论与实践。</div></div></div></a><a class="pagination-related" href="/2025/10/07/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java基础</div></div><div class="info-2"><div class="info-item-1">本文系统梳理了Java核心基础，包括基本语法、程序结构（判断、循环、数组）、方法以及面向对象三大特性（封装、继承、多态），并介绍了字符串、集合等常用工具类。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%958/" title="数据结构与算法8"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-11</div><div class="info-item-2">数据结构与算法8</div></div><div class="info-2"><div class="info-item-1">本文系统介绍堆数据结构，包括定义、存储与基本操作，详细分析入堆、出堆的堆化过程，阐述两种建堆方法及其时间复杂度，最后探讨堆在Top-k问题中的高效应用。全文结合代码与图示，兼顾理论与实践。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">余</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lucime470"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.算法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.与数据结构的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">2.复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E8%AF%84%E4%BC%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.算法效率评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.算法设计目标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%89%BE%E5%88%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E6%B3%95"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">1.找到问题解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%BB%E6%B1%82%E6%9C%80%E4%BC%98%E8%A7%A3%E6%B3%95"><span class="toc-number">1.2.1.1.2.</span> <span class="toc-text">2.寻求最优解法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.算法评估指标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">1.时间效率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">2.空间效率</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%88%E7%8E%87%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3.效率评估方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9E%E9%99%85%E6%B5%8B%E8%AF%95"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">1.实际测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%90%86%E8%AE%BA%E4%BC%B0%E8%AE%A1"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">2.理论估计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%AD%E4%BB%A3%E4%B8%8E%E9%80%92%E5%BD%92"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.迭代与递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1.迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">1.for循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">2.while循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.2.2.1.3.</span> <span class="toc-text">3.嵌套循环</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%92%E5%BD%92"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%B0%83%E7%94%A8%E6%A0%88"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">1.调用栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">2.尾递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%80%92%E5%BD%92%E6%A0%91"><span class="toc-number">1.2.2.2.3.</span> <span class="toc-text">3.递归树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3.对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%81%94%E7%B3%BB"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4.联系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%9F%E8%AE%A1%E6%97%B6%E9%97%B4%E5%A2%9E%E9%95%BF%E8%B6%8B%E5%8A%BF"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.统计时间增长趋势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E6%B8%90%E8%BF%91%E4%B8%8A%E7%95%8C"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.函数渐近上界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8E%A8%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.推算方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%9F%E8%AE%A1%E6%93%8D%E4%BD%9C%E6%95%B0%E9%87%8F"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">1.统计操作数量</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%BF%BD%E7%95%A5-%F0%9D%91%87-%F0%9D%91%9B-%E4%B8%AD%E7%9A%84%E5%B8%B8%E6%95%B0%E9%A1%B9"><span class="toc-number">1.2.3.3.1.1.</span> <span class="toc-text">1.忽略 𝑇(𝑛) 中的常数项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%9C%81%E7%95%A5%E6%89%80%E6%9C%89%E7%B3%BB%E6%95%B0"><span class="toc-number">1.2.3.3.1.2.</span> <span class="toc-text">2.省略所有系数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B9%98%E6%B3%95"><span class="toc-number">1.2.3.3.1.3.</span> <span class="toc-text">3.循环嵌套时使用乘法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%A4%E6%96%AD%E6%B8%90%E8%BF%91%E4%B8%8A%E7%95%8C"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">2.判断渐近上界</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">4.常见类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B8%B8%E6%95%B0%E9%98%B6-%F0%9D%91%82-1%EF%BC%89"><span class="toc-number">1.2.3.4.1.</span> <span class="toc-text">1.常数阶 𝑂(1）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E9%98%B6%F0%9D%91%82-n%EF%BC%89"><span class="toc-number">1.2.3.4.2.</span> <span class="toc-text">2.线性阶𝑂(n）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%B9%B3%E6%96%B9%E9%98%B6%F0%9D%91%82-n-2%EF%BC%89"><span class="toc-number">1.2.3.4.3.</span> <span class="toc-text">3.平方阶𝑂(n^2）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8C%87%E6%95%B0%E9%98%B6%F0%9D%91%82-2-n%EF%BC%89"><span class="toc-number">1.2.3.4.4.</span> <span class="toc-text">4.指数阶𝑂(2^n）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AF%B9%E6%95%B0%E9%98%B6%F0%9D%91%82-log-n%EF%BC%89"><span class="toc-number">1.2.3.4.5.</span> <span class="toc-text">5.对数阶𝑂(log n）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E7%BA%BF%E6%80%A7%E5%AF%B9%E6%95%B0%E9%98%B6%F0%9D%91%82-n-log-n%EF%BC%89"><span class="toc-number">1.2.3.4.6.</span> <span class="toc-text">6.线性对数阶𝑂(n*log n）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E9%98%B6%E4%B9%98%E9%98%B6%F0%9D%91%82-n%EF%BC%81%EF%BC%89"><span class="toc-number">1.2.3.4.7.</span> <span class="toc-text">7.阶乘阶𝑂(n！）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9C%80%E5%B7%AE%EF%BC%8C%E6%9C%80%E4%BD%B3%EF%BC%8C%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">5.最差，最佳，平均时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.空间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1.算法相关空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8E%A8%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.推算方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">3.常见类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B8%B8%E6%95%B0%E9%98%B6%F0%9D%91%82-1%EF%BC%89"><span class="toc-number">1.2.4.3.1.</span> <span class="toc-text">1.常数阶𝑂(1）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E9%98%B6%F0%9D%91%82-n%EF%BC%89-2"><span class="toc-number">1.2.4.3.2.</span> <span class="toc-text">2.线性阶𝑂(n）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%B9%B3%E6%96%B9%E9%98%B6%F0%9D%91%82-n-2%EF%BC%89-2"><span class="toc-number">1.2.4.3.3.</span> <span class="toc-text">3.平方阶𝑂(n^2）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8C%87%E6%95%B0%E9%98%B6%F0%9D%91%82-2-n%EF%BC%89-2"><span class="toc-number">1.2.4.3.4.</span> <span class="toc-text">4.指数阶𝑂(2^n）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AF%B9%E6%95%B0%E9%98%B6%F0%9D%91%82-log-n%EF%BC%89-2"><span class="toc-number">1.2.4.3.5.</span> <span class="toc-text">5.对数阶𝑂(log n）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9D%83%E8%A1%A1%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">5.权衡时间与空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">3.数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.数据结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.设计目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.与算法的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.数据结构分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">1.逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">2.物理结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">5.基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.6.</span> <span class="toc-text">6.数字编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">1.原码，反码，补码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8E%9F%E7%A0%81"><span class="toc-number">1.3.6.1.1.</span> <span class="toc-text">1.原码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%8E%9F%E7%A0%81%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.6.1.1.1.</span> <span class="toc-text">1.原码的计算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%8E%9F%E7%A0%81%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.3.6.1.1.2.</span> <span class="toc-text">2.原码的弊端</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%8D%E7%A0%81"><span class="toc-number">1.3.6.1.2.</span> <span class="toc-text">2.反码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%8F%8D%E7%A0%81%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.6.1.2.1.</span> <span class="toc-text">1.反码的计算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%8F%8D%E7%A0%81%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.3.6.1.2.2.</span> <span class="toc-text">2.反码的弊端</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%A1%A5%E7%A0%81"><span class="toc-number">1.3.6.1.3.</span> <span class="toc-text">3.补码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">2.浮点数编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.7.</span> <span class="toc-text">7.字符编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ASCII%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">1.ASCII字符集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-GBK%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">2.GBK字符集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Unicode%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%88%E7%BB%9F%E4%B8%80%E7%A0%81%EF%BC%89"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">3.Unicode字符集（统一码）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-UTF-8%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.7.4.</span> <span class="toc-text">4.UTF-8编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.7.5.</span> <span class="toc-text">5.编程语言的字符编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">4.数组与链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">1.数组常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">1.初始化数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.1.1.2.</span> <span class="toc-text">2.访问元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.1.1.3.</span> <span class="toc-text">3.插入元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.1.1.4.</span> <span class="toc-text">4.删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.1.1.5.</span> <span class="toc-text">5.遍历数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.1.1.6.</span> <span class="toc-text">6.查找元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%89%A9%E5%AE%B9%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.1.1.7.</span> <span class="toc-text">7.扩容数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">2.数组的优点与局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BC%98%E7%82%B9"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">1.优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">2.局限性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%93%BE%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1.链表常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">1.初始化链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.2.1.1.1.</span> <span class="toc-text">1.初始化各个节点对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%9E%84%E5%BB%BA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.2.1.1.2.</span> <span class="toc-text">2.构建节点之间的引用关系</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.2.1.2.</span> <span class="toc-text">2.插入节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.2.1.3.</span> <span class="toc-text">3.删除节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%AE%BF%E9%97%AE%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.2.1.4.</span> <span class="toc-text">4.访问节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.2.1.5.</span> <span class="toc-text">5.查找节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E4%B8%8E%E8%8A%82%E7%82%B9%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2.数组与节点的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3.常见链表类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%93%BE%E8%A1%A8%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4.链表典型应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%88%97%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1列表常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.3.1.1.</span> <span class="toc-text">1.初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%97%A0%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">1.4.3.1.1.1.</span> <span class="toc-text">1.无初始值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%9C%89%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">1.4.3.1.1.2.</span> <span class="toc-text">2.有初始值</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-2"><span class="toc-number">1.4.3.1.2.</span> <span class="toc-text">2.访问元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.3.1.3.</span> <span class="toc-text">3.插入和删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.3.1.4.</span> <span class="toc-text">4.遍历列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%8B%BC%E6%8E%A5%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.3.1.5.</span> <span class="toc-text">5.拼接列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.3.1.6.</span> <span class="toc-text">6.排序列表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">2.列表实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E4%B8%8E%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.内存与缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">1.计算机存储设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%86%85%E5%AD%98%E6%95%88%E7%8E%87"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">2.数据结构的内存效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%BC%93%E5%AD%98%E6%95%88%E7%8E%87"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">3.数据结构的缓存效率</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">1.5.</span> <span class="toc-text">5.栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">1.栈的常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">2.栈的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">1.基于链表的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.1.2.2.</span> <span class="toc-text">2.基于数组的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.1.2.3.</span> <span class="toc-text">3.两种实现的对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%A0%88%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.1.2.4.</span> <span class="toc-text">4.栈的典型应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1.队列常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2.队列的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">1.基于链表的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.5.2.2.2.</span> <span class="toc-text">2.基于数组的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.2.2.3.</span> <span class="toc-text">3.队列的典型应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.双向队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">1.双向队列的常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">2.双向队列实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.3.2.1.</span> <span class="toc-text">1.基于双向链表的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.5.3.2.2.</span> <span class="toc-text">2.基于数组的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.3.2.3.</span> <span class="toc-text">3.双向队列的应用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">6.哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">1.哈希表常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">2.哈希表简单实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E6%89%A9%E5%AE%B9"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">3.哈希冲突与扩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.哈希冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%93%BE%E5%BC%8F%E5%9C%B0%E5%9D%80"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1.链式地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2.开放寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B"><span class="toc-number">1.6.2.2.1.</span> <span class="toc-text">1.线性探测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B"><span class="toc-number">1.6.2.2.2.</span> <span class="toc-text">2.平方探测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%A4%9A%E6%AC%A1%E5%93%88%E5%B8%8C"><span class="toc-number">1.6.2.2.3.</span> <span class="toc-text">3.多次哈希</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">3.编程语言的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.哈希算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1.哈希算法的目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">2.哈希算法的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">3.常见哈希算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">4.数据结构的哈希值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%A0%91"><span class="toc-number">1.7.</span> <span class="toc-text">7.树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">1.二叉树常见术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">2.二叉树基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.1.2.1.</span> <span class="toc-text">1.初始化二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.1.2.2.</span> <span class="toc-text">2.插入与删除节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">3.常见二叉树类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.1.3.1.</span> <span class="toc-text">1.完美二叉树(满二叉树)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.1.3.2.</span> <span class="toc-text">2.完全二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AE%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.1.3.3.</span> <span class="toc-text">3.完满二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.1.3.4.</span> <span class="toc-text">4.平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%80%E5%8C%96"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">4.二叉树的退化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.二叉树遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">1.层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.2.1.1.</span> <span class="toc-text">1.代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">1.7.2.1.2.</span> <span class="toc-text">2.复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%EF%BC%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">2.前序，中序，后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.7.2.2.1.</span> <span class="toc-text">1.代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">1.7.2.2.2.</span> <span class="toc-text">2.复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.二叉树数组表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%A1%A8%E7%A4%BA%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">1.表示完美二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A1%A8%E7%A4%BA%E4%BB%BB%E6%84%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">2.表示任意二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%82%B9%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">3.优点与局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.7.4.</span> <span class="toc-text">4.二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">1.二叉搜索树的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.4.1.1.</span> <span class="toc-text">1.查找操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-2"><span class="toc-number">1.7.4.1.2.</span> <span class="toc-text">2.插入节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-2"><span class="toc-number">1.7.4.1.3.</span> <span class="toc-text">3.删除节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%89%E5%BA%8F"><span class="toc-number">1.7.4.1.4.</span> <span class="toc-text">4.中序遍历有序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">2.二叉搜索树的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">3.二叉搜索树常见应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-AVL%E6%A0%91"><span class="toc-number">1.7.5.</span> <span class="toc-text">5.AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-AVL%E6%A0%91%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">1.AVL树常见术语</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%8A%82%E7%82%B9%E9%AB%98%E5%BA%A6"><span class="toc-number">1.7.5.1.1.</span> <span class="toc-text">1.节点高度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%8A%82%E7%82%B9%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90"><span class="toc-number">1.7.5.1.2.</span> <span class="toc-text">2.节点平衡因子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-AVL%E6%A0%91%E6%97%8B%E8%BD%AC"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">2.AVL树旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%B3%E6%97%8B"><span class="toc-number">1.7.5.2.1.</span> <span class="toc-text">1.右旋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B7%A6%E6%97%8B"><span class="toc-number">1.7.5.2.2.</span> <span class="toc-text">2.左旋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%85%88%E5%B7%A6%E6%97%8B%E5%90%8E%E5%8F%B3%E6%97%8B"><span class="toc-number">1.7.5.2.3.</span> <span class="toc-text">3.先左旋后右旋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%85%88%E5%8F%B3%E6%97%8B%E5%90%8E%E5%B7%A6%E6%97%8B"><span class="toc-number">1.7.5.2.4.</span> <span class="toc-text">4.先右旋后左旋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%97%8B%E8%BD%AC%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.7.5.2.5.</span> <span class="toc-text">5.旋转的选择</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-AVL%E6%A0%91%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">3.AVL树常见操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.5.3.1.</span> <span class="toc-text">1.插入节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.5.3.2.</span> <span class="toc-text">2.删除节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.5.3.3.</span> <span class="toc-text">3.查找节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-AVL%E6%A0%91%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">1.7.5.4.</span> <span class="toc-text">4.AVL树典型应用</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%958/" title="数据结构与算法8">数据结构与算法8</a><time datetime="2025-12-11T11:38:44.992Z" title="发表于 2025-12-11 19:38:44">2025-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951-7/" title="数据结构与算法1-7">数据结构与算法1-7</a><time datetime="2025-12-11T11:38:41.812Z" title="发表于 2025-12-11 19:38:41">2025-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/07/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2025-10-07T08:30:44.422Z" title="发表于 2025-10-07 16:30:44">2025-10-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/03/CQB%E7%90%86%E8%AE%BA/" title="CQB理论">CQB理论</a><time datetime="2025-10-03T09:37:52.535Z" title="发表于 2025-10-03 17:37:52">2025-10-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/30/%E5%9C%A8butterfly%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%89%AF%E6%A0%87%E9%A2%98%EF%BC%8C%E5%B9%B6%E8%83%BD%E5%A4%9F%E8%BE%93%E5%87%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%AD%E5%BD%95/" title="在butterfly主题添加一个副标题，并能够输出自定义的随机语录">在butterfly主题添加一个副标题，并能够输出自定义的随机语录</a><time datetime="2025-08-30T12:21:45.678Z" title="发表于 2025-08-30 20:21:45">2025-08-30</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 余</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="请输入内容" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
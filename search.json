[{"title":"MySQL运维","url":"/2025/08/27/MySQL运维笔记/","content":"\n# MySQL运维\n\n## 1.日志\n\n### 1.错误日志\n\n* 错误日志是 MySQL 中最重要的日志之一，它记录了当mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。\n\n* 当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。\n\n* 该日志是默认开启的，默认存放目录/var/log/，默认的日志文件名为mysqld.log。查看日志位置：\n\n```sql\n  show variables like '%log_error%';\n```\n\n  \n\n### 2.二进制日志\n\n#### 1.介绍\n\n* 二进制日志（binlog）记录了所有ddl（数据定义语言）语句和dml（数据操纵语言）语句，但不包括数据查询（select，show）语句\n\n* 作用：\n\n  * 灾难时的数据恢复，数据库崩溃后再次执行二进制日志中的内容就可以恢复\n\n  * MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启的，涉及参数：\n\n```sql\n    show variables like '%log_bin%';\n```\n\n  * 可以查询到：\n\n    * log_bin：开启或关闭\n    * log_bin_basename：日志文件位置，文件由binlog和编号组成\n    * log_bin_index：索引文件位置\n\n\n\n#### 2.日志格式\n\n| 日志格式  | 含义                                                         |\n| --------- | ------------------------------------------------------------ |\n| statement | 基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中 |\n| row       | 基于行的日志记录，记录的是每一行的数据变更（默认）           |\n| mixed     | 混合了statement和row两种格式，默认采用statement，在某些特殊情况下会自动切换为row进行记录 |\n\n```sql\n  show variables like '%binlog_format%';\n```\n\n\\# 查询日志格式\n\n\\# 需要在文件中修改日志格式\n\n\\# 修改后会在新的日志文件中记录\n\n\n\n#### 3.日志查看\n\n* 由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具mysqlbinlog来查看\n\n* 语法：\n\n```shell\n  mysqlbinlog 选项 日志文件名\n```\n\n* 选项：\n\n  * -d，指定数据库名称，只列出指定的数据库相关操作\n  * -o，忽略掉日志中的前n行命令\n  * -v，将行事件（数据变更）重构为SQL语句\n  * -w，将行事件（数据变更）重构为SQL语句，并输出注释信息\n\n\n\n#### 4.日志删除\n\n* 对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间\n\n| 指令                                              | 含义                                                         |\n| ------------------------------------------------- | ------------------------------------------------------------ |\n| reset master;                                     | 删除全部binlog日志，删除之后，日志编号，将从binlog.000001重新开始 |\n| purge master logs to 'binlog.xxxxxx';             | 删除xxxxxx编号之前的所有日志（此编号不会被删除）             |\n| purge master logs before 'yyyy-mm-dd hh24:mi:ss'; | 删除日志为'yyyy-mm-dd hh24:mi:ss'之前产生的所有日志          |\n\n\n\n* 也可以在mysql的配置文件中配置二进制日志的过期时间，设置后，二进制日志过期会自动删除\n\n```sql\n  show variables like '%binlog_expire_logs_seconds%';\n```\n\n\\# 默认30天\n\n\n\n### 3.查询日志\n\n* 查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的\n\n* 涉及参数：general_log\n\n* 修改MySQL的配置文件/etc/my.cnf文件，添加内容：\n* **general_log=1**\n\n\\# 开启\n\n* general_log_file=目录/文件名\n\n\\# 指定文件名，默认文件名为主机名.log\n\n\n\n### 4.慢查询日志\n\n* 慢查询日志记录了所有执行时间超过参数long_query_time 设置值并且扫描记录数不小于min_examined_rowlimit的所有的SQL语句的日志，默认未开启。long_query_time 默认为10秒，最小为0，精度可以到微秒。\n\n\n\n* 默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以在MySQL的配置文件/etc/my.cnf文件中修改log_slow_admin_statements和更改此行为log_queries_not_using_indexes\n\n* **log_slow_admin_statements=1**\n\n\\# 记录执行较慢的管理语句\n\n* **log_queries_not_using_indexes=1**\n\n\\# 记录执行较慢的未使用索引的语句\n\n\n\n## 2.主从复制\n\n### 1.概述\n\n* 主从复制是指将主数据库的DDL 和 DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库（slave）和主库（master）的数据保持同步。\n\n* MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。\n\n\n\n* 作用：\n  * 1.主库出现问题，可以快速切换到从库提供服务。\n  * 2.实现读写分离，降低主库的访问压力。\n  * 3.可以在从库中执行备份，以避免备份期间影响主库服务。\n\n\n\n### 2.原理\n\n* 主要分为三步：\n  * 1.Master 主库在事务提交时，会把数据变更记录在二进制日志文件 binlog中。\n  * 2.从库的IOthread读取主库的二进制日志文件 binlog，写入到从库的中继日志Relay Log。\n  * 3.slave从库的SQLthread读取中继日志，再将改变反映它自己的数据。\n\n\n\n### 3.搭建\n\n#### 1.服务器准备\n\n* 主库和从库\n\n* 关闭服务器的防火墙\n\n```shell\n  systemctl stop firewalld\n```\n\n\\# 关闭防火墙\n\n```shell\n  systemctl disable firewalld\n```\n\n\\# 关闭防火墙的开机自启动\n\n* 或者\n* 开放指定的端口号\n\n\n\n#### 2.主库配置\n\n##### 1.修改配置文件/etc/my.cnf\n\n* **server-id=1**\n\n\\# mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1，默认为1\n\n\n\n* **read-only=0**\n\n\\# 是否只读，1代表只读，0代表读写\n\n\n\n* **binlog-ignore-db=数据库名**\n\n\\# 忽略数据库，指不需要同步的数据库\n\n\n\n* **binlog-do-db=数据库名**\n\n\\# 指定同步的数据库\n\n\n\n##### 2.重启MySQL服务器\n\n```shell\n  systemctl restart mysqld\n```\n\n\\# 没有报错则配置成功\n\n\n\n##### 3.登录mysql，创建远程连接的账号，并授予主从复制权限\n\n```sql\n  create user '用户名'@'%'identified with mysql_native_password by '密码';\n```\n\n\\# 创建用户，并设置密码，因为主机名设置为%所以该用户可在任意主机连接该MySQL服务\n\n```sql\n  grant replication slave on *.* to '用户名'@'%';\n```\n\n\\# 为用户分配主从复制权限\n\n\n\n##### 4.通过指令，查看二进制日志坐标\n\n```sql\n  show master status;\n```\n\n* 字段含义说明：\n\n  * file：从哪个日志文件开始推送日志文件\n  * position：从哪个位置开始推送日志\n  * binlog_ignore_db：指定不需要同步的数据库\n\n\n\n#### 3.从库配置\n\n##### 1.修改配置文件/etc/my.cnf\n\n* **server-id=2**\n\n\\# mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1，和主库不一样即可\n\n\n\n* **read-only=1**\n\n\\# 是否只读，1代表只读，0代表读写\n\n\n\n* **super-read-only=1**\n\n\\# 可以将超级管理员也设置为只读，否则也能读写\n\n\n\n##### 2.重启MySQL服务器\n\n```shell\n  systemctl restart mysqld\n```\n\n\\# 没有报错则配置成功\n\n\n\n##### 3.登录mysql，设置主库配置\n\n```sql\n  change replication source to source_host='原主机ip地址',source_user='用户名',source_password='密码',source_log_file='对应二进制日志文件',source_log_pos=从日志中的哪个位置开始同步;\n```\n\n\\# 从日志中的哪个位置开始同步，可以查看二进制日志坐标中的position\n\n* 老版本\n\n```sql\n  change master to master_host='原主机ip地址',master_user='用户名',master_password='密码',master_log_file='对应二进制日志文件名',master_log_pos=从日志中的哪个位置开始同步;\n```\n\n  \n\n##### 4.开启同步操作\n\n```sql\n  start replica;\n```\n\n\n\n* 老版本(新版本也兼容)\n\n```sql\n  start slave;\n```\n\n\n\n##### 5.查看主从同步状态\n\n```sql\n  show replica status;\n```\n\n\n\n* 老版本\n\n```sql\n  show slave status;\n```\n\n\\# 状态中**Replica_IO_Running** 和**Replica_SQL_Running** 为**Yes** 说明主从复制正常\n\n\n\n## 3.分库分表\n\n### 1.介绍\n\n#### 1.问题分析\n\n* 随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：\n  * 1.IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多，带宽不够，网络IO瓶颈。\n  * 2.CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。\n\n\n\n* 分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。\n\n\n\n#### 2.拆分策略\n\n* 垂直拆分\n  * 垂直分库：以表为依据，根据业务将不同表拆分到不同库中。\n    * 每个库的表结构都不一样\n    * 每个库的数据也不一样\n    * 所有库的并集是全量数据\n  * 垂直分表：以字段为依据,根据字段属性将不同字段拆分到不同表中。\n    * 每个表的结构都不一样\n    * 每个表的数据也不一样，一般通过一列（主键/外键）关联\n    * 所有表的并集是全量数据\n\n\n\n* 水平拆分\n  * 水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。\n    * 每个库的表结构都一样\n    * 每个库的数据都不一样\n    * 所有库的并集是全量数据\n  * 水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个库中。\n    * 每个表的表结构都一样\n    * 每个表的数据都不一样\n    * 所有表的并集是全量数据\n\n\n\n#### 3.实现技术\n\n* shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。\n* MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。\n\n\n\n### 2.MyCat概述\n\n#### 1.介绍\n\n* Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。mycat伪装了mysql的协议，所以可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在。\n\n* 优势：\n  * 性能可靠稳定\n  * 强大的技术团队\n  * 体系完善\n  * 社区活跃\n\n\n\n* MyCat中间件服务器需要安装jdk和mycat\n\n\n\n* mycat解压后有主要四个目录：\n  * bin：存放可执行文件，用于启动停止mycat\n  * conf：存放mycat的配置文件\n  * lib：存放mycat的项目依赖包（jar）\n  * logs：存放mycat的日志文件\n\n\n\n#### 2.概念介绍\n\n* 逻辑结构：\n* 逻辑库\n  * 逻辑表\n    * 分片节点\n* 物理结构：\n* 节点主机（与分片节点相连）\n\n\n\n### 3.MyCat入门\n\n#### 1.需求\n\n* 由于 tb_order 表中数据量很大，磁盘IO及容量都到达了瓶颈，现在需要对tb_order表进行数据分片，分为三个数据节点，每一个节点主机位于不同的服务器上。\n\n\n\n#### 2.环境准备\n\n* 需要在三台服务器上都建立一个空的数据库\n* 将防火墙关闭或者直接开放指定端口\n\n\n\n#### 3.分片配置（schema.xml）\n\n* 修改mycat中conf中的schema.xml文件\n\n\\# 可以用notepad++的插件NppFTP，show NppFTP Windows，便于编辑\n\n\n\n* 1.配置table（逻辑表）的表名\n* 2.配置dataNode（数据节点）的数据节点名\n* 3.配置数据节点连接的dataHost（节点主机）的节点主机名\n* 4.配置关联的节点主机的database（数据库）的数据库名\n* 5.在下面的dataHost中详细配置关联的服务器的ip地址，端口号以及用户名和密码\n\n\n\n#### 4.分片配置（server.xml）\n\n* 修改mycat中conf中的server.xml文件\n\n* 配置mycat的用户及用户的权限信息\n\n\n\n* 将user中的schemas后面的testdb改为数据库名\n* 在readOnly后可以配置是否只可读\n\n\n\n#### 5.启动服务\n\n* 切换到mycat的安装目录，执行指令启动mycat\n\n```shell\n  bin/mycat start\n```\n\n\\# 启动\n\n```shell\n  bin/mycat stop\n```\n\n\\# 停止\n\n\\# mycat启动后占用端口号8066\n\n\n\n* 启动完成后可以查看logs目录下的启动日志，查看mycat是否启动完成\n\n\n\n* 登录\n\n* 和MySQL一样\n\n```shell\n  mysql -h 主机ip地址 -P 8066 -u root -p\n```\n\n  \n\n### 4.MyCat配置\n\n#### 1.schema.xml\n\n* schema.xml作为MyCat中最重要的配置文件之一，涵盖了MyCat的逻辑库、逻辑表、分片规则、分片节点及数据源的配置。\n* 主要包含三组标签\n\n##### 1.schema\n\n```xml\n  <schema name=\"DB01\" checkSQLschema=\"true\" sqlMaxLimit=\"100\">\n      <table name-\"TB ORDER\" dataNode=\"dnl,dn2,dn3\" rule=\"auto-sharding-long\" />\n  </schema>\n```\n\n* schema标签用于定义 MyCat实例中的逻辑库，一个MyCat实例中，可以有多个逻辑库，可以通过 schema标签来划分不同的逻辑库。\n* MyCat中的逻辑库的概念，等同于ySQL中的database概念，需要操作某个逻辑库下的表时，也需要切换逻辑库(use xxx)。\n* 核心属性：\n  * name：指定自定义的逻辑库库名\n  * checksdLschema：在SOL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去除，false：不自动去除\n  * sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录\n\n* 子标签table\n\n  * table标签定义了MyCat中逻辑库schema下的逻辑表，所有需要拆分的表都需要在table标签中定义。\n\n```xml\n    <schema name=\"DB01\" checkSQLschema=\"true\" sqlMaxLimit=\"100\">\n        <table name-\"TB ORDER\" dataNode=\"dnl, dn2,dn3\" rule=\"auto-sharding-long\" /></schema>\n```\n\n  * 核心属性：\n\n    * name：定义逻辑表表名，在该逻辑库下唯一\n    * dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔\n    * rule：分片规则的名字，分片规则名字是在rule.xml中定义的\n    * primaryKey：逻辑表对应真实表的主键\n    * type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配置为global\n\n\n\n##### 2.dataNode\n\n* dataNode标签中定义了MyCat中的数据节点，也就是我们通常说的数据分片。一个dataNode标签就是一个独立的数据分片。\n\n```xml\n      <dataNode name=\"dn1\" dataHost=\"dhost1\" database=\"dbo1\"/>\n  \t<dataNode name=\"dn2\" dataHost=\"dhost2\" database=\"dbo1\">\n      <dataNode name=\"dn3\" dataHost=\"dhost3\" database-\"dbo1\">\n```\n\n* 核心属性：\n  * name：定义数据节点名称\n  * dataHost：数据库实例主机名称，引用自dataHost 标签中name属性\n  * database：定义分片所属数据库\n\n\n\n##### 3.dataHost\n\n* dataHost标签在MyCat逻辑库中作为底层标签存在，直接定义了具体的数据库实例、读写分离、心跳语句。\n\n```xml\n  <dataHost name=\"dhost1\" maxCon=\"1000\" minCon=\"10\" balance=\"0\" writeType=\"0\" dbType=\"mysql\" dbDriver=\"jdbc\">\n      <heartbeat>select user()</heartbeat>\n      <writeHost host=\"master\" url=\"jdbc:mysql://192.168.200.210:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp:characterEncoding-utf8\"\n                 user=\"root\" password=\"1234\">    \n      </writeHost>\n  </dataHost》\n```\n\n* 核心属性：\n\n  * name：唯一标识，供上层标签使用\n  * maxCon/minCon: 最大连接数/最小连接数\n  * balance:负载均衡策略，取值0,1,2,3\n  * writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）\n  * dbDriver：数据库驱动，支持native、jdbc\n\n\n\n#### 2.rule.xml\n\n* rule.xml中定义所有拆分表的规则，在使用过程中可以灵活的使用分片算法，或者对同一个分片算法使用不同的参数，它让分片过程可配置化。主要包含两类标签：tableRule、Function\n\n```xml\n  <tableRule name=\"auto-sharding-long\"> \n  \t<rule>\n          <columns>id</colunsJ>\n      \t<algorithm>rang-long</algorithm>\n      </rule>\n  </tableRule>\n```\n\n\\# 分片规则\n\n```xml\n  <function name=\"rang-long\"\n      class=\"io.mycat.route.function.AutoPartitionByLong\">\n      <property name-\"mapFile\">autopartition-long.txt</property>\n  </function>\n```\n\n\\# 关联的分片算法rang-long，封装在外部文件autopartition-long.txt\n\n\n\n#### 3.server.xml\n\n* server.xml配置文件包含了MyCat的系统配意信息，主要有两个重要的标签：System、user。\n\n* system\n\n  * 对应的系统配置项及其含义，参考资料。\n\n```xml\n    <system>\n        <property name=\"nonePasswordLogin\">0</property>\n        <property name=\"useHandshakeV10\">1</property>\n        <property name=\"useSqlStat\">l</property>\n    </system>\n```\n\n* user\n\n```xml\n    <user name=\"root\" defaultAccount=\"true\">\n    \t<property name=\"password\">123456</property>\n    \t<property name=\"schemas\">DB01</property>\n```\n\n  * schemas后的表示该用户可以访问的逻辑库，多个逻辑库之间逗号分隔\n\n```xml\n    <privileges check=\"false\">\n        <schema name=\"TESTDB\" dml=\"0110\">\n        \t<table name=\"tb01\" dml=\"0000\"></table>\n        \t<table name=\"tb02\" dml=\"1111\"></table>\n        </schema>\n    </privileges>\n```\n\n  \\# \\<privileges check=\"false\">表示是否开启DML权限检查，默认为false\n\n  \\# \\<schema name=\"TESTDB\" dml=\"0110\">配置指定逻辑库的权限\n\n  \\# \\<table name=\"tb01\" dml=\"0000\">\\</table>配置指定逻辑表的权限，就近原则：以逻辑表为准（如果配置了逻辑表权限）\n\n  \\# 0000，用二进制数对应IUSD（增改查删，例如1010则为增和查）的权限\n\n\n\n### 5.MyCat分片\n\n#### 1.垂直拆分\n\n##### 1.场景\n\n* 在业务系统中，涉及以下表结构，但是由于用户与订单每天都会产生大量的数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分，原有的数据库表如下\n  * 省市区\n  * 商品\n    * 基础信息\n    * 品牌\n    * 分类\n    * 编号\n    * 详细信息\n  * 订单\n    * 详细信息\n    * 支付记录\n  * 用户\n    * 用户名\n    * 用户地址\n\n* 将用户和省市区，商品，订单存放在三个分片中\n\n\n\n##### 2.准备\n\n* 在三台MySQL中创建数据库shopping\n\n\n\n##### 3.配置\n\n* 在schema中配置逻辑库，逻辑表，以及指定每一个逻辑表所关联的数据节点\n\n```xml\n  <schema name=\"SHOPPING\" checksgLschema=\"true\" sqlMaxLimit=\"100\">\n      <table name=\"tb goods base\" dataNode=\"dnl\" primaryKey=\"id\"/>\n      <table name=\"tb goods brand\" dataNode-\"dnl\" primaryKey\"id\"/>\n      <table name=\"tb goods cat\" dataNode=\"dn1\" primaryKey=\"id\"/>\n      <table name=\"th goods desc\" dataNode=\"dnl\" primaryKey=\"goods id\"/>\n      <table name=\"tb goods item\" dataNode=\"dnl\" primaryKey=\"id\"/>\n      \n      <table name=\"tb order item\" dataNode=\"dn2\" primaryKey=\"id\"/>\n      <table name=\"tb order master\" dataNode=\"dn2\" primaryKey=\"order id\"/>\n      <table name=\"tb order pay log\" dataNode=\"dn2\" primaryKey=\"out trade no\"/>\n      \n      <table name=\"tb user\" dataNode=\"dn3\" primaryKey=\"id\"/>\n  \t<table name=\"th user address\" dataNode=\"dn3\" primaryKey=\"id\"/>\n      <table name=\"tb areas provinces\" dataNode=\"dn3\" primaryKey=\"id\"/>\n      <table name=\"tb areas city\" dataNode=\"dn3\" primaryKey=\"id\"/>\n      <table name=\"tb areas region\" dataNode=\"dn3\" primaryKey=\"id\">\n  </schema>\n      \n  <dataNode name=\"dn1\" dataHost=\"dhostl\" database=\"shopping\" />\n  <dataNode name=\"dn2\" dataHost=\"dhost2\" database=\"shopping\" />\n  <dataNode name-\"dn3\" dataHost=\"dhost3\" database=\"shopping\" />\n```\n\n  \n\n##### 4.测试\n\n* 在mycat命令行中，通过source指令导入表结构，以及对应的数据，查看数据分布情况\n\n```shell\n  source /目录/文件名\n```\n\n\n\n* 查询用户的收件人及收件人地址信息（多表联查）\n\n```sql\n  select ua.user_id, ua.contact, p.province, c.city, r.area , ua.address from tb_user address ua ,tb_areas_city c, tb_areas_provinces p,tb_areas_region r where ua.province_id = p.provinceid and ua.city_id = c.cityid and ua.town_id = r.areaid;\n```\n\n  \n\n* 查询每一笔订单及订单的收件地址信息\n\n```sql\n  SELECT order_id , payment,receiver,province,city,area FROM tb_order_master o , tb_areas_provinces p , tb_areas_city c, tb_areas_region r WHERE o.receiver_province = p.provinceid AND o.receiver_city = c.cityid AND o.receiver_region = r.areaid;\n```\n\n\\# 这里直接执行会报错，这是跨两库的多表联查\n\n\n\n##### 5.全局表配置\n\n* 对于省、市、区/县表tb_areas_provinces,tb_areas_city,tb_areas_region，是属于数据字典表，在多个业务模块中都可能会遇到，可以将其设置为全局表，利于业务操作。\n\n```xml\n  <table name=\"tb_areas_provinces\" dataNode=\"dnl,dn2,dn3\" primaryKey=\"id\"type=\"global\"/>\n```\n\n\\# 对三张表进行全局配置，查询的时候就会把这三张表路由到订单的数据库中，这样就能实现跨两库的多表联查\n\n\\# 全局表更新后关联的其他三个库中的表也会更新\n\n\n\n#### 2.水平拆分\n\n##### 1.场景\n\n* 在业务系统中，有一张表(日志表，业务系统每天都会产生大量的日志数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分。\n\n\n\n##### 2.准备\n\n* 在三台MySQL中创建数据库itcast\n\n\n\n##### 3.配置\n\n```xml\n  <schema name=\"ITCAST\" checkSQLschema=\"true\" sqlMaxLimit=\"100\">\n  \t<table name=\"tb_log\" dataNode=\"dn4,dn5,dn6\" rule=\"mod-long\" />\n  </schema>\n  <dataNode name=\"dn4\" dataHost=\"dhosti\" database=\"itcast\" />\n  <dataNode name=\"dn5\" dataHost=\"dhost2\" database=\"itcast\" />\n  <dataNode name=\"dn6\" dataHost=\"dhost3\" database=\"itcast\" />\n```\n\n\\# 这里rule=\"mod-long\"将分片规则配置为取模\n\n```xml\n  <user name=\"root\" defaultAccount=\"true\">\n  \t<property name=\"password\">123456</property>\n  \t<property name=\"schemas\">SHOPPING,ITCAST</property>\n```\n\n\\# 增加访问的逻辑库\n\n\n\n* 创建表结构并导入数据\n\n\n\n#### 3.分片规则\n\n##### 1.范围（auto-sharding-long）\n\n* 根据指定的字段及其配置的范围与数据节点的对应情况，来决定该数据属于哪一个分片。\n\n```xml\n  <table name-\"tb operate\" dataNode-\"dn4,dn5,dn6\" rule\"auto-sharding-long\" />\n```\n\n\\# 在schema.xml中通过rule来指定对应的分片规则\n\n\n\n```xml\n  <tableRule name=\"auto-sharding-long\">\n      <rule>\n          <columns>id<columns>\n          <algorithm>rang-long</algorithm>\n      <rule>\n  <tableRule> \n```\n\n\\# rule\"auto-sharding-long\"分片规则引用的是rule.xml中定义的分片规则\n\n\\# \\<columns>id\\<columns>定义了根据id字段进行分片\n\n\\# \\<algorithm>rang-long\\</algorithm>分片对应的算法\n\n\n\n```xml\n  <function name=\"rang-long\" class=\"io.mycat.route.function.AutoPartitionByLong\">\n  \t<property name=\"mapFile\" >autopartition-long.txt</property>\n  <function>\n```\n\n\\# \\<algorithm>rang-long\\</algorithm>引用rule.xml中的function\n\n\\# class=\"io.mycat.route.function.AutoPartitionByLong\"这个java类中对分片规则进行定义解析\n\n\\# \\<property name=\"mapFile\" >autopartition-long.txt\\</property>又引用了一个外部文件\n\n\n\n```\n  # range start-end ,data node index\n  # K=1000,M=10000.\n  0-500M=0\n  500M-1000M=1\n  1000M-1500M=2\n```\n\n\\# autopartition-long.txt这个外部文件中具体配置了范围对应的节点\n\n\n\n##### 2.取模（mod-long）\n\n* 根据指定的字段值与节点数量进行求模运算，根据运算结果，来决定该数据属于哪一个分片。\n\n```xml\n  <property name=\"count\">3</property>\n```\n\n\\# 在rule.xml中配置节点数\n\n\n\n##### 3.一致性hash（sharding-by-murmur）\n\n* 所谓一致性哈希，将字符串字段根据哈希计算，相同的哈希因子计算值总是被划分到相同的分区表中，不会因为分区节点的增加而改变原来数据的分区位置。\n\n```xml\n  <property name=\"count\">3</property>\n```\n\n\\# function中配置节点数\n\n\n\n##### 4.枚举（sharding-by-intfile）\n\n* 通过在配置文件中配置可能的枚举值,指定数据分布到不同数据节点上,本规则适用于按照省份、性别、状态拆分数据等业务。\n\n```xml\n  <property name=\"defaultNode\">2</property>\n```\n\n\\# function配置默认节点值，当插入的数据超出了指定的枚举值则默认存储到这个节点\n\n\n\n```xml\n  <property name=\"mapFile\">partition-hash-int.txt</property>\n```\n\n\\# function中引用外部文件，在partition-hash-int.txt这个文件中直接定义例如3=1，则字段值为3时存到第2个节点，节点是从0开始的\n\n\n\n* 如果有不同的字段要用同一种分片规则，则可以将原本的分片规则复制黏贴，修改规则名称，修改字段，对应的算法不更改\n\n\n\n##### 5.应用指定（sharding-by-substring）\n\n* 运行阶段由应用自主决定路由到那个分片，直接根据子字符串（必须是数字，例如截取前2个数字）计算分片号。\n\n```xml\n  <tableRule name=\"sharding-by-substring\"\n  \t<rule>\n  \t\t<columns>id</columns>\n  \t\t<algorithm>sharding-by-substring</algorithm>\n  \t</rule>\n  </tableRule>\n  \n  <function name=\"sharding-by-substring\" class=\"io.mycat.route.function.PartitionDirectBySubString\">\n  \t<property name=\"startIndex\">O</property>\n  \t<property name=\"size\">2</property>\n  \t<property name=\"partitionCount\">3</property>\n  \t<property name=\"defaultPartition\">2</property>\n  </function>\n```\n\n\\# 这个分片规则不在默认的样例中，需要自行添加\n\n\n\n```xml\n  <property name=\"startIndex\">O</property>\n```\n\n\\# 在function中配置开始索引\n\n\n\n```xml\n  <property name=\"size\">2</property>\n```\n\n\\# 配置截取长度\n\n\n\n```xml\n  <property name=\"partitionCount\">3</property>\n```\n\n\\# 配置分片数量\n\n\n\n```xml\n  <property name=\"defaultPartition\">2</property>\n```\n\n\\# 配置默认分片，截取出来的子字符串不在分片数量范围内则存储到默认分片\n\n\n\n##### 6.固定分片hash算法（sharding-by-long-hash）\n\n* 该算法类似于十进制的求模运算，但是为二进制的操作，会将指定字段（值必须是数字）的二进制的前10位与1111111111进行位&运算。\n* 位&运算：将前十位的每一位数与1111111111中的相同位置的数字进行对比，相同则为1，不同则为0，获得一个新的数字。1111111111对应的十进制数是2^10-1=1023，所以这里的位&运算得出的结果位于0-1023\n\n* 特点：\n  * 如果是求模，连续的值，分别分配到各个不同的分片；但是此算法会将连续的值可能分配到相同的分片，降低事务处理的难度。\n  * 可以均匀分配到节点，也可以非均匀分配。\n  * 分片字段必须为数字类型。\n\n\n\n```xml\n  <property name=\"partitionCount\">2,1</property>\n  <property name=\"partitionLength\">256,512</property>\n```\n\n\\# 2,1表示共三个节点，前两个长度都是256，后一个是512（总的分片长度默认最大为1024）\n\n\\# 2,1和256,512这里配置的数字个数必须对应\n\n\n\n##### 7.字符串hash解析（sharding-by-stringhash）\n\n* 截取字符串中的指定位置的子字符串，进行哈希运算，算出哈希值与1023进行位&运算，算出分片。\n\n```xml\n  <tableRule name=\"sharding-by-stringhash\"\n  \t<rule>\n  \t\t<columns>name</columns>\n  \t</rule>\n  </tableRule>\n  <function name=\"sharding-by-stringhash\" class=\"io.mycat.route.function.PartitionByString\">\n  \t<property name=\"partitionLength\">512</property>\n  \t<property name=\"'partitionCount\">2</property>\n  \t<property name=\"hashslice\">0:2</property>\n  </function>\n```\n\n\\# 这个分片规则也是需要自行添加的\n\n\n\n```xml\n  <property name=\"partitionLength\">512</property>\n  <property name=\"'partitionCount\">2</property>\n```\n\n\\# 两个节点各512长度\n\n\n\n```xml\n  <property name=\"hashslice\">0:2</property>\n```\n\n\\# hash运算位，格式start:end，start从0开始。0在end中出现代表str.length()，-1代表str.length()-1，大于0代表数字本身\n\n\n\n##### 8.按（天）日期分片（sharding-by-date）\n\n```xml\n  <function name=\"sharding-by-date\" class=\"io.mycat.route.function.PartitionByDate\">\t\t<property name=\"dateformat\">yyyy-MM-dd</property>\n  \t<property name=\"sBecinDate\">2022-01-01</property>\n  \t<property name=\"sEndDate\">2022-01-30</property>\n  <property name=\"sPartionDay\">10</property>\n  </function>\n```\n\n\\# 需要自行配置\n\n```xml\n  <property name=\"daterormat\">yyyy-MM-dd</property>\n```\n\n\\# 日期格式\n\n\n\n```xml\n  <property name=\"sBeginDate\">2022-01-01</property>\n```\n\n\\# 起始时间\n\n\n\n```xml\n  <property name=\"sEndDate\">2022-01-30</property>\n```\n\n\\# 截止时间\n\n\n\n```xml\n  <property name=\"sPartionDay\">10</property>\n```\n\n\\# 分片周期，每十天位一个分片，到达结束时间后，后面的日期再插入，会重复开始分片插入\n\n\\# dataNode的分片数量必须和这里的分片规则的数量一致，例如从同一年的01-01到12-31，每十天一个分片，则需要37个分片，没有则报错\n\n\n\n##### 9.按自然月分片（sharding-by-month）\n\n* mycat中自带的分片规则\n\n* 和按天分片一样需要配置日期格式和起始截止日期\n* 一个月为一个分片，到达结束时间后，后面的日期再插入，会重复开始分片插入\n* dataNode的分片数量必须和这里的分片规则的数量一致，例如从同一年的01-01到12-31，每一个月一个分片，则需要12个分片，没有则报错\n\n\n\n### 6.MyCat管理及监控\n\n#### 1.MyCat原理\n\n* 客户端发送插入的SQL语句到mycat\n* mycat\n  * 解析SQL\n  * 分片分析\n  * 路由分析，路由到相对应的节点中\n  * 读写分离分析\n  * ......\n\n* 客户端发送查询的SQL语句到mycat\n\n* mycat\n  * 解析SQL\n  * 分片分析，如果字段值不在规则范围内或者没有这个字段值，则接下来的路由分析会路由到所有库中\n  * 路由分析\n  * 读写分离分析\n  * ......\n* 分片节点\n  * 接收到SQL语句\n  * 执行后返回结果到mycat\n* mycat\n  * 结果合并\n  * 聚合处理\n  * 排序处理\n  * 分页处理\n  * ......\n  * 结果返回到客户端\n\n\n\n#### 2.MyCat管理\n\n* Mycat默认开通2个端口，可以在server.xml中进行修改。\n\n  * 8066数据访问端口，即进行DML和DDL操作。\n\n  * 9066数据库管理端口，即mycat服务管理控制功能，用于管理mycat的整个集群状态\n\n```shell\n    mysql -h ip地址 -P 9066 -uroot -p密码\n```\n\n\n\n| 命令               | 含义                        |\n| ------------------ | --------------------------- |\n| show @@help        | 查看Mycat管理工具帮助文档   |\n| show @@version     | 查看Mycat的版本             |\n| reload @@config    | 重新加载Mycat的配置文件     |\n| show @@datasouorce | 查Mycat的数据源信息         |\n| show @@datanode    | 查看MyCat现有的分片节点信息 |\n| show @@threadpool  | 查看Mycat的线程池信息       |\n| show @@sql         | 查看执行的SQL               |\n| show @@sql.sum     | 查看执行的SQL统计           |\n\n\n\n#### 3.MyCat-eye\n\n* Mlycat-web(Mycat-eye)是对mycat-server提供监控服务，功能不局限于对mycat-server使用。他通过JDBC连接对Mycat、Mysal监控，监控远程服务器(目前仅限于linux系统)的cpu、内存、网络、磁盘。\n* Mycat-eye运行过程中需要依赖zookeeper，因此需要先安装zookeeper。\n\n\n\n* 在mycat-web文件夹下\n\n```shell\n  sh start.sh\n```\n\n\\# 启动mycat-web\n\n* 在浏览器中输入网址：服务器ip：8082/mycat进入网站（需要关闭服务器的防火墙）\n\n\n\n* 在网站中进入mycat配置中的mycat服务配置\n* 管理端口：9066\n* 服务端口：8066\n* 数据库名称：这里要配置mycat-server配置文件schema.xml中schema标签配置的name。\n* 用户名：这里要配置mycat-server配置文件server.xml中user标签中name配置的值\n\n* 密码：这里要配置mycat-server配置文件server.xml中user标签中，property name=\"password\"配置的密码。\n\n\n\n## 4.读写分离\n\n### 1.介绍\n\n* 读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。\n* 通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。\n\n\n\n### 2.一主一从\n\n#### 1.原理\n\n* MySQL的主从复制，是基于二进制日志（binlog）实现的。\n\n\n\n#### 2.环境准备\n\n* 搭建主从结构\n\n\n\n### 3.一主一从读写分离\n\n#### 1.配置\n\n* 在schema.xml文件中配置主库writeHost host=\"master\" url=和从库readHost host=\"slave\" url=的ip地址\n\n\\# 从库的需要自行添加\n\n* 还要在server.xml中的user标签中的schemas中新增逻辑库，增加权限\n\n* MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控制，将参数值修改为1或3\n\n| 参数值 | 含义                                                         |\n| ------ | ------------------------------------------------------------ |\n| 0      | 不开启读写分离机制，所有读操作都发送到当前可用的writeHost上  |\n| 1      | 全部的readHost 与备用的writeHost都参与select语句的负载均衡（主要针对于双主双从模式） |\n| 2      | 所有的读写操作都随机在writeHost，readHost上分发              |\n| 3      | 所有的读请求随机分发到writeHost对应的readHost上执行,writeHost不负担读压力 |\n\n\n\n#### 2.问题\n\n* 主节点Master宕机之后,业务系统就只能够读,而不能写入数据了。\n  \n\n### 4.双主双从\n\n#### 1.介绍\n\n* 一个主机 Master1 用于处理所有写请求，它的从机 Slave1和另一台主机 Master2 还有它的从机库Slave2负责所有读请求。当Master1主机宕机后，Master2 主机负责写请求，Master1、Master2 互为备机。\n\n\n\n#### 2.环境准备\n\n* 共需要5台服务器，1台中间件，2台主库，2台从库\n* 全部关闭防火墙\n\n\n\n#### 3.搭建\n\n##### 1.修改主库1的配置文件/etc/my.cnf\n\n* **server-id=1**\n\n\\# mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1，默认为1\n\n\n\n* **binlog-do-db=数据库名**\n\n\\# 指定同步的数据库,需要写三句来同步三个数据库\n\n\n\n* **log-slave-updates**\n\n\\# 在作为从库时，有写入操作也要更新二进制日志文件\n\n\n\n##### 2.重启mysql服务\n\n```shell\n  systemctl restart mysqld\n```\n\n\n\n##### 3.修改主库2的配置文件/etc/my.cnf\n\n* 与主库1配置相同，只需修改id\n\n\n\n##### 4.两台主库创建账户并授权\n\n```sql\n  CREATE USER '用户名'@'%' IDENTIFIED WITH mysql_native_password BY Root@密码';\n```\n\n\\# 创建用户，并设置密码，该用户可在任意主机连接该MySQL服务\n\n\n\n```sql\n  GRANT REPLICATION SLAVE ON *.* TO '用户名'@'%';\n```\n\n\\# 为用户分配主从复制权限\n\n\n\n```sql\n  show master status;\n```\n\n\\# 通过指令查看两台主库的二进制日志坐标\n\n\n\n##### 5.修改从库1配置文件/etc/my.cnf\n\n* **server-id=2**\n\n\\# mysql服务id，保证整个集群环境中唯一，取值范围：1~2^32-1\n\n\n\n##### 6.重启mysql服务\n\n\n\n##### 7.修改从库2配置文件/etc/my.cnf\n\n\\# 修改id\n\n\n\n##### 8.从库1配置关联的主库1\n\n```sql\n  CHANGE MASTER TO MASTER_HOST='对应主库ip',MASTER_USER='用户名',MASTER_PASSWORD='密码',MASTER_LOG_FILE='二进制日志文件名',MASTER_LOG_POS=日志中开始的位置；\n```\n\n\\# 需要注意slave1对应的是master1，slave2对应的是master2。\n\n\n\n##### 9.启动从库主从复制，查看从库状态\n\n```sql\n  start slave;\n```\n\n```sql\n  show slave status;\n```\n\n  \n\n##### 10.从库2配置关联的主库2\n\n* 与从库1配置关联的主库1相同\n\n\n\n##### 11.主库之间的相互复制\n\n```sql\n  CHANGE MASTER TO MASTER_HOST='另一个主库ip',MASTER_USER='用户名',MASTER_PASSWORD='密码',MASTER_LOG_FILE='二进制日志文件名',MASTER_LOG_POS=日志中开始的位置；\n```\n\n\\# 在两台主库中都要执行指令\n\n\n\n##### 12.启动从库主从复制，查看从库状态\n\n\n\n### 5.双主双从读写分离\n\n* 在schema.xml文件中配置主库writeHost host=\"master\" url=和从库readHost host=\"slave\" url=的ip地址\n\n\\# 两个主库从库都要配置，从库分别配置在对应主库下\n\n\n\n* 修改balance的数值为1\n\n\n\n```xml\n  <dataHost name=\"dhost7\" maxCon=\"1000\" minCon=\"10\" balance=\"1\" writeType=\"0\" switchType=\"1 dbType=\"mysql\" dbDriver=\"jdbc\">\n```\n\n\\# 新增writeType和switchType\n\n* writeType\n  * 0：写操作都转发到第1台writeHost, writeHost1挂了，会切换到writeHost2上；\n  * 1：所有的写操作都随机地发送到配置的writeHost上；\n\n* switchType\n  * -1：不自动切换\n  * 1：自动切换","tags":["MySQL"]},{"title":"MySQL进阶","url":"/2025/08/27/MySQL进阶笔记/","content":"\n# MySQL进阶\n\n## 1.储存引擎\n\n### 1.MySQL体系结构\n\n* 客户端连接器：PHP,Python，Java的JDBC等\n\n\n\n* MySQL服务端：\n* 连接层：\n  * 连接池，用于接收客户端的连接，完成连接的处理，认证授权（校验用户名密码），校验每个客户端的权限，相关安全方案，检查是否超过最大连接数\n\n\n\n* 服务层：SQL接口，完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程，函数等\n  * SQL接口\n  * 解析器\n  * 查询优化器\n  * 缓存\n\n\n\n* 引擎层：复杂数据的存储和提取，服务器通过API和存储引擎进行通信。其中含有多个可选择的引擎，不同的存储引擎有不同功能，也可以在此基础上扩展。\n  * 可插拔存储引擎\n    * InnoDB（MySQL5.5后的默认引擎）\n    * NDB\n    * MyISAM\n    * .........\n\n\n\n* 存储层：主要将数据存储在文件系统之上，并完成与存储引擎的交互\n  * 系统文件\n  * 文件和日志\n\n\n\n### 2.储存引擎简介\n\n* 存储数据，建立索引，查询/更新数据等技术的实现方式。\n* 存储引擎是基于表的，而不是基于库的，所以存储引擎也可以称为表类型\n\n\n\n#### 1.查询表的存储引擎\n\n```sql\n  show create table 表名；\n```\n* 用查询建表语句查询\n\n```sql\n  CREATE TABLE `user1` (\n    `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',\n    `name` varchar(10) NOT NULL,\n    `age` int DEFAULT NULL,\n    `status` char(1) DEFAULT '1',\n    `gender` char(1) DEFAULT NULL,\n    `id_for_connent` int DEFAULT NULL,\n    PRIMARY KEY (`id`),\n    UNIQUE KEY `name` (`name`),\n    KEY `fk_user1_name_dept_id` (`id_for_connent`),\n    CONSTRAINT `fk_user1_name_dept_id` FOREIGN KEY (`id_for_connent`) REFERENCES `dept` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT `user1_chk_1` CHECK (((`age` > 0) and (`age` <= 120)))\n  ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用于学习约束的用户表'\n```\n\n* 其中查询出的**ENGINE=InnoDB** 就是存储引擎，InnoDB为默认引擎\n\n* **AUTO_INCREMENT=4** 代表id是自增的\n* **DEFAULT CHARSET=utf8mb4** 即当前表的默认字符集是utf8mb4\n* **COLLATE=utf8mb4_0900_ai_ci** 即排序方式\n\n\n\n#### 2.创建表时指定存储引擎\n\n```sql\n  create tables 表名(\n  \n  \t字段1 字段1的类型（comment 字段1的注释）,      #注意逗号\n  \n  \t字段2 字段2的类型（comment 字段2的注释）,\n  \n  \t........\n  \n  ) engine=innodb（comment 表注释）；\n```\n\n  \n\n\n\n#### 3.查看当前数据库支持的存储引擎\n\n```sql\n  show engine；\n```\n* 查询后显示\n\nengine（引擎名称）       support（是否支持）        comment（描述）       transactions       XA       savepoints    \n\n\n\n### 3.储存引擎特点\n\n#### 1.InnoDB\n\n* InnoDB是一种兼顾高可靠性和高性能的通用存储引擎\n* 特点：\n  * DML（数据的增删改）操作遵循ACID模型（事务的四大特性），支持**事务**\n  * **行级锁** ，提高并发访问性能\n  * 支持**外键** foreign key约束，保证数据的完整性和正确性\n\n* 文件：\n  * xxx.ibd:xxx代表的是表名，innodb引擎的每一张表都会对应这样一个表空间文件，储存该表的表结构（frm，sdi），数据和索引\n  * \\#文件不能直接打开，可以在文件夹中打开cmd，**ibd2sdi xxx.idb** 会返回一长串json\n  * 参数：innodb_file_per_table\n  * \\#可以用\n\n    ```sql\n    show varialbes like‘innodb_file_per_table’;\n    ```\n  \n    查看是否打开，打开则表示每张表对应一个表空间文件\n  \n* 逻辑存储结构\n  * tablespace：表空间，其中包含多个segment\n    * segment：段，其中包含多个extent\n      * extent：区（大小固定，每个区1M），其中包含多个page（可以包含64个页）\n        * page：页（大小固定，每个页16K，页也是磁盘操作的最小单元），其中包含多个row\n          * row：行，其中包含最后一次操作事务的id，指针，字段\n\n\n\n#### 2.MyISAM\n\n* MyISAM是MySQL早期的默认存储引擎\n* 特点：\n  * 不支持事务，不支持外键\n  * 支持表锁，不支持行锁\n  * 访问速度快\n\n* 文件：\n  * xxx.MYD：存储数据\n  * xxx.MYI：存储索引\n  * xxx.sdi：存储表结构信息，打开是文本形式的json，json格式化后查看\n\n\n\n#### 3.Memory\n\n* Memory引擎的表数据是存储在内存中的，由于受到硬件问题，或断电问题的影响，只能将这些表作为临时表或缓存使用\n* 特点：\n  * 内存存放（所以访问速度快）\n  * hash索引（默认）\n\n* xxx.sdi：存储表结构信息\n\n\n\n| 特点         | InnoDB        | MyISAM | Memory |\n| ------------ | ------------- | ------ | ------ |\n| 存储限制     | 64TB          | 有     | 有     |\n| 事务安全     | 支持          | —      | —      |\n| 锁机制       | 行锁          | 表锁   | 表锁   |\n| B+tree索引   | 支持          | 支持   | 支持   |\n| Hash索引     | —             | —支持  |        |\n| 全文索引     | 支持（5.6后） | 支持   | —      |\n| 空间使用     | 高            | 低     | N/A    |\n| 内存使用     | 高            | 低     | 中等   |\n| 批量插入速度 | 低            | 高     | 高     |\n| 支持外键     | 支持          | —      | —      |\n\n\n\n### 4.储存引擎选择\n\n* 应根据应用系统的特点选择合适的存储引擎，对于复杂的应用系统，可以根据实际情况选择多种存储引擎\n  * InnoDB：是MySQL的默认存储引擎，支持事务，外键。如果应用对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新，删除操作，那么InnoDB存储引擎是比较合适的选择\n  * MyISAM：如果应用是以读写操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性，并发性要求不是很高，那么MyISAM是合适的选择\n  * Memory：将所有数据保存在内存种，访问速度快，通常用于临时表及缓存。Memory的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性\n\n\n\n## 2.索引\n\n### 1.索引概述\n\n* 索引（index）：帮助MySQL**高效获取数据** 的**数据结构（有序）** 。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据上实现高级查找算法，这种数据结构就是索引。\n\n\\# 无索引时，例如\n\n```sql\nselect * from user where age = 40；\n```\n\n会与每一条数据匹配，称为全表扫描，性能极低\n\n\n\n* 优点：\n  * 提高数据检索的效率，降低数据的IO成本\n  * 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗\n\n\n\n* 缺点（影响较小）\n  * 索引列也要占用空间\n  * 索引提高了查询效率，但同时也降低更新表的速度，如对表进行insert，update，delete时效率降低\n\n\n\n### 2.索引结构\n\n* MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构\n\n| 索引结构            | 描述                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| B+Tree索引          | 最常见的索引类型，大部分引擎都支持B+树索引                   |\n| Hash索引            | 底层数据结构是用哈希表实现的，只有精确匹配索引列查询才有效，不支持范围查询 |\n| R-tree(空间索引)    | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间的数据类型，使用较少 |\n| Full-text(全文索引) | 是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，ES |\n\n\n\n| 索引          | InnoDB    | MyISAM | Memory |\n| ------------- | --------- | ------ | ------ |\n| B+Tree索引    | 支持      | 支持   | 支持   |\n| Hash索引      | 不支持    | 不支持 | 支持   |\n| R-tree索引    | 不支持    | 支持   | 不支持 |\n| Full-text索引 | 5.6后支持 | 支持   | 不支持 |\n\n\n\n#### 1.二叉树\n\n* 树状图，但是每个节点下最多只有两个分叉\n* 缺点：\n  * 1.极端情况如顺序插入时，会形成一个链表（即斜树，只有左子树或者只有右子树），查询性能大大降低。\n  * 2.大数据量情况下，层级较深，检索速度慢\n\n* 红黑数只能解决第一个缺点\n\n\n\n#### 2.B-Tree（多路平衡查找树）\n\n* 同样是树状图，但是可以有多个节点，一个节点的子节点个数称为度数（max-degree），每个节点可以存储（度数-1）个key，度数个指针\n* 当插入超过（度数-1）个key时，中间元素则向上裂变，例如数字：23，56，28，49，如果再插入一个数字59，则中间元素49向上裂变，（23，28），（56，59）成为49的两个子节点\n\n\n\n#### 3.B+Tree\n\n* 与B树类似，但是所有元素都会出现在叶子节点，上面的非叶子节点主要起到索引的作用，叶子节点则存放数据。同时叶子节点形成一个单向链表，每个节点通过指针指向下一个元素\n* 在MySQL中对B+Tree进行了优化，增加了一个指向相邻页子节点的链表指针，形成带有顺序指针的B+Tree，提高区间访问的性能\n* 其中的键值，数据，指针，都是存放在页\n\n\\# 假设一行数据大小为1k，那高度为2时可以存储18736字节的数据，高度为3时可以存储21939856字节的数据\n\n\n\n#### 4.Hash\n\n* 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中\n* 如果两个或多个键值，映射到同一个槽位上，就产生了hash冲突（hash碰撞），可以通过链表解决\n\n* 特点\n  * 1.Hash索引只能用于对等比较（=，in），不支持范围查询（between，>,<,...）\n  * 2.无法利用索引完成排序操作\n  * 3.查询效率高，通常（不出现hash碰撞）只需要一次检索就可以，效率通常要高于B+tree索引\n\n* 存储引擎支持\n  * MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的\n\n\n\n#### 5.思考\n\n* 为什么InnoDB存储引擎用B+Tree索引结构\n  * 相对于二叉树，层级少，搜素效率高\n  * 对于B-tree，无论叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低\n  * 相对Hash索引，B+tree支持范围匹配及排序操作\n\n\n\n### 3.索引分类\n\n| 分类     | 含义                                         | 特点                     | 关键字   |\n| -------- | -------------------------------------------- | ------------------------ | -------- |\n| 主键索引 | 针对于表中主键创建的索引                     | 默认自动创建，只能有一个 | primary  |\n| 唯一索引 | 避免同一个表中某数据列中的值重复             | 可以有多个               | unique   |\n| 常规索引 | 定位特定数据                                 | 可以有多个               |          |\n| 全文索引 | 查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | fulltext |\n\n\n\n* 在InnoDB中根据索引的存储形式，又分为两种\n\n| 分类                                              | 含义                                                       | 特点               |\n| ------------------------------------------------- | ---------------------------------------------------------- | ------------------ |\n| 聚焦索引                                          | 将数据存储与索引放在一块，索引结构的叶子节点保存了行数据   | 必须有，且只有一个 |\n| \\# 叶子节点下对应的是主键和这一行的行数据         |                                                            |                    |\n| 二级索引                                          | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个       |\n| \\# 叶子节点下对应的是索引对应字段和字段对应的主键 |                                                            |                    |\n\n\n\n* 两个索引都是B+tree索引\n\n\n\n* 例如\n\n  ```sql\n  select * from user where name='arm';\n  ```\n\n  这时候就会先根据name这个字段的二级索引查找对应name下面对应的主键，再根据主键去主键的聚焦索引查找对应主键下面的行数据。这个过程称为**回表查询**\n\n* 所以根据主键查询的效率要更高\n\n\n\n* 聚焦索引选取规则\n  * 如果存在主键，主键索引就是聚焦索引\n  * 如果不存在主键，将使用第一个唯一索引作为聚焦索引\n  * 如果以上都没有则自动生成一个rowid作为隐藏的聚焦索引\n\n\n\n### 4.索引语法\n\n1.创建索引\n\n```sql\n  create unique/fulltext index 索引名称 on 表名(表中字段名1,.....);\n```\n\n\\# 如果省略unique或者fulltext则创建一个常规索引\n\n\\# 关联一个字段则为单列索引，多个则为联合索引（联合索引）\n\n\\# 索引名称规范一般为**idx_表名\\_字段名**\n\n\n\n2.查看索引\n\n```sql\n  show index from 表名\\G；\n```\n\n\\# 不加G显示出来的是表格，但是内容过多会导致表格变形，加上G可以使其每行显示一条\n\n\n\n3.删除索引\n\n```sql\n  drop index 索引名称 on 表名；\n```\n\n\n\n### 5.SQL性能分析\n\n#### 1.SQL执行频率\n\n* MySQL中通过**show session/global status** 可以提供服务器状态信息。\n\n\\# session和global分别为当前会话和全局\n\n```sql\n  show global status like ’Com_____________';\n```\n\n\\# Com后面有几个下划线则为模糊匹配几个字符，可以查看当前数据库的insert，update，delete，select的访问频次\n\n\n\n#### 2.慢查询日志\n\n* 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认不开启，需要在MySQL的配置文件（/etc/my.cnf）中配置\n\n\n\n* **slow_query_log=1** 在配置文件中配置开启\n\n\n\n* **long_query_time=2** 设置慢查询日志的时间为2秒\n\n\n\n```sql\n  show variables like ‘slow_query_log'；\n```\n\n  查询慢查询日志是否打开\n\n\n\n* 日志存放在**/var/lib/mysql** 中会有一个以**-slow.log** 结尾的文件\n\n\\# 日志中会记录：哪一个用户通过哪一个主机连接,执行用了多少时间，锁了多少行，返回了多少条记录，用的哪一个数据库，执行的时间，执行的语句\n\n\n\n* **tail  -f  文件名** 在Linux中这个指令可以查看文件实时输出的内容\n\n\n\n#### 3.profile详情\n\n```sql\n  select @@have_profiling；\n```\n\n\\# 通过have_profiling参数，能够看到当前MySQL是否支持profile操作\n\n\n\n```sql\n  select @@profiling；\n```\n\n\\# 查看返回数字，是否开启\n\n\n\n```sql\n  set profiling=1；\n```\n\n\\# 默认profiling是关闭的，可以选择在session/global级别开启\n\n\n\n```sql\n  show profiles；\n```\n\n\\#查看每一条SQL的耗时基本情况\n\n\\# 会显示query_id，duration，query\n\n\n\n```sql\n  show profile for query 指定query_id；\n```\n\n\\# 查看指定query_id的SQL语句各阶段的耗时情况\n\n\n\n```sql\n  show profile cpu for query 指定query_id；\n```\n\n\\# 查看指定query_id的SQL语句cpu的使用情况\n\n\n\n#### 4.explain执行计划\n\n* explain或者desc命令获取MySQL如何执行select语句的信息，包括select语句执行过程中表如何连接和连接的顺序\n\n\n\n```sql\n  explain select 字段列表 from 表名 where 条件；\n```\n\n\\# 直接在select语句前加关键字explain/desc\n\n\\# 会显示id，select_type（查询类型）,table（使用的表），partitions（分区），type（连接的类型），possible_keys（可能用到的索引），key（实际用到的索引），key_len（索引长度），rows（扫描记录数），ref，filtered，extra\n\n\n\n* explain执行计划各字段含义\n\n  * id\n\n    * select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，则值越大的先执行）\n\n      \\# 多表查询会出现多条记录，会有多个id \n\n  * select_type\n\n    * 表示select的类型，常见有simple（简单表，即不使用表连接或者子查询），primary（主查询，即外层的查询），union（union中的第二个或者后面的查询语句），subquery（select/where之后包含了子查询）等\n\n  * type\n\n    * 表示连接（访问）类型，性能由好到坏为，null（基本不会出现，除非不访问表），system（访问系统表），const（根据主键和唯一索引访问），eq_ref（联表查询中根据主键和唯一索引访问）,ref（根据非唯一性的索引访问）,range,index（遍历整个索引）,all（全表扫描）\n\n  * possible_keys\n\n    * 表可能会用到的索引，会有一个或多个\n\n  * key\n\n    * 实际使用的索引，没有使用索引则为null\n\n  * key_len\n\n    * 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好\n\n  * rows\n\n    * MySQL认为必须要执行查询的行数，在innodb引擎的表中，是估计值\n\n  * filtered\n\n    * 表示返回结果的行数占需要读取行数的百分比，值越大越好\n\n\n\n### 6.索引使用\n\n#### 1.验证索引效率\n\n* 在未建立索引之前，执行SQL语句查看SQL耗时\n* 针对字段创建索引后再执行相同的SQL语句，再次查看SQL耗时\n\n\n\n#### 2.使用原则\n\n##### 1.最左前缀法则\n\n* 最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳过某一列，**索引将部分失效，则此列后面的字段失效**\n\n* 如果索引了多列（即联合索引），要遵守最左前缀法则\n\n\\# 例如建立联合索引按顺序关联name，age，status三个字段，在使用联合查询的时候，\n\n```sql\nselect * from 表名 where ......;\n```\n\n​    要遵守最左前缀法则，则where后面必须存在name=（位置不限），否则不会根据索引查询，\n\n​    在查询时用and连接字段，如果跳过了age字段，则name根据索引查询，status则不会\n\n\n\n##### 2.范围查询\n\n* 联合索引中，出现范围查询（>,<)，**范围查询右侧的列索引失效**\n\n\\# 同样是上面的例子，如果查询的时候where后面age>30，则其右侧即status失效（age仍然根据索引查询）\n\n\\# 在允许的情况下用>=和<=可以规避这个问题\n\n\n\n##### 3.索引列运算\n\n* 不要在索引列上进行运算操作，**索引将失效**\n\n\\# 例如建立了关于phone这个字段的索引，\n\n```sql\nselect * from 表名 where phone=‘号码’；\n```\n\n这样查询是可以根据索引查询的\n\n如果使用\n\n```sql\nselect * from 表名 where substring（phone，10，2）=‘12’；\n```\n\n即用了substring函数进行了运算\n\n则进行的是全表扫描，不会根据索引查询\n\n\\# 最左前缀法则中中间字段进行了运算会导致此字段和其后的字段索引失效\n\n\n\n##### 4.字符串不加引号\n\n* 字符串类型字段使用时，不叫引号，**索引将失效** ，根本原因是对其进行了隐式类型转换，字符串转为数字，而索引存储的是原字符串\n\n\\# possibilities_keys为字段相关的索引，但是实际索引key为null\n\n\\# 在最左前缀法则中，如果中间字段没有加引号，**则此字段以及后面的索引全部失效**\n\n\n\n##### 5.模糊查询\n\n* 如果仅仅是尾部查询模糊匹配（abc%），索引不会失效。但是只要头部模糊匹配（%abc），索引就失效\n\n\\# 同样在最左前缀法则中尾部模糊查询会导致当前索引可以使用，其后索引失效。\n\n\\# 只要有头部模糊就会导致，此字段索引及其后索引失效\n\n\n\n##### 6.or连接的条件\n\n* 用or分割开的条件，任一条件中列没有索引，那么前后索引都不会被用到\n\n\\# 只要有条件中的字段是联合索引里的中间字段且没有单独索引则失效，如果只是最左索引则可以使用\n\n\\# 会有可能索引，但实际索引key为null\n\n\\# 如果要查询字段是联合索引里的中间字段则需要创建单独索引\n\n\n\n##### 7.数据分布影响\n\n* 如果MySQL评估使用索引比全表更慢，则不使用索引\n\n\\# 主要取决于数据的分布，如果条件筛选出来的是小部分数据则会使用索引，反之不使用\n\n\n\n##### 8.SQL提示\n\n* 在SQL语句中加入一些提示来达到优化操作的目的\n\n\n\n###### 1.use index：建议MySQL使用某个索引，实际使用的索引根据MySQL的判断\n\n```sql\n  select * from 表名 use index（索引名）where ......；\n```\n\n\\# 可以用explain查看最终使用了哪个索引\n\n\n\n###### 2.ignore index：不使用某个索引\n\n```sql\n  select * from 表名 ignore index（索引名）where ........;\n```\n\n\n\n###### 3.force index：强制使用某个索引\n\n```sql\n  select * from 表名 force index（索引名）where .........；\n```\n\n\n\n##### 9.覆盖索引\n\n* 尽量使用覆盖索引（查询使用了索引，并且需要返回的列在该索引中已经全部能够找到），减少select*出现\n\n\\# 例如建立了关联了phone，age，name的联合索引，select id，phone，age，name后面条件包含三个字段\n\n​\t根据二级索引，主键id也包含在内，四个字段都在使用的索引中，这时候用explain查询，extra信息会显示\n\n​\tusing where；using index：查找使用了索引，但是需要的数据都在索引列中能找到，使用不需要回表查询\n\n​\t如果再查询status，这个字段不包含在使用到的索引中，则extra信息会显示\n\n​\tusing index condition：查找使用了索引，但是需要回表查询数据\n\n​\t如果要查询则再建立phone，age，name，status的联合索引，以提高效率，单独再建一个status的单列索引仍然会回表查询\n\n\n\n##### 10.前缀索引\n\n* 当字段类型为字符串（varchar，text等）使，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘io，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样可以对的节约索引空间，从而提高索引效率\n\n\n\n* 语法：\n```sql\n  create index 索引名称 on 表名（字段名（n））；\n```\n\n\\# n表示要提取这个字段的前面n个字符来构建索引\n\n\n\n* 前缀长度\n* 可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的\n* 计算公式：\n```sql\n  select count（distinct 字段名）/count（\\*） from 表名；\n```\n\n\\# distinct用于去除重复记录\n\n```sql\n  select count（distinct substring（字段名，起始位置，截取长度））/count（\\*） from 表名；\n```\n\n\\# substring用于截取，起始位置从1开始\n\n\n\n* 前缀索引查询流程\n```sql\n  select * from 表名 where email=‘完整的邮箱’；\n```\n\n\\# 先根据完整邮箱的前n位到创建的邮箱的前n位的二级索引中查找得到对应主键，再到聚合索引中找到对应主键的行数据，再将行数据中的email与要查询的完整邮箱比对，完全一致则返回数据。如果出现前n位相同，则将几个主键都拿到聚合索引中查询，最终一致的再返回出来\n\n\n\n##### 11.单列索引与联合索引\n\n* 如果存在多个查询条件，考虑针对于查询字段建立索引，建议建立联合索引，而非单列索引\n\n\\# 在使用时，即使创建了联合索引，MySQL可能仍会使用单列索引，会回表查询，可以使用SQL提示\n\n\n\n* 联合索引情况：\n* 仍然是B+tree，每个节点存储的键值是几个索引的组合情况\n\n\\# 例如将phone，name，age按顺序关联成联合索引，则每个键值的形式都是phone+name+age，根据phone来排序，phone一致则再根据name来排序，以此类推。同时phone就作为最左列\n\n\n\n### 7.索引设计原则\n\n1.针对于数据量较大（数据量超过100万左右），且查询比较频繁的表建立索引。\n\n2.针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。\n\n3.尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。\n\n4.如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。\n\n5.尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\n\n6.要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。\n\n7.如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。\n\n\n\n## 3.SQL优化\n\n### 1.插入数据\n\n#### 1.insert优化\n\n##### 1.批量插入\n\n```sql\n  insert into 表名 values（），（），（），.....；\n```\n\n\\# 因为每一次insert插入都会与数据库进行建立连接和网络传输，所以将多个insert合并为一个\n\n\\# 插入数据量在500-1000较为合适\n\n\n\n##### 2.手动提交事务\n\n```sql\nstart transaction；\n\ninsert......;\n\ninsert......;\n\ninsert......;\n\ncommit;\n\n```\n\n\n\n##### 3.主键顺序插入\n\n* 主键乱序插入\n* 主键顺序插入\n\n\\# 顺序插入的性能高于乱序插入，与MySQL的数据组织结构有关\n\n\n\n#### 2.大批量插入数据\n\n* 如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入\n\n* 客户端连接服务端时，加上参数  --local-infile  用于加载本地文件\n```shell\n  mysql --local-infile -u root -p\n```\n* 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关\n```sql\n  set global local_infile=1；\n```\n\n\\# 可以再用\n\n```sql\nselect @@local_infile；\n```\n\n查看值为多少，是否开启\n\n* 执行load指令将准备好的数据，加载到表结构中\n```sql\n  load data local infile ‘/root/文件名’ into ‘表名’ fields terminated by  ‘，’ lines terminated by ‘\\n';\n```\n\n\\# ‘，’表示指定用，分割每个字段，‘\\n'表示指定用\\n分割每一行数据\n\n\\# 需要先将文件上传到服务器中\n\n\\# 同样要按照主键顺序插入\n\n\n\n### 2.主键优化\n\n#### 1.数据组织方式\n\n* 在innodb存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（iot）\n\n\n\n* 页分裂\n* 页可以为空，也可以填充一半，或者全部填充，每个页至少包含2行数据（如果某一行数据过大，会行溢出），根据主键排列\n* 主键顺序插入：当第一个页填充满了，数据会在第二个页继续填充，同时会在一二页中维护一个双向指针\n\n* 主键乱序插入：例如第一个页中有值为1 5 9 23 47，第二个页中有值为55 67 89 101 107，且这两页已经填充满，此时插入一个值为50的行数据，那么会先生成一个新的数据页，再找到第一个页的50%的位置，即1 5 9和23 47，则先将23 47移动到生成的第三个页，再将50插入到第三个页，那么原本的链表指针是一二之间的，则重新设置一三间的双向指针和三二之间的双向指针，此现象被称为页分裂\n\n\n\n* 页合并\n* 当删除一行数据时，并没有真正的删除，只是数据被标记为删除并且它的空间允许被其他数据声明使用\n* 当页中删除的数据达到merge_threshold（合并页的阈值，默认为页的50%，可以自己设置，在创建表或者创建索引时指定），innodb会开始寻找最近的页查看是否可以将两个页合并以优化空间使用\n\n\n\n#### 2.主键设计原则\n\n* 满足业务需求的情况下，尽可能降低主键的长度，过长会占用空间，耗费大量磁盘io\n\n* 插入数据时，尽量选择顺序插入，选择auto_increment自增主键\n* 尽量不要使用uuid（每次生成的是无序的，导致乱序插入，可能页分裂，uuid v7是有序的）做主键或者其他自然主键，如身份证号（长度较长）\n\n* 业务操作时，避免对主键的修改\n\n\n\n### 3.order by优化\n\n* using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所以不是通过索引直接返回排序结果的排序都叫FileSort排序\n* using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高\n\n\n\n* 索引创建出来默认是升序排序的，在信息collation中显示A（asc），所以如果在查询时order by后面的字段都是倒序，就会在explain的extra中提示backward index scan（反向扫描索引）\n* 如果既有升序又有降序那么在extra中就会既有using index又有using filesort\n\n\\# **可以在创建索引的时候在字段名后加asc/desc来指定升序或降序**\n\n\n\n* 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则\n* 尽量使用覆盖索引\n* 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则\n* 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k）\n\n\\# 可以用\n\n```sql\nshow variables like ‘sort_buffer_size’；\n```\n\n来查看排序缓冲区的大小\n\n\\# 如果排序缓冲区满了，会在磁盘文件中排序，性能就会较低\n\n\n\n### 4.group by优化\n\n* 通过索引来提升效率\n* 分组操作时，索引的使用也是满足最左前缀法则的\n\n\\# 在group by后面使用字段也可以走联合索引\n\n\n\n### 5.limit优化\n\n* 正常limit查询时，如从200000000条开始一页10行数据，这时会将前200000010都排序，但是最终只返回10条记录\n* 可以通过覆盖索引和子查询来解决\n\n\n\n### 6.count优化\n\n* InnoDB中查询count（*）会很耗时，执行时需要把每一行数据从引擎里读出来，然后累加\n* erMyISAM引擎把一个表的总行数存在了磁盘上，因此执行count（*）的时候会直接返回这个数，效率高\n\n\\# 前提是查询时后面没有where条件\n\n\n\n* count的几种用法\n\n  * count（）是一个聚合函数，对于返回的结果集，一行一行地判断，如果count函数的参数不是null，累计值就加1，否则不加，最后返回累计值\n\n  * 用法：\n\n    * count（*）：InnoDB引擎不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行累加\n    * count（主键）：InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层，服务层获取主键后直接按行进行累加（主键不可能是null）\n    * count（字段）：\n      * 没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null则计数\n      * 有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回服务层直接累加\n    * count（1）：InnoDB引擎会遍历整张表，但不取值，服务层对于返回的每一行，放一个数字1进去，直接按行累加\n\n    \\# 官方文档中说，count（*）和count（1）的优化是一样的\n\n    \\# 效率：count（字段）<count（主键）<count（1）=count（*）\n\n\n\n### 7.update优化\n\n* InnoDB的行锁是针对索引加的锁，不是针对记录加的，并且该索引不能失效，否则会从行锁升级为表锁\n\n\\# 在一个窗口中开启事务，where条件后跟的是有索引的且不能是前面提到过的各种索引失效的字段，则符合条件的行数据会被锁定（在另一个会话中可以对其他行数据进行update），否则则会将整张表锁住，在另一个会话中开启事务对表中任意一行数据update都无法成功\n\n\n\n## 4.视图\n\n### 1.介绍\n\n* 视图（view）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图查询中使用的表（基表/基础表），并且在使用视图时动态生成的\n* 视图只保存查询的SQL逻辑，不保存查询结果，所以在创建视图的时候，主要在于创建SQL查询语句\n\n\n\n### 2.基本语法\n\n#### 1.创建\n\n```sql\n  create or replace view 视图名称（列名列表） as select语句 wtih cascaded/loacl check option；\n```\n\n\\# 如不需要替换视图则or replace可以省略\n\n\\# 不需要检查增删改是否满足条件时wtih cascaded/loacl check option可以省略\n\n\\# 例如\n\n```sql\ncreate view stu_i_n as select id，name from student where id <=10;\n```\n\n\n\n#### 2.查询\n\n* 查看创建视图的语句\n\n```sql\n  show create view 视图名称；\n```\n\n  \n\n* 查看视图数据\n```sql\n  select * from 视图名称 .........;\n```\n\n\\# 后面可以添加条件\n\n\n\n#### 3.修改\n\n```sql\n  create or replace view 视图名称（列名列表） as select语句 wtih cascaded/loacl check option；\n```\n\n或\n\n```sql\n  alter view 视图名称（列名列表） as select语句 wtih cascaded/loacl check option；\n```\n\n  \n\n#### 4.删除\n\n```sql\n  drop view if exists 视图名称 1，视图名称2， .......；\n```\n\n  \n\n### 3.检查选项\n\n* 当使用with check option子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的条件。MySQL允许基于另一个视图创建视图，它还会检查**所依赖视图** 中的规则以保持一致性。为了确定检查的范围，MySQL提供了两个选项：cascaded和local，默认值为cascaded（级联）\n\n\n\n* **cascaded** ：检查视图以及其所依赖的视图的条件\n* **local** ：检查视图条件，再查看其所依赖的视图是否有with check option来检查条件，有则检查，没有则只需满足当前视图条件\n\n\n\n### 4.更新\n\n* 要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则视图不可更新\n  * 聚合函数或窗口函数（sum，min，max，count）\n  * distinct\n  * group by\n  * having\n  * union或union all\n\n\n\n### 5.作用\n\n* 简单\n  * 视图不仅可以简化用户对数据的理解，也可以简化操作。经常使用的查询可以被定义为视图（类似于封装成函数），从而使得用户不必为以后的操作每次指定全部的条件\n* 安全\n  * 数据库可以授权，但不能授权到数据库的特定行和列上。通过视图用户只能查询修改授权的数据\n* 数据独立\n  * 视图可以帮助用户屏蔽真实表结构变化带来的影响，当基表的字段名改变时，可以通过起别名的方式使视图的字段名和基表原始字段相同\n\n\n\n## 5.储存过程\n\n### 1.介绍\n\n* 存储过程是事先经过编译并存储在数据库中的一段SQL语句集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器间的传输，提高数据处理的效率\n\n* 存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用\n\n\n\n* 特点：\n  * 封装，重用\n  * 可以接收参数，也可以返回数据\n  * 减少网络交互，提升效率\n\n\n\n### 2.基本语法\n\n#### 1.创建\n\n```sql\n  create procedure 存储过程名称（参数列表）\n  \n  begin\n  \n  \tSQL语句\n  \n  end；\n```\n\n\n\\# 在**命令行** 中创建存储过程时，SQL语句中会有**；** ，导致判定为SQL语句完成\n\n\\# **需要用关键字delimiter指定SQL语句的结束符**\n\n* 即**delimiter** 指定符号\n\n* 在end后将；改为指定符号\n\n* 同样也可以改回；\n\n\n\n#### 2.调用\n\n* **call 名称（参数）；**\n\n\n\n#### 3.查看\n\n```sql\n  select * from information_schema.routines where routine_schema = 'xxxx'；\n```\n\n\\# 在information_schema这个数据库中的routines这张表中，routine_schema限制数据库名称\n\n\\# 查询指定数据库的存储过程及状态信息\n\n\n\n```sql\n  show create procedure 存储过程名称；\n```\n* \\# 查询某个存储过程的定义\n\n\n\n#### 4.删除\n\n```sql\n  drop procedure if exists 存储过程名称；\n```\n\n\n\n### 3.变量\n\n#### 1.系统变量\n\n* 是MySQL服务器提供，不是用户自定义的，属于服务器层面，分为全局变量（global），会话变量(session）\n\n\\# 没有指定session或global则默认为session\n\n\n\n##### 1.查看系统变量\n\n```sql\n  show session/global variables；\n```\n\n\\# 查看所有系统变量\n\n\n\n```sql\n  show session/global variables like ‘.........’；\n```\n\n\\# 通过like模糊匹配查找变量\n\n\n\n```sql\n  select @@session/global.系统变量名；\n```\n\n\\# 查看指定变量的值\n\n\n\n##### 2.设置系统变量\n\n```sql\n  set session/global 系统变量名=值；\n```\n```sql\n  set @@session/global 系统变量名=值；\n```\n\n\\# 重启后设置的全局参数会恢复默认值，可以在/etc/my.cnf中配置\n\n\n\n#### 2.用户自定义变量\n\n* 是用户根据需要自己定义的变量，**用户变量不用提前声明** ，在用的时候直接用**@变量名** 使用就可以，其作用域为当前连接\n\n\n\n##### 1.赋值\n\n```sql\n  set @变量名1=值1，......；\n```\n```sql\n  set @变量名1 ：=值1，......；\n```\n\n\\# 建议使用**：=**\n\n```sql\n  select @变量名1 ：=值1，......；\n```\n```sql\n  select 字段名 into @变量名 from 表名；\n```\n\n\\# 将查询结果赋给变量\n\n\n\n##### 2.使用\n\n```sql\n  select @变量名1，......；\n```\n\n\\# 直接使用一个未赋值的变量也不会报错，只会返回null\n\n\n\n#### 3.局部变量\n\n* 是根据需要定义的在局部生效的变量，**访问前需要declare声明** ，可用作存储过程内的局部变量和输入参数，**局部变量的范围是在其内声明的begin...end块**\n\n\n\n##### 1.声明\n\n```sql\n  declare 变量名 变量类型 default ....；\n```\n\n  \n\n##### 2.赋值\n\n```sql\n  set 变量名=值；\n```\n```sql\n  set 变量名 ：=值；\n```\n```sql\n  select 字段名 into 变量名 from 表名 ......；\n```\n\n  \n\n### 4.if\n\n* 语法\n\n```sql\n  if 条件1 then\n  \t.......\n  elseif 条件2 then\n  \t........\n  else\n  \t........\n  end if；\n```\n\n\\# 例如\n\n```sql\ncreate procedure p1()\nbegin\n\tdeclare score int default 58 #这里将分数的默认值设为58，没有参数\n\tdeclare result varchar(10);\n\tif score >= 85 then\n\t\tset result :='优秀';\n\telseif score >= 60 then\n\t\tset result :='及格';\n\telse\n\t\tset result :='不及格'\n\tend if;\n\tselect result;\nend;\n```\n\n\n\n### 5.参数\n\n| 类型  | 含义                                         | 备注                            |\n| ----- | -------------------------------------------- | ------------------------------- |\n| in    | 该类参数作为输入，也就是需要调用时传入值     | \\# 默认为in                     |\n| out   | 该类参数作为输出，也就是该参数可以作为返回值 |                                 |\n| inout | 既可以作为输入参数，也可以作为输出参数       | \\# 可以用于作为百分制转化的参数 |\n\n\n\n* 语法\n\n```sql\ncreate procedure 存储过程名称（in/out/inout 参数名 参数类型）\n\nbegin\n\n\tSQL语句\n\nend；\n```\n\n\\# 例如\n\n```sql\ncreate procedure p1(in score int，out result varchar(10)) #这里将分数的类型设置为in传入，同时设置result为out返回\nbegin\n\tif score >= 85 then\n\t\tset result :='优秀';\n\telseif score >= 60 then\n\t\tset result :='及格';\n\telse\n\t\tset result :='不及格'\n\tend if;\nend;\n```\n\n\\# call的时候就要传入一个参数，同时还要自定义一个变量来接收返回的结果\n\n```sql\ncall p1(68,@result1);\n```\n\n\\# 这里执行完不会直接显示result，要查询@result1才能显示\n\n\n\n### 6.case\n\n* 语法一\n\n```sql\ncase 表达式\n\twhen 值1 then sql1语句\n\twhen 值2 then sql2语句\n\t......\n\telse sql3语句\nend case;\n```\n\n\n\n* 语法二\n\n```sql\ncase\n\twhen 条件表达式1 then sql1语句\n\twhen 条件表达式2 then sql2语句\n\t.......\n\telse sql3语句\nend case;\n```\n\n\\# 例如\n\n```sql\ncreate procedure p6(in month int)\nbegin\n\tdeclare result varchar(10）；\n\tcase\n\t\twhen month >= 1 and month <= 3 then\n\t\t\tset result :='第一季度'；\n\t\twhen month >= 4 and month <=6 then\n\t\t\tset result :='第二季度'；\n\t\twhen month >= 7 and month <=9 then\n\t\t\tset result :='第三季度'；\n\t\twhen month >= 10 and month <= 12 then\n\t\t\tset result :='第四季度'；\n\t\telse\n\t\t\tset result :='非法参数'；\n\tend case；\n\tselect concat('您输入的月份为：',month，'，所属的季度为：'，result）；\nend;\n```\n\n\n\n### 7.循环\n\n#### 1.while\n\n* while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句\n\n* 语法\n\n```sql\n  while 条件 do\n  \tsql语句\n  end while;\n```\n\n\\# 先判定条件，如果为true，则执行语句，否则不执行\n\n\\# 例如从1到n的累加\n\n\n\n#### 2.repeat\n\n* repeat是有条件的循环控制语句，当满足条件时退出循环\n\n* 语法\n\n```sql\n  repeat\n  \tsql语句\n  \tuntil 条件\n  end repeat;\n```\n\n\\# 先执行一次语句，然后判定是否满足条件，满足则退出，不满足则继续下一次循环\n\n\\# 同样也可以做累加的操作\n\n\n\n#### 3.loop\n\n* loop实现简单的循环，如果不在SQL语句中增加退出循环的条件，可以用其来实现简单的死循环\n\n* loop配合以下两个语句使用\n\n* **leave** ：配合循环使用，退出循环\n\n* **iterate** ：必须用在循环中，作用时跳过当前循环剩下的语句，直接进入下一次循环\n\n* 语法\n\n```sql\n  标识名:loop\n  \tsql语句\n  end loop 标识名;\n```\n\n```sql\n  leave 标识名;\n```\n\n```sql\n  iterate 标识名;\n```\n\n\\# 同样可以做累加\n\n```sql\ncreate procedure p9(in n int)\nbegin\n\tdeclare total int default 0;\n\t\n\tsum:loop\n\t\tif n<=0 then\n\t\t\tLeave sum;\n\t\tend if;\n\t\t\n\t\tset total:= total+n;\n\t\tset n:=n-1;\n\tend loop sum;\n\t\n\tselect total;\nend;\n```\n\n\n\n\\# 配合iterate可以做到累加偶数\n\n```sql\ncreate procedure p9(in n int)\nbegin\n\tdeclare total int default 0;\n\t\n\tsum:loop\n\t\tif n<=0 then\n\t\t\tLeave sum;\n\t\tend if;\n\t\t\n\t\tif n%2 = 1 then\n\t\t\tset n := n-1;\n\t\t\titerate sum;\n\t\tend if;\n\t\t\n\t\tset total:= total+n;\n\t\tset n:=n-1;\n\tend loop sum;\n\t\n\tselect total;\nend;\n```\n\n\n\n### 8.游标（光标）\n\n* 游标（cursor）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环处理。游标的使用包括游标的声明，open，fetch，close\n* 语法\n\n* 声明游标\n\n```sql\n  declare 游标名称 cursor for 查询语句;\n```\n\n\\# 游标的声明要在普通变量声明的后面\n\n\n\n* 打开游标\n\n```sql\n  open 游标名称;\n```\n\n\n\n* 获取游标记录\n\n```sql\n  fetch 游标名称 into 变量1，变量2，......;\n```\n\n\n\n* 关闭游标\n\n```sql\n  close 游标名称;\n```\n\n  \n\n### 9.条件处理程序\n\n* 条件处理程序（handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤\n\n* 语法\n\n```sql\n  declare handler_action handler for condition_value,condition_value,.... sql语句;\n```\n\n\\# handler_action:\n\n​\tcontinue：继续执行当前程序\n\n​\texit：终止执行当前程序\n\n\\# condition_value\n\n​\tsqlstate：状态码，如0200\n\n​\tsqlwarning：所有以01开头的sqlstate代码的简称\n\n​\tnot found：所有以02开头的sqlstate代码的简称\n\n​\tsqlexception：所有没有被sqlwarning和not found捕获的sqlstate代码的简称\n\n\n\n\\# 例如要查询所有年龄小于uage的用户的名称和专业\n\n```sql\ncreate procedure p11(in uage int）\nbegin\n\tdeclare uname varchar(100）；\n\tdeclare upro varchar(100）；\n\tdeclare u_cursor cursor for select name,profession from tb_user where age <= uage;\n\t#游标在普通声明后声明\n    declare exit handler for SQLSTATE '02000' close u_cursor；\n\t#条件处理程序，用于在循环体里结束循环\n\n    drop table if exists tb_user_pro;\n\tcreate table if not exists tb_user_pro(\n\t\tid int primary key auto_increment，\n\t\tname varchar(100），\n\t\tprofession varchar(100）\n\t）；\n\t#创建空的表来接收查询出来的数据\n                         \n    open u_cursor；\n\twhile true do\n\t\tfetch ucursor into uname,upro;\n\t\tinsert into tb_user_pro values (null, uname, upro)；\n\tend while；\n    close u_cursor;\n\t#将游标中的数据循环读出，当读完所有数据时仍会循环读取，就会报错02000，上面的条件处理程序就会使其停止执行\n                           \nend;\n```\n\n\n\n## 6.存储函数\n\n* 存储函数是有返回值的存储过程，存储函数的参数只能是in类型的\n\n* 语法\n\n```sql\n  create function 存储函数名称（参数列表）\n  returns 数据类型 characteristic\n  begin\n  \tsql语句\n  \treturn.......;\n  end;\n```\n\n\\# characteristic：\n\n​\tdeterministic：相同的输入参数总是产生相同的结果\n\n​\tno sql：不包含sql语句\n\n​\treads sql data：包含读取数据的语句，但不包含写入数据的语句\n\n\\# 二进制制在版本8是默认开启的，所以会强制指定一个characteristic\n\n\n\n\\# 因为有return.......;所以可以直接查询这个存储函数来获取结果\n\n\\# 使用较少，存储过程可以替代存储函数\n\n\n\n## 7.触发器\n\n### 1.介绍\n\n* 触发器是与表有关的数据库对象，值在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作\n* 使用别名old和new来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发\n\n\n\n| 触发器类型     | new和old                                               |\n| -------------- | ------------------------------------------------------ |\n| insert型触发器 | new表示将要或者已经新增的数据                          |\n| update型触发器 | old表示修改之前的数据，new表示将要或者已经修改后的数据 |\n| delete型触发器 | old表示将要或者已经修改的数据                          |\n\n\n\n### 2.语法\n\n* 创建\n\n```sql\n  create trigger 触发器名称\n  before/after insert/update/delete\n  on 表名 for each row #行级触发器\n  begin\n  \t具体逻辑;\n  end;\n```\n\n  \n\n* 查看\n\n```sql\n  show triggers;\n```\n\n  \n\n* 删除\n\n```sql\n  drop trigger 数据库名称.触发器名称\n```\n\n\\# 如果没有指定数据库名称则默认为当前的数据库\n\n\n\n\\#例如一个用户表在增删改时要将增删改的内容记录到一个日志中\n\n```sql\ncreate table user_logs(\nid int(11) not null auto_increment,\noperation varchar(20) not null comment '操作类型，insert/update/delete',\noperate_time datetime not null comment '操作时间',\noperate_id int(11) not null comment '操作的ID',\noperate_params varchar(500) comment '操作参数',\nprimary key(`id`）\nengine=innodb default charset=utf8;\n```\n\n\\# 先创建一个日志用于记录\n\n\n\n\\# 创建插入数据触发器\n\n```sql\ncreate trigger tb_user_insert trigger\n\tafter insert on tb_user for each row\n\t#插入数据触发必然是after\nbegin\n\tinsert into user_logs(id, operation, operate_time, operate_id, operate_params) VALUES\n\t(null, 'insert', now(), new.id, concat('插入的数据内容为：id=',new.id,',name=',new.name,',phone=',NEW.phpne,',email=',NEW.email,',professiom=',NEW.profession))\n\t#id是自增的\n\t#insert表示数据操作的类型\n\t#now()获取当前数据操作时的实际\n\t#new.id获取操作数据的id\n\t#concat用于拼接后面这些新的数据\nend；\n```\n\n \\# 更新和删除也类似，更新时要同时记录更新前和更新后的数据，就再用old.字段名来获取，删除则只记录删除操作前的数据，只需要old.字段名\n\n\n\n## 8.锁\n\n### 1.介绍\n\n* 锁是计算机协调多个进程或者线程并发访问某一资源的机制。在数据库中，除传统的计算资源（cpu，ram，i/o）的争用以外，数据也是一种供许多用户享用的资源。任何保证数据并发访问的一致性，有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素\n\n\n\n### 2.全局锁\n\n* 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于**只读状态** ，后续的dml语句，ddl语句和已经更新操作的事务提交语句都会被阻塞\n* 典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性\n\n\n\n#### 1.语法\n\n* 加全局锁\n\n```sql\n  flush tables with read lock;\n```\n\n\n\n* 备份时可以使用MySQL的工具mysqldump（不要在MySQL中执行，这是MySQL的工具）\n\n```shell\n  mysqldump -uroot -p密码 表名>要转移到的表的表名.sql\n```\n\n\n\n* 解锁\n\n```sql\n  unlock tables;\n```\n\n\n\n#### 2.特点\n\n* 如果在主库上备份，那么在备份期间都不能执行更新，业务停摆\n* 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟\n\n\\# 在InnoDB引擎中，可以在备份时加上参数 --single-transaction参数来完成不加锁的一致性数据备份\n\n```shell\nmysqldump --single-transaction -uroot -p密码 表名>要转移到的表的表名.sql\n```\n\n\n\n### 3.表级锁\n\n* 表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率高，并发度最低。应用在MyISAM，InnoDB，BDB等存储引擎中\n\n\n\n#### 1.表锁\n\n* 可以分为两类：\n  * 1.表共享读锁（read lock，读锁）:所有客户端都只能读取数据，加了表锁的客户端写入会报错，其他客户端会被阻塞\n  * 2.表独占写锁（write lock，写锁）：加了表锁的客户端可以读写，其他客户端读写会被阻塞\n\n\n\n* 语法：\n\n* 加锁\n\n```sql\n  lock tables 表名..... read/write;\n```\n\n\\# 可以锁定多张表\n\n\n\n* 释放锁\n\n```sql\n  unlock tables;\n```\n\n\\# 或者直接将客户端关闭\n\n\n\n#### 2.元数据锁（meta data lock，mdl）\n\n* MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作，为了避免DML和DDL冲突，保证读写的正确性\n* MySQL5.5中引入的MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）\n\n| 对应SQL                                     | 锁类型                                | 说明                                             |\n| ------------------------------------------- | ------------------------------------- | ------------------------------------------------ |\n| lock tables xxx read/write                  | shared_read_only/shared_no_read_write |                                                  |\n| select，select....lock in share mode        | shared_read（共享）                   | 与shared_read，shared_write兼容，与exclusive互斥 |\n| insert，update，delete，select...for update | shared_write（共享）                  | 与shared_read，shared_write兼容，与exclusive互斥 |\n| alter table....                             | exclusive（排他）                     | 与其他的MDL都互斥                                |\n\n\n\n* 查看元数据锁\n\n```sql\n  select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;\n```\n\n\\# metadata_locks这张表中记录了当前数据库中是元数据锁\n\n\n\n#### 3.意向锁\n\n* 为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查\n\n\n\n* 分为两种：\n  * 意向共享锁（IS）：由语句select ... lock in share mode添加\n    * 与表锁共享锁（read）兼容，与表锁排他锁（write）互斥，会被阻塞\n  * 意向排他锁（IX）：由insert，upadte，delete，select ... for update 添加\n    * 与表锁共享锁（read）及排他锁（write）都互斥。意向锁之间不会互斥\n\n\n\n* 查看意向锁及行锁的加锁情况\n\n```sql\n  select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;\n```\n\n  \n\n\n### 4.行级锁\n\n#### 1.介绍\n\n* 行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中\n* InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，不是对记录加锁。\n* 主要分为三类：\n  * 行锁（record lock，记录锁）：锁定单个行数据的锁，防止其他事务对此行进行update和delete。在rc（read commit），rr（repeatable read）隔离级别下都支持\n  * 间隙锁（gap lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在rr隔离级别下都支持\n  * 临建锁（next-key lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙gap。在rr隔离级别下支持\n\n\n\n#### 2.行锁\n\n* InnoDB实现了以下两种类型的行锁\n  * 共享锁（s）：允许一个事务去读一行，即共享锁之间兼容，阻止其他事务获得相同数据集的排他锁\n  * 排他锁（x）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁\n\n\n\n| 请求锁类型              | s（共享锁） | x（排他锁） |\n| :---------------------- | :---------: | :---------: |\n| 当前锁类型：s（共享锁） |    兼容     |    冲突     |\n| x（排他锁）             |    冲突     |    冲突     |\n\n\n\n| SQL                          | 行锁类型   | 说明                                   |\n| ---------------------------- | ---------- | -------------------------------------- |\n| insert                       | 排他锁     | 自动加锁                               |\n| update                       | 排他锁     | 自动加锁                               |\n| delete                       | 排他锁     | 自动加锁                               |\n| select                       | 不加任何锁 |                                        |\n| select....lock in share mode | 共享锁     | 需要手动在select后加lock in share mode |\n| select....for update         | 排他锁     | 需要手动在select后加for update         |\n\n\n\n* 在默认情况下，InnoDB在repeatable read事务隔离级别运行，InnoDB使用next-key锁进行搜素和索引扫描，以防止幻读\n* 1.针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁\n* 2.InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁\n\n\n\n* 查看意向锁及行锁的加锁情况\n\n```sql\n  select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;\n```\n\n\n\n#### 3.间隙锁/临建锁\n\n* 默认情况下，InnoDB在repeatable read事务隔离级别运行，InnoDB使用next-key锁进行搜素和索引扫描，以防止幻读\n* 1.索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁\n* 2.索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁\n* 3.索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止\n\n\\# 间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙采用间隙锁\n\n\n\n## 9.InnoDB引擎\n\n### 1.逻辑存储结构\n\n* tablespace：表空间（ibd文件）一个mysql实例可以对应多个表空间，用于存储记录，索引等数据\n  * segment：段，分为数据段（leaf node segment），索引段（non-leaf node segment），回滚段（rollback segment），InnoDB是索引组织表，数据段就是B+tree的叶子节点，索引是B+tree的非叶子节点。段用来管理多个区\n    * extent：区，表空间的单元结构，每个页的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页\n      * page：页，是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区\n        * row：行，InnoDB存储引擎数据是按行进行存放的\n          * Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给Trx_id隐藏列\n          * Roll_pointer：每次对某条记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息\n\n\n\n### 2.架构\n\n* MySQL5.5之后，默认使用InnoDB存储引擎，它擅长事务处理，具有奔溃恢复特性，在日常开发中使用广泛\n\n\n\n#### 1.内存架构\n\n##### 1.Buffer Pool\n\n* 缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度\n\n* 缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态将Page分为三种类型：\n  * free page：空闲page，未被使用\n  * clean page：被使用page，数据没有被修改过\n  * dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘数据产生了不一致，还未刷新到磁盘\n\n\n\n##### 2.Change Buffer\n\n* 更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中\n\n* 与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更\n  新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了\n  ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。\n\n\n\n##### 3.Adaptive Hash Index\n\n* 自适应hash索引，用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引\n* 自适应哈希索引，无需人工干预，是系统根据情况自动完成。\n* 参数：adaptive_hash_index，可以查询是否开启\n\n\n\n##### 4.Log Buffer\n\n* 日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘IO\n* 参数：\n  * 缓冲区大小：innodb_log_buffer_size\n  * 日志刷新到磁盘时机：innodb_flush_log_at_trx_commit\n    * 1：日志在每次事务提交时写入并刷新磁盘\n    * 0：每秒将日志写入并刷新磁盘一次\n    * 2：日志在每次事务提交后写入，并每秒刷新到磁盘一次\n\n\n\n#### 2.磁盘结构\n\n##### 1.System Tablespace\n\n* 系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等）\n* 参数：innodb_data_file_path\n\n\n\n##### 2.File-Per-Table Tablespaces\n\n* 每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。\n* 参数：innodb_file_per_table\n\n\\# 默认开启\n\n\n\n##### 3.General Tablespaces\n\n* 通用表空间，需要通过CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。\n\n* 语法：\n\n* 创建通用表空间\n\n```sql\n  create tablespace xxxx add datafile '表空间关联的表空间文件' engine='引擎名称';\n```\n\n\n\n* 指定表空间\n\n```sql\n  create table xxx... tablespace 表空间名称;\n```\n\n\n\n##### 4.Undo Tablespaces\n\n* 撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间(初始大小16M)，用于存储undo log日志。\n\n\n\n##### 5.Temporary Tablespaces\n\n* InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。\n\n\n\n##### 6.Doublewrite Buffer Files\n\n* 双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。\n\n* dblwr后缀文件\n\n\n\n##### 7.Redo Log\n\n* 重做日志，是用来实现事务的持久性。该日志文件由两部分组成：\n  * 重做日志缓冲(redo log buffer），在内存中\n  * 重做日志文件（redo log）在磁盘中。\n\n* 当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。\n\n* 以循环方式写入重做日志，涉及两个文件ib_logfile0和ib_logfile1\n\n\n\n#### 3.后台线程\n\n##### 1.Master Thread\n\n* 核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。\n\n\n\n##### 2.IO Thread\n\n* 在InnoDB存储引擎中大量使用了AIO来处理IO请求，这样可以极大地提高数据库的性能，而IO Thread主要负素这些IO请求的回调。\n\n\n\n| 线程类型             | 默认个数 | 职责                         |\n| -------------------- | -------- | ---------------------------- |\n| Read thread          | 4        | 负责读操作                   |\n| Write thread         | 4        | 负责写操作                   |\n| Log thread           | 1        | 负责将日志缓冲区刷新到磁盘   |\n| Insert buffer thread | 1        | 负责将写缓冲区内容刷新到磁盘 |\n\n\n\n##### 3.Purge Thread\n\n* 主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收\n\n\n\n##### 4.Page Cleaner Thread\n\n* 协助Master Thread刷新脏页到磁盘的线程，它可以减轻Master Thread的工作压力，减少阻塞\n\n\n\n#### 4.总结\n\n* 业务操作时直接操作缓冲区中的数据，缓冲区中没有数据时，将磁盘中的数据加载回来再存储到缓冲区中，缓冲区中的数据再以一定的频率，通过后台线程刷新到磁盘中，在磁盘中进行永久化保留\n\n\n\n### 3.事务原理\n\n#### 1.概述\n\n* 事务有四个特性：\n  * 原子性\n  * 一致性\n  * 隔离性\n  * 持久性\n\n* 其中原子性，一致性，持久性由redo log和undo log这两份日志来保证\n* 隔离性则由锁机制和MVCC多版本并发控制来实现\n\n\n\n#### 2.redo log\n\n* 重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。\n* 该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。\n\n* 这种先写日志再将脏页中的数据刷新到磁盘的机制称为WAL(Write-Ahead-Logging)\n\n* 保证了事务的持久性\n\n\n\n#### 3.undo log\n\n* 回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和 MVCC(多版本并发控制)。\n* undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录（updata之前的数据）。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。\n* 保证了事务的原子性\n* Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。\n* Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。\n\n\n\n### 4.MVCC\n\n#### 1.基本概念\n\n##### 1.当前读\n\n* 读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于日常操作，如select...lock in share mode（共享锁），select ...for update，update，insert，delete（排他锁）都是一种当前读\n\n\n\n##### 2.快照读\n\n* 简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。\n* Read Committed：每次select，都生成一个快照读。\n* Repeatable Read：开启事务后第一个select语句才是快照读的地方。\n* Serializable：快照读会退化为当前读。\n\n\n\n##### 3.MVCC\n\n* 全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现\n* MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。\n\n\n\n#### 2.实现原理\n\n##### 1.隐藏字段\n\n| 隐藏字段    | 含义                                                         |\n| ----------- | ------------------------------------------------------------ |\n| DB_TRX_ID   | 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID |\n| DB_ROLL_PTR | 回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本 |\n| DB_ROW_ID   | 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段         |\n\n\n\n##### 2.undo log\n\n* 回滚日志，在insert、 update、delete的时候产生的便于数据回滚的日志。\n  * 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。\n  * 而update、delete的时候，产生的undo log不仅在回滚时需要，在快照读时也需要，不会立即被删除。\n\n\n\n* undo log版本链\n* 不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录\n* DB_ROLL_PTR指向上一个修改的记录\n\n\n\n##### 3.readview\n\n* readview（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交）id\n* readview中包含四个核心字段：\n\n| 字段           | 含义                                                 |\n| -------------- | ---------------------------------------------------- |\n| m_ids          | 当前活跃的事务id集合                                 |\n| min_trx_id     | 最小活跃事务id                                       |\n| max_trx_id     | 预分配事务id，当前最大事务id+1（因为事务id是自增的） |\n| creator_trx_id | readview创建者的事务id                               |\n\n\n\n* 版本链数据访问规则\n  * trx_id==creator_trx_id？可以访问该版本\n    * 说明数据是当前这个事务更改的\n  * trx_id<min_trx_id？可以访问该版本\n    * 说明数据已经提交了\n  * trx_id>max_trx_id？不可以访问该版本\n    * 说明该事务是再readview生成后才开启\n  * min_trx_id<=trx_id<=max_trx_id？如果trx_id**不在** m_ids中是可以访问该版本的\n    * 说明数据已经提交\n\n\\# trx_id：代表undo log中每一条数据的当前事务id\n\n\\# 从最新的undo log记录，逐条数据进行比对，直到查找到符合规则的记录返回\n\n\n\n* 不同的隔离级别，生成readview的时机不同\n  * rc：在事务每一次执行快照读时生成readview\n  * rr：仅在事务中第一次执行快照读时生成readview，后续复用该readview\n\n\n\n## 10.MySQL管理\n\n### 1.系统数据库\n\n* 在MySQL数据库安装完后，自带了四个数据库\n\n| 数据库             | 含义                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| mysql              | 存储MySQL服务器正常运行所需要的各种信息（时区，主从，用户，权限） |\n| information_schema | 提供了访问数据库元数据的各种表和视图，包含数据库，表，字段类型及访问权限等 |\n| performance_schema | 为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数 |\n| sys                | 包含了一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图 |\n\n\n\n### 2.常用工具\n\n#### 1.mysql\n\n* mysql的客户端工具\n\n* 语法：\n\n```shell\n  mysql 选项 数据库\n```\n\n* 选项：\n\n  * -u，指定用户名\n\n  * -p，指定密码\n\n  * -h，指定服务器IP或域名\n\n  * -P，指定连接端口\n\n  * -e，执行SQL语句并退出\n\n    * -e这个选项可以在MySQL客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式较为方便\n\n    * 例如：\n\n```shell\n      mysql -uroot -p密码 数据库名 -e'sql语句'\n```\n\n​      \n\n#### 2.mysqladmin\n\n* mysqladmin是一个执行管理操作的客户端程序，可以用它来检查服务器的配置和当前状态，创建并删除数据库等\n\n* 例如：\n\n```shell\n  mysqladmin -uroot -p密码 drop 数据库名\n```\n\n```shell\n  mysqladmin -uroot -p密码 version\n```\n\n  \n\n* 可以通过帮助文档查看选项：\n\n```sehll\n  mysqladmin --help\n```\n\n  \n\n#### 3.mysqlbinlog\n\n* 由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog日志管理工具\n\n* 语法\n\n```shell\n  mysqlbinlog 选项 binlog文件名1 binlog文件名2 ...\n```\n\n* 选项：\n\n  * -d，指定数据库名称，只列出指定的数据库相关操作\n  * -o，忽略掉日志中的前n行命令\n  * -r，将输出的文本格式日志输出到指定文件中\n  * -s，显示简单格式，省略掉一些信息\n  * --start-datetime=起始日期 --stop-datetime=截止日期，指定日期间隔内的所有日志\n  * --start-positon=日志起始位置 --stop-position=日志截止位置，指定位置间隔内的所有日志\n\n\n\n#### 4.mysqlshow\n\n* mysqlshow客户端对象查找工具，用来快速查找存在哪些数据库，数据库中的表，表中的列或者索引\n\n* 语法：\n\n```shell\n  mysqlshow 选项 数据库名称 表名称 字段名称\n```\n\n* 选项：\n\n  * --count，显示数据库及表的统计信息（数据库，表均可不指定）\n  * -i，显示指定数据库或者指定表的状态信息\n\n* 例如：\n\n```shell\n  mysqlshow -uroot -p密码 --count\n```\n\n\\# 查询每个数据库的表的数量及表中记录的数量\n\n\n\n```shell\n  mysqlshow -uroot -p密码 数据库名 --count\n```\n\n\\# 查询指定数据库中每个表中的字段数及行数\n\n\n\n```shell\n  mysqlshow -uroot -p密码 数据库名 表名 --count\n```\n\n\\# 查询指定数据库中指定表的详细情况\n\n\n\n#### 5.mysqldump\n\n* mysqldump客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句\n\n* 语法：\n\n```shell\n  mysqldump 选项 数据库名 表名\n```\n\n```shell\n  mysqldump 选项 --database 数据库名1 数据库名2 ...\n```\n\n  或\n\n```shell\n  mysqldump 选项 -B 数据库名1 数据库名2 ...\n```\n\n```shell\n  mysqldump 选项 --all-databases\n```\n\n  或\n\n```shell\n  mysqldump 选项 -A\n```\n\n\\# 后面加**> 文件名.sql** 来指定保存到哪个文件\n\n* 选项：\n\n  * 连接选项：\n\n    * -u，指定用户名\n\n    * -p，指定密码\n    * -h，指定服务器IP或域名\n    * -P，指定连接端口\n\n  * 输出选项：\n\n    * --add-drop-database，在每个数据库创建语句前加上drop database语句\n    * --add-drop-table，在每个表创建语句前加上drop table语句，默认开启；不开启（--skip-add-drop-table）\n    * -n，不包含数据库的创建语句\n    * -t，不包含数据表的创建语句\n    * -d，不包含数据\n    * -T，自动生成两个文件：\n      * .sql后缀文件，创建表结构的语句\n      * .txt后缀文件，数据文件\n\n\n\n#### 6.mysqlimport/source\n\n* mysqlimport是客户端数据导入工具，用来导入mysqldump加-T参数后导出的文本文件\n\n* 语法：\n\n```shell\n  mysqlimport 选项 数据库名 文件位置\n```\n\n* 例如：\n\n```shell\n  mysqlimport -uroot -p密码 数据库名 文件目录/文件名.txt\n```\n\n\n\n* 如果需要导入sql文件，可以使用mysql中的source指令\n\n* 语法：\n\n```shell\n  source /root/文件名.sql\n```\n\n","tags":["MySQL"]},{"title":"MySQL基础","url":"/2025/08/27/MySQL基础笔记/","content":"\n# MySQL基础\n\n## 1. 启动和关闭\n\n### 1.cmd\n\n* win加r进入运行输入cmd，ctrl加shift加enter以管理员模式运行\n\n  ```cmd\n  net start mysql80\n  ```\n\n   其中**mysql80** 为服务名，同样以\n\n  ```cmd\n  net stop mysql80\n  ```\n\n  结束运行。\n\n\n\n### 2.服务\n\n* win加r进入运行输入**services.msc** ，进入后找到**MySQL80** 右键运行或停止。\n\n\n\n## 2. 客户端连接\n\n### 1.MySQL提供的工具\n\n* 进入后直接输入密码连接。\n\n\n\n### 2.cmd\n\n* win加r进入运行输入cmd，ctrl加shift加enter以管理员模式运行，（这里已经将mysql添加到环境变量，可以在任意路径下运行）输入\n\n  ```cmd\n  mysql -h 127.0.0.1 -P 3306 -u root -p\n  ```\n\n  ，其中-h后面跟指定地址，-**P** （大写）后跟指定端口，（这两个可以省略），-u后跟指定用户，以root用户进行连接，-p指定密码。\n\n\n\n## 3. 数据库概念及模型\n\n### 1.概念\n\n* 关系型数据库（RDBMS)\n  * 由二维表组成，以关系型模型为基础      \n* 使用表存储数据，格式统一，便于维护\n* 使用SQL语句进行操作\n\n\n\n### 2.数据模型\n\n1. 客户端连接MySQL的数据库管理系统DBMS\n\n2. 使用SQL语句通过数据库管理系统来创建数据库\n\n3. 使用SQL语句在指定的数据库中创建多张表\n\n4. 单个数据库服务可以创建多个数据库\n\n5. 在表中存储数据\n\n   \n\n## 4.SQL语句\n\n### 1.通用语法\n\n* 可以单行或多行书写，和c一样以分号结束\n* 语句中可以用空格和缩进使其美观且不影响\n* SQL语句不区分大小写，关键字建议用大写\n* 注释\n  * 单行：-- 或  \\# \n  * 多行：/*     */（同c）\n\n\n\n### 2.SQL分类\n\n#### 1.DDL 数据定义语言，用来定义数据库对象（数据库，表，字段）\n\n##### 1.数据库操作\n\n1.查询\n\n* 查询所有数据库 \n\n  ```sql\n  show databases；\n  ```\n\n\n\n\n* 查询当前所处数据库\n\n  ```sql\n  select database();\n  ```\n\n\n\n2.创建\n\n```sql\n  create database (if not exists #数据库不存在时则创建，存在时无报错) 数据库名称 （default charset 字符集 #例如utf8)  (collate 排序规则) ；\n```\n\n  \n\n3.删除\n\n```sql\n  drop database（if exists）数据库名；\n```\n\n  \n\n4.使用\n\n```sql\n  use 数据库名；\n```\n\n#进入一个数据库\n\n\n\n##### 2.表操作\n\n###### 1.查询\n\n1.查询**当前** 数据库中所有表（需要先进入一个数据库）\n\n```sql\n  show tables；\n```\n\n  \n\n2.查询表结构\n\n```sql\n  desc 表名；\n```\n\n  \n\n3.查询指定表的建表语句\n\n```sql\n  show create table 表名；\n```\n\n  \n\n\n\n###### 2. 创建\n\n```sql\n  create tables 表名(\n  \n  \t字段1 字段1的类型（comment 字段1的注释）,      #注意逗号\n  \n  \t字段2 字段2的类型（comment 字段2的注释）,\n  \n  \t........\n  \n  )（comment 表注释）；\n```\n\n  \n\n###### 3.修改\n\n1.添加\n\n```sql\n  alter table 表名 add 字段名 类型（长度） （comment 注释）（约束）;\n```\n\n  \n\n2.修改数据类型\n\n```sql\n  alter table 表名 modify 字段名 新数据类型（长度）;\n```\n\n  \n\n3.修改字段名和字段类型\n\n```sql\n  alter table 表名 change 旧字段名 新字段名 类型(长度) （comment 注释）（约束）;\n```\n\n  \n\n4.删除字段\n\n```sql\n  alter table 表名 drop 字段名;\n```\n\n  \n\n5.修改表名\n\n```sql\n  alter table 表名 remane to 新表名；\n```\n\n  \n\n###### 4.删除\n\n1.删除表\n\n```sql\n  drop table （if exists） 表名；\n```\n\n  \n\n2.删除指定表，并重新创建该表 （保留表结构，但是其中数据删除）\n\n```sql\n  truncate table 表名；\n```\n\n  \n\n##### 3.数据类型\n\n###### 1.数值类型\n\n| 类型                                                         | 大小                                                         | 有符号（signed）范围     | 无符号（unsigned）范围 |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------ | ---------------------- |\n| **tinyint**                                                  | 1byte                                                        | (-128,127)               | (0,255)                |\n| \\# **适用例如年龄 age TINYINT UNSIGNED (因为年龄只为正整数，所以用无符号的TINYINT型)** | \\# ** 如果储存的是01，那么最终查询出来的也是1，只有用字符串‘01’，最后查询出来的才是01** |                          |                        |\n| smallint                                                     | 2bytes                                                       | (-32768,32767)           | (0,65535)              |\n| mediumint                                                    | 3bytes                                                       | (-8388608,8388607)       | (0,16777215)           |\n| int或integer                                                 | 4bytes                                                       | (-2147483648,2147483647) | (0,4294967295)         |\n| bigint                                                       | 8bytes                                                       | (-2^63,(2^63)-1)         | (0,(2^64)-1)           |\n| **float**                                                    | 4bytes                                                       |                          |                        |\n| \\# **与double相比较内存小运算快**                            |                                                              |                          |                        |\n| **double**                                                   | 8bytes                                                       |                          |                        |\n| \\# **适用例如分数(一百分制)   score double(4,1) 但是更适合用float** |                                                              |                          |                        |\n| decimal                                                      | 依赖于M(精度)和D(标度)的值                                   |                          |                        |\n| \\# **精度即为整个数的位数，标度为小数点位数，例如256.13精度为5，标度为2** |                                                              |                          |                        |\n| \\# **float是单精度浮点数  double是双精度浮点数 decimal是以字符串形式储存的精确小数** |                                                              |                          |                        |\n| \\#**float 和 double都是二进制近似计算，计算可能有舍入误差，且有精度范围，但decimal可自定义精度精确小数，且为十进制计算完全精准，适用于财务货币等精确计算** |                                                              |                          |                        |\n\n\n\n###### 2.字符串类型\n\n| 类型                                                         | 大小          | 描述               |\n| ------------------------------------------------------------ | ------------- | ------------------ |\n| **char**                                                     | 0-255 bytes   | 定长** 字符串       |\n| \\# **char(10)数字为储存的最大字符数，存储十以内的字符都占用十个字符，未占用的用空格补位，如果删除所有字符串即用update修改值为‘ ’空字符串，显示会是空字符串，而不是null** |               |                    |\n| \\# **varchar(10)会根据存储内容计算所要空间，因为要计算所以性能要比char差，但是存储空间利用率就高** |               |                    |\n| **varchar**                                                  | 0-65536 bytes | ** 变长**字符串     |\n| tinyblob                                                     | 0-255 bytes   | 二进制数据         |\n| tinytext                                                     | 0-255 bytes   | 短文本字符串       |\n| blob                                                         | 0-65535 bytes | 二进制长文本       |\n| text                                                         | 0-65535 bytes | 长文本             |\n| mediumblob                                                   |               | 二进制中等长度文本 |\n| mediumtext                                                   |               | 中等长度文本       |\n| longblob                                                     |               | 二进制极大文本     |\n| longtext                                                     |               | 极大文本           |\n\n\n\n###### 6.日期类型\n\n| 类型                            | 大小 | 范围                                     | 格式                |\n| ------------------------------- | ---- | ---------------------------------------- | ------------------- |\n| **date**                        | 3    | 1000-01-01至9999-12-31                   | YYYY-MM-DD          |\n| \\# **日期值**                   |      |                                          |                     |\n| time                            | 3    | -838:59:59至838:59:59                    | HH:MM:SS            |\n| \\# **时间值或持续时间**         |      |                                          |                     |\n| year                            | 1    | 1901至2155                               | YYYY                |\n| \\# **年份值**                   |      |                                          |                     |\n| datetime                        | 8    | 1000-01-01 00:00:00至9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS |\n| \\# **混合日期和时间值**         |      |                                          |                     |\n| timestamp                       | 4    | 1970-01-01 00:00:01至2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS |\n| \\# **混合日期和时间值，时间戳** |      | \\# ** 这个2038问题是时间戳导致的问题**    |                     |\n\n\n\n#### 2.DML 数据操作语言，用来对数据库中的数据进行增删改\n\n##### 1.添加数据\n\n###### 1.给指定字段添加数据\n\n```sql\n  insert into 表名 字段1，字段2，....... values 值1，值2，........;\n```\n\n\\# 如果值是字符串或日期数据类型，则要加引号\n\n\n\n###### 2.给全部字段添加数据\n\n```sql\n  insert into 表名 values 值1，值2，........;\n```\n\n\\#即值1对应字段1，值2对应字段2，.....\n\n###### 3.批量添加数据\n\n```sql\n  insert into 表名 字段1，字段2，....... values 值1，值2，........，值1，值2，........，值1，值2，........;\n```\n```sql\n  insert into 表名 values  值1，值2，........，值1，值2，........，值1，值2，........;\n```\n\n   \n\n###### 2.修改数据\n\n```sql\n  update 表名 set 字段名1=值1,字段名2=值2,.........（where 条件）;\n```\n* 这里的条件就是把某几个符合这个条件的数据修改，例如修改id为1的这一条数据的name，\n\n  ```sql\n  update 表名 set name=值1\n  ```\n\n   那么所有id为1的数据中的name都变为值1\n* 如果不加where 条件则修改所有的name都变为值1，会警告\n* 同样如果值是字符串或日期数据类型，则要加引号\n\n\n\n###### 3.删除数据\n\n```sql\n  delete from 表名 （where 条件）；\n```\n* 同样如果不加条件则删除所有数据\n* 删除的不是某个字段而是整条数据\n* 如果要删除某个字段的值则是要用**update** 来修改，字段=null\n\n\n\n#### 3.DQL 数据查询语言，用来查询数据库中表的记录\n\n##### 1.语法\n\n* **select** 字段列表\n* **from** 表名列表\n* **where** 条件列表\n* **group by** 分组字段列表\n* **having** 分组后条件列表\n* **order by** 排序字段列表\n* **limit** 分页参数\n\n\n\n##### 2.基本查询\n\n###### 1.查询多个字段\n\n```sql\n  select 字段1 ，字段2，字段3,........from 表名；\n```\n\n\\#记得加逗号\n\n```sql\n  select * from 表名；\n```\n\n \\#  *指查询返回所有字段，尽量直接写出所有字段，提高可读性\n\n\n\n###### 2.设置别名\n\n```sql\n  select 字段1 as 别名1，字段2 as 别名2，........from 表名；\n```\n\n\\# 这里as可以省略\n\n* 表名后面也可以设置别名\n\n\n\n###### 3.去除重复记录\n\n```sql\n  select distinct 字段列表 from 表名；\n```\n\n\\# 这里字段后面也可以加as来设置别名，同样可以省略\n\n* 纯数字别名必须加引号（单双都可以）但是最终查询出来的别名还是‘数字’\n\n\n\n##### 3.条件查询\n\n###### 1.语法\n\n```sql\n  select 字段列表 from 表名 where 条件列表；\n```\n* 查询出来的符合条件的字段列表，如果用*来代替则查询出来的是符合条件的一整条数据\n\n\n\n###### 2.条件\n\n| 比较运算符                                                   | 功能                                       | 逻辑运算符 | 功能                     |\n| ------------------------------------------------------------ | ------------------------------------------ | ---------- | ------------------------ |\n| \\>                                                           | 大于                                       | and 或 &&  | 并且（多个条件同时成立） |\n| \\>=                                                          | 大于等于                                   | or 或 \\|\\| | 或者（任一条件成立）     |\n| <                                                            | 小于                                       | not 或 !   | 非                       |\n| <=                                                           | 小于等于                                   |            |                          |\n| =                                                            | 等于                                       |            |                          |\n| <>或!=                                                       | 不等于                                     |            |                          |\n| between...and...                                             | 在某个范围内（包含最大和最小值）           |            |                          |\n| in(...)                                                      | 在in后跟的列表中的数值满足其一即可         |            |                          |\n| \\# **例如select * from  newwork where age in (12,18,20) ;即查询年龄为12，18，20的整条数据** |                                            |            |                          |\n| like 占位符                                                  | 模糊匹配（_匹配单个字符，%匹配任意个字符） |            |                          |\n| \\# **例如select * from  newwork where name like '** __**'；即查询名字为两个字符的整条数据，这里是两个下划线** |                                            |            |                          |\n| \\# **例如select * from  newwork where card_id like '%9';即查询身份证最后一位是9的整条数据** |                                            |            |                          |\n| \\# **也可以select * from  newwork where card_id like '%8_';即查询倒数第二位是8的整条数据** |                                            |            |                          |\n| is null                                                      | 字段为null                                 |            |                          |\n\n\n\n##### 4.分组查询\n\n###### 1.语法\n\n```sql\n  select 字段列表1，字段列表2，... from 表名 where 条件 group by 分组字段名1，字段名2,... having 分组后过滤条件\n```\n\n\n\n###### 2.where和having的区别\n\n* 执行时间：where在分组前使用，having在分组后使用对结果过滤\n* 判断条件：where的条件不允许使用聚合函数，having可以\n\n\\# 例如\n\n```sql\nselect gender,count(*) from newwork group by gender;\n```\n\n即统计所有数据中每种性别的个数，同时会显示性别\n\n\n\n\\# 例如\n\n```sql\nselect age from newwork where name like '___' group by age;\n```\n\n即先筛选名字为三个字符串的，再按年龄分组\n\n\n\n\\# 例如\n\n```sql\nselect age,count(age) from newwork where card_id like '%9' group by age having count(age)<5;\n```\n\n即分组前先查询身份证最后一位是9的，然后按年龄分组，最后having统计出所有年龄中相同年龄个数小于5个的个数\n\n\\# 一般查询的字段列表是聚合函数或者分组字段，查询其他会报错，禁用报错后也只会显示该类数据的第一个\n\n\\#这里同样可以设置别名\n\n\n\n##### 5.排序查询\n\n###### 1.语法\n\n```sql\n  select 字段列表 from 表名 order by 字段1 排序方式，字段2 排序方式；\n```\n\n\n\n###### 2.排序方式\n\n* asc：升序（可省略）\n* desc：降序\n\n\\# 例如\n\n```sql\nselect * from newwork order by  age asc,id desc ;\n```\n\n即所有数据先按年龄升序排序，有相同年龄的则按id数字降序排序\n\n\n\n###### 3.注意\n\n* 多字段排序时，，当第一个字段值相同时，才会根据第二个字段进行排序\n\n\n\n##### 6.分页查询\n\n###### 1.语法\n\n```sql\n  select 字段列表 from 表名 limit 起始索引，查询记录数；\n```\n\n  \n\n###### 2.注意\n\n* 起始索引从0开始，和数组一样，所以起始索引=（查询页码-1）* 每页记录数\n* 不同数据库的分页查询不同，MySQL中是limit\n* 起始索引为0，即查询第一页时可以省略起始索引\n* 前面可以加where，order by，group by 。limit是再整个语句的最后使用\n\n\\# 例如\n\n```sql\nselect * from newwork limit 3;\n```\n\n即从第一页查询所有数据，每页3条数据\n\n\n\n\\# 例如\n\n```sql\nselect * from newwork limit 5,5;\n```\n\n即每页5条数据，从第二页开始查询\n\n\n\n##### 7.执行顺序\n\n* 1.from\n*  2.where \n* 3.group by \n* 4.having \n* 5.select  \n* 6.order by \n* 7.limit\n\n\\# 需要注意执行顺序，再设置别名，才能正常使用别名\n\n\n\n#### 4.DCL 数据控制语言，用来创建数据库用户，控制访问权限\n\n##### 1.管理用户\n\n###### 1.查询用户\n\n```sql\n  use mysql； #用户表存放在MySQL的mysql数据库中，所以要先进入这个数据库 \n  select * from user\n```\n\n  \n\n###### 2.创建用户\n\n```sql\n  create user ‘用户名’@‘主机名’ identified by ‘密码’；\n```\n\n  \n\n###### 3.修改用户密码\n\n```sql\n  alter user ‘用户名’@‘主机名’ identified with mysql_native_password by ‘新密码’；\n```\n\n   \n\n###### 4.删除用户\n\n```sql\n  drop user ‘用户名’@‘主机名’；\n```\n\n\\# 主机名有localhost即本机，%即任意主机都可以访问此数据库\n\n\n\n##### 2.权限控制\n\n| 权限                | 说明               |\n| ------------------- | ------------------ |\n| all，all privileges | 所有权限           |\n| select              | 查询数据           |\n| insert              | 插入数据           |\n| update              | 修改数据           |\n| delete              | 删除数据           |\n| alter               | 修改表             |\n| drop                | 删除数据库/表/视图 |\n| create              | 创建数据库/表      |\n\n\n\n###### 1.查询权限\n\n```sql\n  show grants for ‘用户名’@‘主机名’；\n```\n\n  \n\n###### 2.授予权限\n\n```sql\n  grant 权限列表 on 数据库名.表名 to ‘用户名’@‘主机名’；\n```\n\n  \n\n###### 3.撤销权限\n\n```sql\n  revoke 权限列表 on 数据库.表名 from ‘用户名’@‘主机名’；\n```\n\n  \n\n###### 4.注意\n\n* 数据库和表名可以为*\n* 权限列表可以为多个权限，之间要加，隔开\n\n\n\n## 5.函数\n\n### 1.聚合函数\n\n* 将一列数据作为一个整体，进行纵向计算\n\n#### 1.常见聚合函数\n\n| 函数                | 功能     |\n| ------------------- | -------- |\n| count               | 统计数量 |\n| max                 | 最大值   |\n| min                 | 最小值   |\n| avg                 | 平均值   |\n| sum                 | 求和     |\n| \\# null值不参与计算 |          |\n\n\n\n#### 2.语法\n\n```sql\n  select 聚合函数(字段列表)  from 表名 where 条件；\n```\n\n\\# 这里的括号和前面的聚合函数间不能有空格\n\n\n\n### 2.字符串函数\n\n#### 1.常见字符串函数\n\n| 函数                                                         | 功能                                                      |\n| ------------------------------------------------------------ | --------------------------------------------------------- |\n| concat(S1,S2,.....Sn)                                        | 字符串拼接，将括号里的拼接成一个字符串                    |\n| lower(str)                                                   | 将字符串str全部转为小写                                   |\n| upper(str)                                                   | 将字符串str全部转为大写                                   |\n| lpad(str,n,pad)                                              | 左填充，将字符串pad对str的左边进行填充，达到n个字符串长度 |\n| rpad(str,n,pad)                                              | 右填充，将字符串pad对str的右边进行填充，达到n个字符串长度 |\n| \\# n是指填充完的整个字符串为n个，当pad的长度大于n-原字符串长度时，只会填充pad的前n-原字符串长度个 |                                                           |\n| trim(str)                                                    | 去掉字符串头部和尾部的空格                                |\n| substring(str,start,len)                                     | 返回字符串str中从start位置起的len个长度的字符串           |\n| \\# start是数字索引，但是这里的索引是从1开始的                |                                                           |\n\n\n\n### 3.数值函数\n\n#### 1.常见数值函数\n\n| 函数                                                         | 功能                             |\n| ------------------------------------------------------------ | -------------------------------- |\n| ceil(x)                                                      | 向上取整                         |\n| floor(x)                                                     | 向下取整                         |\n| mod(x,y)                                                     | 返回x/y的模（余数）              |\n| rand()                                                       | 返回0-1内的随机数                |\n| \\# 例如**select lpad(round(rand()\\*1000000,0),6,0);** 可以用作生成随机六位数验证码，即先用rand随机出数字再乘1000000，再用round去掉小数，lpad在左边补0 |                                  |\n| round(x,y)                                                   | 求参数x的四舍五入值，保留y位小数 |\n| \\# 例如**select round(206.2658,2);** 返回的值就是206.27       |                                  |\n\n\n\n### 4.日期函数\n\n#### 1.常见日期函数\n\n| 函数                                                         | 功能                                               |\n| ------------------------------------------------------------ | -------------------------------------------------- |\n| curdate()                                                    | 返回当前日期                                       |\n| curtime()                                                    | 返回当前时间                                       |\n| now()                                                        | 返回当前日期和时间                                 |\n| year(date)                                                   | 获取指定date的年份                                 |\n| \\# 例如**select  year(now());**                              |                                                    |\n| month(date)                                                  | 获取指定date的月份                                 |\n| day(date)                                                    | 获取指定date的日期                                 |\n| date_add(date,interval expr type)                            | 返回一个日期或时间值加上一个时间间隔expr后的时间值 |\n| \\# 例如**select date_add(now(),interval 70 day );** 即当前时间向后推70天的日期和时间，这里interval是固定的，expr是间隔，type是时间类型 |                                                    |\n| datediff(date1,date2)                                        | 返回起始时间date1和结束时间date2之间的天数         |\n| \\# 返回的时间=date1-date2，所以可能会是负数                  |                                                    |\n| \\# 例如**select name,datediff(curdate(),enterdate) as 'enterdate' from newwork order by  enterdate desc;** 即计算入职天数并设置其别名为enterdate，再按降序排序 |                                                    |\n\n\n\n### 5.流程函数\n\n#### 1.常见的流程函数\n\n| 函数                                                         | 功能                                         |\n| ------------------------------------------------------------ | -------------------------------------------- |\n| if(value,t,f)                                                | 如果value为true则返回t，否则返回f            |\n| ifnull(value1,value2)                                        | 如果value1不为空，返回value1，否则value2     |\n| case when val1 then res1 else default end                    | 如果val1为true，返回res1，...否则返回default |\n| \\# 例如**select age,name,case when age <18 then 'y' when age>18 then 'a' else 'e' end from newwork;** 即查询年龄在十八以下的为y，十八以上为a，其他为e 。同理可以用于判断成绩优良 |                                              |\n| case expr when val1 then res1 else default end               | 如果expr的值=val1，返回res1，否则default     |\n| \\# 例如**select name, age，case age when 20 then 't' when 19 then 'n' end from newwork;** 即查询年龄为20和19的分别返回t和n |                                              |\n\n\n\n## 6.约束\n\n### 1.概述\n\n#### 1.概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据\n\n\n\n#### 2.目的：保证数据库中的数据的正确有效和完整性\n\n\n\n#### 3.分类：\n\n| 约束                      | 描述                                                     | 关键字      |\n| ------------------------- | -------------------------------------------------------- | ----------- |\n| 非空约束                  | 限制改字段的数据不能为null                               | not null    |\n| 唯一约束                  | 保证该字段的所有数据都是唯一，不重复的                   | unique      |\n| 主约束条件                | 主键是一行数据的唯一标识，要求非空且唯一                 | primary key |\n| 默认约束条件              | 保存数据时，如果未指定该字段的值，则采用默认值           | default     |\n| 检查约束                  | 保证字段值满足某一个条件                                 | check       |\n| \\# 8.0.16后才支持检查约束 |                                                          |             |\n| 外键约束                  | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | foreign key |\n\n\n\n### 2.示例\n\n| 字段名 | 字段类型      | 约束条件                  | 约束关键字                  |\n| ------ | ------------- | ------------------------- | --------------------------- |\n| id     | int           | 主键，并且主动增长        | primary key，auto_increment |\n| name   | varchar（10） | 不为空，并且唯一          | not null，unique            |\n| age    | int           | 大于0，并且小于等于120    | check                       |\n| status | char（1）     | 如果没有指定该值，默认为1 | default                     |\n| gender | char（1）     | 无                        |                             |\n\n\n\n```sql\ncreate table user1(\n        id int primary key auto_increment comment '主键',\n        name varchar(10) not null unique ,\n        age int check ( age>0 && age<=120 ),\n        status char(1) default 1,\n        gender char(1)\n)comment '用于学习约束的用户表';\n```\n\n* 然后用 **insert** 向表中插入数据\n* 注意：如果某一条插入的数据违反了约束那么是不会创建该数据的，但是会向数据库申请一个主键，所以会导致下一次创建数据的时候即使没有违反约束，也会跳过之前没有创建的数据的主键，产生跳号的现象\n\n* 但是主键最核心的是其唯一性，而不是连续性，部分数据库中可以手动填空\n\n\n\n### 3.外键约束\n\n* 概念：外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性\n\n\n\n#### 1.添加外键\n\n```sql\ncreate table 表名(\n\n\t字段名 数据类型，\n\n\t.......\t\n\n\tconstraint 外键名 foreign key （外键字段名） references 主表（主表列名）\n\n\t);\n\n```\n\n或\n\n```sql\nalter table 表名 add constraint 外键名 foreign key （外键字段名） references 主表（主表列名）\n```\n\n\\# 例如\n\n```sql\nalter table user1 add constraint fk_user1_dept_id foreign key (id_for_connent) references dept (id);\n```\n\n即将表user1中的id_for_connent与表dept中的id关联并把外键名设置为fk_user1_dept_id\n\n* 如果删除dept中的数据则会报错，以此来保证数据的完整性\n\n\n\n#### 2.删除外键\n\n```sql\n  alter table 表名 drop foreign key 外键名；\n```\n\n\n\n#### 3.删除/更新行为\n\n| 行为                      | 说明                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| no action                 | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，有则不允许删除/更新 |\n| restrict                  | 同上（默认的）                                               |\n| cascade                   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，有则删除/更新子表中的记录 |\n| set null                  | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，有则设置子表中该外键为null |\n| \\# 前提是该外键允许取null |                                                              |\n| set default               | 父表有变更时，子表将外键列设置成一个默认的值（MySQL的lnnodb引擎不支持） |\n\n\n\n```sql\n  alter table 表名 add constraint 外键名 foreign key （外键字段） references 主表名（主表字段名） on update cascade on delete cascade；\n```\n\n\\#例如\n\n```sql\nalter table user1 add constraint fk_user1_name_dept_id foreign key (id_for_connent) references dept (id) on UPDATE cascade on delete cascade ;\n```\n\n即添加一个外键，并且设置为更新/删除时cascade级联，即对应的更新/删除。其中的cascade可以更换成其他行为\n\n* 这个语法不是直接修改而是创建外键并设定了属性\n\n\n\n## 7.多表查询\n\n### 1.多表关系\n\n#### 1.一对多（多对一）\n\n* 例如：一个部门可以有多个员工，但是一个员工只能对应一个部门、\n* 实现：在多的一方建立外键，指向少的一方的主键\n\n\n\n#### 2.多对多\n\n* 例如：一个学生可以选择多个课程，一门课程可以被多个学生选择\n\n```sql\nselect s.name,s.no,c.name from student.s,student_course sc,course c where s.id=sc.studentid and sc.courseid=c.id;\n```\n\n* 实现：建立第三张中间表，中间表中要有两个外键，分别连接另外两张表的主键\n\n\n\n#### 3.一对一\n\n* 例如：每个用户对应其用户信息\n* 实现：**在任意一表中加入外键，再关联到另一个表的主键** ，但是外键要设置约束条件为唯一unique\n\n\n\n### 2.多表查询概述\n\n* 概述：指从多张表中查询数据\n\n* **笛卡尔积** ：笛卡尔乘积指的是，两个集合的所有组合情况，如果直接用\n\n  ```sql\n  select * from user1,dept;\n  ```\n\n  来查询两张表就会出现笛卡尔积的情况，所以正常查询时可以使用where语句根据具体情况来消除无效的笛卡尔积\n\n    \n\n* #### 分类\n\n* 连接查询\n\n  * 内连接：相当于查询A,B交集部分的数据\n  * 外连接：\n    * 左外连接：查询**左表** 所有数据，以及两张表交集部分数据\n    * 右外连接：查询**右表** 所有数据，以及两张表交集部分数据\n\n  * 自连接：当前表与自身的连接查询，自连接必须使用表的别名\n\n* 子查询\n\n\n\n### 3.内连接\n\n#### 1.隐式内连接\n\n```sql\n  select 字段列表 from 表1，表2 where 条件...;\n```\n\n\\#例如\n\n```sql\nselect u.name,d.name from user1 u，dept d where u.id_for_connent=d.id;\n```\n\n\\#注意字段名前面要用表名来限定是哪个表的字段\n\n\\#可以设置别名，但是设置别名后就不能再使用表名\n\n\n\n#### 2.显式内连接\n\n```sql\n  select 字段列表 from 表1 inner join 表2 on 连接条件....;\n```\n\n\\# inner可以省略\n\n\\# 相当于where换成on\n\n\\# 连接条件后面可以再加where条件\n\n\n\n### 4.外连接\n\n#### 1.左外连接\n\n```sql\n  select 字段列表 from 表1 left outer join 表2 on 条件...;\n```\n\n\\# outer可以省略\n\n\\# 查询的是左表即表1的所有数据，包含两个表的交集部分\n\n\\# 例如\n\n```sql\nselect u.*,d.name from user1 u left join dept d on u.id_for_connent=d.id;\n```\n\n这样即使user1中有部分数据没有与dept中的关联也可以被查询出来\n\n\n\n#### 2.右外连接\n\n```sql\n  select 字段列表 from 表1 right outer join 表2 on 条件...;\n```\n\n\\# outer可以省略\n\n\\# 查询的是右表即表2的所有数据，包含两个表的交集部分\n\n\\# 可以通过交换两个表名来实现右外连接和左外连接的转换，通常使用左外连接\n\n\n\n### 5.自连接\n\n```sql\n  select 字段列表 from 表1 别名1 join 表1 别名2 on 条件...;\n```\n\n* 自连接可以是内连接，也可以是外连接\n\n\\# 例如\n\n```sql\nselect u.name,u1.name from user1 u ，user u1 where u.manager_id=u1.id;\n```\n\n\\# 在一张公司员工表中manager_id表示某一员工的领导的id，这样可以查询出员工的领导是谁\n\n\\# 这里用的是内连接，这样就不会在员工那一栏显示领导，因为领导没有领导，可以用外连接，就能在员工栏显示出领导，领导栏就会显示null\n\n\\# 将一张表视为两张\n\n\n\n### 6.联合查询\n\n* 就是把多次查询的结果合并，形成一个新的查询结果集\n```sql\n  select 字段列表 from 表1...      #省略号中可以用where条件\n  union all      \t\t\t\t   #all可以省略，省略后会去除重复的数据\n  select 字段列表 from 表2...；    #省略号中可以用where条件\n```\n* **这是一个完整的语句可以将上下两个结果直接合并**\n\n\\# 注意：上下两个字段的列数和字段类型必须一致，否则会报错\n\n\n\n### 7.子查询\n\n* 概念：SQL语句中嵌套select语句，称为子查询（嵌套查询）\n\n* 例如\n\n  ```sql\n  select * from 表1 where column1=（select column1 from 表2）；\n  ```\n\n* 其中**select column1 from 表2** 就是子查询，其他的外部语句可以是insert/delete/select中任一\n\n* 根据子查询结果不同，可以分为\n\n  * 标量子查询（子查询结果为单个值）\n\n  * 列子查询（查询结果为一列）\n\n  * 行子查询（查询结果为一行）\n\n  * 表子查询（子查询结果为多行多列）\n\n    \n\n* 根据子查询位置不同，又分为\n  * where之后\n  * from之后\n  * select之后\n\n\n\n#### 1.标量子查询\n\n* 返回结果是单个值（数字，字符串，日期等）\n* 常用操作符：=,<>,>,>=,<，<=\n\n\\# 例如：需要查询销售部的员工信息\n\n* 第一步：查询销售部的id序号 \n\n  ```sql\n  select id from dept where name=‘销售部’；\n  ```\n\n  假设查询出来id=4\n* 第二步由id作为查询条件在另一张表查询 \n\n  ```sql\n  select * from user1 where id_for_connent=4;\n  ```\n\n  可得结果\n\n\\# 而标量子查询只需要一步\n\n```sql\n  select * from user1 where id_for_connent=(select id from dept where name=‘销售部’);\n```\n\n* 因为括号里查询出来的是单个值所以可以用标量子查询\n\n\\# 同样字符串和日期也可以用此方法来做\n\n\n\n#### 2.列子查询\n\n* 返回结果是一列（可以多行）\n* 常用操作符：\n\n| 操作符 | 描述                               |\n| ------ | ---------------------------------- |\n| in     | 在指定的集合范围内，多选一         |\n| not in | 不在指定的聚合范围内               |\n| any    | 子查询返回列表中有任意一个满足即可 |\n| some   | 与any等同                          |\n| all    | 子查询返回值的所有值都必须满足     |\n\n\n\n\\# 例如查询销售部和研发部的员工信息\n\n```sql\n  select * from user1 where id_for_connent in (select id from dept where name=‘销售部’ or ‘研发部’);\n```\n\n  \n\n\\# 例如要获取所有部门中工资大于研发部所有员工工资的员工信息\n\n* 第一步：先获取研发部的员工工资 \n\n  ```sql\n  select salary from user1 where id_for_connent=(select id from dept where name= ‘研发部);\n  ```\n\n* 第二步：在所有表中查询工资数值大于所有查询到的这些数值的员工信息 \n\n  ```sql\n  select * from user1 where salary> all(select salary from user1 where id_for_connent=(select id from dept where name= ‘研发部));\n  ```\n\n\n\n#### 3.行子查询\n\n* 返回结果是一行（可以多列）\n* 常用操作符：=，<>,in,not in\n\n\\# 例如：要查询和某个员工的工资和领导完全相同的其他员工的信息\n\n```sql\n  select * from user1 where (salary,manager)=(select salary，manager from user1 where name=‘员工1’）;\n```\n\n  \n\n#### 4.表子查询\n\n* 返回结果是多行多列\n* 常用操作符：in\n\n\\# 例如：要查询和某两个员工的工资和领导完全相同的其他员工的信息\n\n```sql\n  select * from user1 where (salary,manager) in (select salary，manager from user1 where name=‘员工1’ or name=‘员工2’）;\n```\n\n\n\n\\# 例如：要查询在2005-01-01后入职的员工的信息和其部门\n\n```sql\n  select u.*,d.* from(select * from user1 where enterdate>'2005-01-01') u left join dept d on u.id_for_connet=d.id;\n```\n\n\\# 这里将第一次查询出来的内容作为一张表放在from后面，再将这张表与部门表左外连接\n\n\n\n## 8.事务\n\n### 1.事务简介\n\n* 事务是一组操作的合集，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即操作同时成功或同时失败\n* 默认每一条语句都是一个事务，且自动提交\n\n\n\n### 2.事务操作\n\n#### 1.查看/设置事务提交方式\n\n##### 方法一：\n\n```sql\n  select @@autocommit；\n```\n\n\\# 查询出来为1则是自动提交，为0则是手动提交\n\n* **set @@autocommit=0；**\n\n\n\n##### 方法二：\n\n```sql\n  start transaction 或 begin \n```\n\n\\# 自动提交的情况下可以用这种方式，这条语句和下面要执行的语句一起运行\n\n\n\n#### 2.提交事务\n\n```sql\n  commit；\n```\n\n\\# 先运行需要执行的语句然后再运行commit\n\n\n\n#### 3.回滚事务\n\n```sql\n  rollback；\n```\n\n\\# 运行报错后不要提交，直接回滚\n\n\n\n### 3.事务四大特性\n\n* 原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败\n* 一致性：事务完成时，必须使所有数据都保持一致状态\n* 隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行\n\n\\# 即多个事务间互不干扰\n\n* 持续性：事务一旦提交或回滚，它对数据库中的数据的改变是永久的\n\n\n\n### 4.并发事务问题\n\n| 问题                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 脏读                                                         | 一个事务读到另一个事务还没有提交的数据                       |\n| 不可重复读                                                   | 一个事务先后读取到同一条记录，但两次读取的数据不同，称之为不可重复读 |\n| \\# 即在另一个事务提交的前后分别查询了这一条数据，**不可重复读的重点在于数据的修改** |                                                              |\n| 幻读                                                         | 一个事务按照条件查询数据时，没有对应的数据行，但在插入数据时，又发现这行数据已经存在 |\n| \\#即在另一个事务提交的前后分别查询和插入了数据，但是反复查询都显示没有数据，**幻读的重点在于数据的新增和删除** |                                                              |\n\n\n\n### 5.事务隔离级别\n\n| 隔离级别                                                     | 会出现的问题 | 脏读 | 不可重复读 | 幻读 |\n| ------------------------------------------------------------ | ------------ | ---- | ---------- | ---- |\n| read uncommitted                                             |              | √    | √          | √    |\n| read committed                                               |              | ⨉    | √          | √    |\n| repeatable read（默认）                                      |              | ⨉    | ⨉          | √    |\n| \\# 不可重复读的问题被解决，变为可重复读，正在执行的事务不会被其他正在执行的事务影响 |              |      |            |      |\n| serializable（串行化）                                       |              | ⨉    | ⨉          | ⨉    |\n| \\# 用了serializable后当第一个事务先执行时，第二个事务会被阻塞，cmd中回车后光标会一直闪烁直到第一个事务提交，才会执行第二个事务。 |              |      |            |      |\n| \\# 从上往下级别越高则数据安全性越高，性能越差                |              |      |            |      |\n\n\n\n* 查看事务隔离级别\n```sql\n  select @@transaction_isolation；\n```\n\n  \n\n* 设置事务隔离级别\n```sql\n  set session/global transaction isolation level read uncommitted/read committed/repeatable read/serializable；\n```\n\n\\# 其中session是会话级别即进当前客户端窗口，global则针对所有客户端窗口","tags":["MySQL"]},{"title":"小六壬起课器","url":"/2025/02/24/小六壬起课器/","content":"\n# 小六壬起课器.py\n\n## （仅起到起课作用）\n\n​\t小六壬，古代中国占卜法，古代主要用于军事韬略，尤以别名诸葛亮马前课著名。\n\n​\t在所有术数中时间都是首位，所以第一则是获取当前用户时间。在运行时可能会遇到用户输入各种类型的数据，所以使用try来运行可能出错的代码，并且在报错后循环让用户重新输入。\n\n```python\nwhile True: #无限循环\n   try: #尝试运行可能出错的代码\n      time=int(input(\"以24时制输入当地当前时:\")) #获取时间  \n   except (ValueError, TypeError): #数值错误和数值类型错误时的处理\n      print(\"错误,输入数字有误,例:当前13:11,则输入13\")\n      continue #跳过下面的循环，防止因为上面错误导致time没有获取数值而使下面的判断报错\n   if time in list10: #判断输入数字是否为0~23\n      break #正常则执行下面的代码\n   else: #不符合则提示并循环\n      print(\"错误,输入数字有误,例:当前13:11,则输入13\")\n```\n\n​\t小六壬中常见起课方式有日期起课以及随机数起课，在这里仅做了随机数起课。（后续可能增加以日期起课的选择）仍然使用try语句来处理可能遇到的输入数据类型错误，再将得到三个随机数储存。\n\n```python\nprint(\"输入心中立即想到的任意大小的正整数\")\nnumbers1 = [None, None, None]  # 用列表存储 x, y, z\nfor i in range(3): # 循环三次以获取三个数字\n    while True: #无限循环\n        try:\n            numbers1[i] = int(input(f\"请输入第 {i + 1} 个数字: \")) #使用f语句\n            if numbers1[i] <= 0:  # 检查输入的数字是否为正整数\n                print(\"输入数字有误，请输入正负整数\")\n            else:\n                break  # 如果输入有效，则退出当前的 while 循环\n        except (ValueError,TypeError):\n            print(\"输入数字有误，请输入正负整数\")\nx, y, z = numbers1 # 将输入的数字赋值给 x, y, z\n```\n\n​\t创建一个列表储存十二个时辰，由于一个时辰对应两个小时，所以列表中时辰储存两次，再将时间对应列表中的时辰，以便后续输出，以及字典的调用。\n\n```python\nlist1=['子','丑','丑','寅','寅','卯','卯','辰','辰','巳','巳','午','午','未','未','申','申','酉','酉','戌','戌','亥','亥','子'] #创建时辰列表\n```\n\n```python\ntime1 = list1[time] #将时间对应时辰\n```\n\n​\t再调用字典将时辰对应12小时制的数字。\n\n```python\ntime2 = dict1.get(time1,'无效值') #调用字典将时辰与数字对应，time1上不用加''\n```\n\n​\t相较于第一版，增加了活六神的功能,仅做展示。\n\n```python\ntime3 = time2%6 #对time2取余数，可知龙头宫位\nwhole = 6-time3 #得出青龙后还有几个元素作为整体\nelement=list11[:whole+1] #将青龙以及后面的元素作为整体\nif time3 == 1:\n   list12=list11\nelif time3 == 0:\n   list12=['朱雀','勾陈','白虎','玄武','腾蛇','青龙']\nelse:\n   list12=[x for x in list11 if x not in element]+element #先遍历列表8不属于整体的元素再加上整体中的元素生成新列表10\nx5,y5,z5 = list5[x1],list5[y1],list5[z1] #分别给三才赋值六神\nx6,y6,z6 = list12[x1],list12[y1],list12[z1] #分别给三才赋值活六神\nnumber1,number2,number3 = dict2.get(x3),dict2.get(y3),dict2.get(z3) #调用字典将五行与列表数字对应\nlist13,list14,list15=globals()[f'list{number1}'],globals()[f'list{number2}'],globals()[f'list{number3}'] #使用globals()作用于全局区别于locals()只能在一个函数局部内返回变量，生成三才对应的十二长生列表\n```\n\n​\t由于python自带的以及库中的居中对齐功能无法正常使用，为了美观增加了根据字数增加空格的函数。\n\n```python\ndef print_xyz(x,y,z): #封装成函数\n   x_len,y_len,z_len = len(x),len(y),len(z)\n   if x_len == 1 and y_len == 1 and z_len == 1:\n      print('', x, ' ', y, ' ', z)\n   elif x_len == 2 and y_len == 1 and z_len == 1:\n      print(x, '', y, ' ', z)\n   elif x_len == 2 and y_len == 2 and z_len == 1:\n      print(x, y, '', z)\n   elif x_len == 2 and y_len == 1 and z_len == 2:\n      print(x, '', y, '', z)\n   elif x_len == 1 and y_len == 2 and z_len == 1:\n      print('', x, '', y, '', z)\n   elif x_len == 1 and y_len == 2 and z_len == 2:\n      print('', x, '', y, z)\n   elif x_len == 1 and y_len == 1 and z_len == 2:\n      print('', x, ' ', y, '', z)\n   else:\n      print(x, y, z)\n\n```\n\n​\t以下是完整代码。\n\n```python\nlist1=['子','丑','丑','寅','寅','卯','卯','辰','辰','巳','巳','午','午','未','未','申','申','酉','酉','戌','戌','亥','亥','子'] #创建时辰列表\nlist2=['大安','留连','速喜','赤口','小吉','空亡'] #创建六宫列表\nlist3=['木','土','火','金','水','土'] #创建五行列表\nlist4=['东','四方','南','西','北','中央'] #创建方位列表\nlist5=['青龙','腾蛇','朱雀','白虎','玄武','勾陈'] #创建六神列表\nlist6=['沐浴','冠带','临官','帝旺','衰','死','病','墓','绝','胎','养','长生'] #创建木对应的十二长生列表\nlist7=['胎','养','长生','沐浴','冠带','临官','帝旺','衰','死','病','墓','绝'] #创建火对应的十二长生列表\nlist8=['死','病','墓','绝','胎','养','长生','沐浴','冠带','临官','帝旺','衰'] #创建金对应的十二长生列表\nlist9=['帝旺','衰','死','病','墓','绝','胎','养','长生','沐浴','冠带','临官'] #创建水，土对应的十二长生列表\nlist10=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23] #创建时间列表\nlist11=['青龙','朱雀','勾陈','白虎','玄武','腾蛇'] #创建活六神顺序列表\ndict1={'子': 1,'丑': 2,'寅': 3,'卯': 4,'辰': 5,'巳': 6,'午': 7,'未': 8,'申': 9,'酉': 10,'戌': 11,'亥': 12} #创建时辰字典\ndict2={'木':6,'火':7,'金':8,'水':9,'土':9}\nwhile True: #无限循环\n   try: #尝试运行可能出错的代码\n      time=int(input(\"以24时制输入当地当前时:\")) #获取时间  \n   except (ValueError, TypeError): #数值错误和数值类型错误时的处理\n      print(\"错误,输入数字有误,例:当前13:11,则输入13\")\n      continue #跳过下面的循环，防止因为上面错误导致time没有获取数值而使下面的判断报错\n   if time in list10: #判断输入数字是否为0~23\n      break #正常则执行下面的代码\n   else: #不符合则提示并循环\n      print(\"错误,输入数字有误,例:当前13:11,则输入13\")\nprint(\"输入心中立即想到的任意大小的正整数\")\nnumbers1 = [None, None, None]  # 用列表存储 x, y, z\nfor i in range(3): # 循环三次以获取三个数字\n    while True: #无限循环\n        try:\n            numbers1[i] = int(input(f\"请输入第 {i + 1} 个数字: \")) #使用f语句\n            if numbers1[i] <= 0:  # 检查输入的数字是否为正整数\n                print(\"输入数字有误，请输入正负整数\")\n            else:\n                break  # 如果输入有效，则退出当前的 while 循环\n        except (ValueError,TypeError):\n            print(\"输入数字有误，请输入正负整数\")\nx, y, z = numbers1 # 将输入的数字赋值给 x, y, z\ntime1 = list1[time] #将时间对应时辰\ntime2 = dict1.get(time1,'无效值') #调用字典将时辰与数字对应，time1上不用加''\ntime3 = time2%6 #对time2取余数，可知龙头宫位\nwhole = 6-time3 #得出青龙后还有几个元素作为整体\nelement=list11[:whole+1] #将青龙以及后面的元素作为整体\nx1,y1,z1= (x-1)%6,(x+y-2)%6,(x+y+z-3)%6 #分别取余数\nx2,y2,z2 = list2[x1],list2[y1],list2[z1] #分别给三才赋值六宫\nx3,y3,z3 = list3[x1],list3[y1],list3[z1] #分别给三才赋值五行\nx4,y4,z4 = list4[x1],list4[y1],list4[z1] #分别给三才赋值方位\nif time3 == 1:\n   list12=list11\nelif time3 == 0:\n   list12=['朱雀','勾陈','白虎','玄武','腾蛇','青龙']\nelse:\n   list12=[x for x in list11 if x not in element]+element #先遍历列表8不属于整体的元素再加上整体中的元素生成新列表10\nx5,y5,z5 = list5[x1],list5[y1],list5[z1] #分别给三才赋值六神\nx6,y6,z6 = list12[x1],list12[y1],list12[z1] #分别给三才赋值活六神\nnumber1,number2,number3 = dict2.get(x3),dict2.get(y3),dict2.get(z3) #调用字典将五行与列表数字对应\nlist13,list14,list15=globals()[f'list{number1}'],globals()[f'list{number2}'],globals()[f'list{number3}'] #使用globals()作用于全局区别于locals()只能在一个函数局部内返回变量，生成三才对应的十二长生列表\nx7,y7,z7 =list13[time2-1],list14[time2-1],list15[time2-1]\ntime_len = len(str(time))\nif time_len == 1:\n   print('时间','',time,'  ',time1)\nelse:\n   print('时间','',time,' ',time1)\nprint(x2,y2,z2)\nprint('',x3,' ',y3,' ',z3)\ndef print_xyz(x,y,z): #封装成函数\n   x_len,y_len,z_len = len(x),len(y),len(z)\n   if x_len == 1 and y_len == 1 and z_len == 1:\n      print('', x, ' ', y, ' ', z)\n   elif x_len == 2 and y_len == 1 and z_len == 1:\n      print(x, '', y, ' ', z)\n   elif x_len == 2 and y_len == 2 and z_len == 1:\n      print(x, y, '', z)\n   elif x_len == 2 and y_len == 1 and z_len == 2:\n      print(x, '', y, '', z)\n   elif x_len == 1 and y_len == 2 and z_len == 1:\n      print('', x, '', y, '', z)\n   elif x_len == 1 and y_len == 2 and z_len == 2:\n      print('', x, '', y, z)\n   elif x_len == 1 and y_len == 1 and z_len == 2:\n      print('', x, ' ', y, '', z)\n   else:\n      print(x, y, z)\nprint_xyz(x4,y4,z4) #调用函数\nprint(x5,y5,z5)\nprint(x6,y6,z6)\nprint_xyz(x7,y7,z7) #调用函数\ninput(\"按下Enter退出\")\n```\n\n\n\n\n\n","tags":["术数"]},{"title":"第一篇文章","url":"/2025/02/08/1/","content":"\n123\n"},{"title":"Hello World","url":"/2025/02/08/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]